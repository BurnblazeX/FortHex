<html lang="en" style="--p1-color-secondary: #60B0E0; --p2-color-secondary: #F05040;"><head><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (typeof arg === 'object') {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    const errorString = stringifyArgs(args);
    window.parent.postMessage({ type: 'error', message: errorString }, '*');
    originalConsoleError.apply(console, args);
  };

  window.addEventListener('error', function(event) {
    const errorString = event.message + ' (' + event.filename + ':' + event.lineno + ':' + event.colno + ') ' + (event.error ? event.error.stack : '');
    window.parent.postMessage({ type: 'error', message: errorString }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FortHex</title>
        <link rel="icon" href="data:image/svg+xml,&lt;svg version='1.1' xmlns='http://www.w3.org/2000/svg' width='300' height='300'&gt;&lt;path d='M0,0 L6,0 L31,13 L52,25 L80,41 L106,56 L119,64 L119,200 L104,209 L78,224 L55,237 L32,250 L10,262 L6,264 L0,264 L-23,252 L-46,239 L-74,223 L-100,208 L-113,200 L-113,64 L-91,51 L-65,36 L-37,20 L-10,5 Z ' fill='%23000000' transform='translate(147,18)'/&gt;&lt;path d='M0,0 L4,2 L17,24 L29,44 L39,61 L54,86 L67,108 L83,135 L98,160 L107,175 L107,179 L92,188 L83,193 L80,192 L63,163 L49,139 L34,113 L20,89 L5,63 L-11,36 L-23,15 L-22,12 L-6,3 Z ' fill='%23F8BD28' transform='translate(108,54)'/&gt;&lt;path d='M0,0 L6,2 L30,16 L55,30 L79,44 L79,47 L52,62 L28,76 L12,85 L9,82 L-8,53 L-17,38 L-28,19 L-27,16 L-6,3 Z ' fill='%2333485D' transform='translate(149,30)'/&gt;&lt;path d='M0,0 L2,0 L2,90 L-9,96 L-25,105 L-27,105 L-43,78 L-55,58 L-66,39 L-62,35 L-34,19 L-16,9 L-6,3 Z ' fill='%232B3D4F' transform='translate(253,121)'/&gt;&lt;path d='M0,0 L5,0 L16,7 L16,24 L6,30 L-21,45 L-42,57 L-56,65 L-60,64 L-70,47 L-72,42 L-54,31 L-33,19 L-12,7 Z ' fill='%23C13F3F' transform='translate(239,83)'/&gt;&lt;path d='M0,0 L4,1 L14,17 L15,23 L0,32 L-26,47 L-44,57 L-58,65 L-68,60 L-72,56 L-72,41 L-59,33 L-34,19 L-11,6 Z ' fill='%233F3FC1' transform='translate(117,153)'/&gt;&lt;/svg&gt;">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&amp;family=Geostar&amp;display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Exo 2', sans-serif;
            background-color: var(--bg-color);
            color: #F0F0F0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            padding-bottom: 100px;
            box-sizing: border-box; 
            overflow-x: auto;
        }
        #gameWrapper {
            min-width: 1300px; /* Force a minimum width to ensure layout doesn't break */
            transform-origin: top center; /* Scale from the top center */
            transition: transform 0.2s ease-in-out; /* Smooth scaling transition */
            padding-top: 60px; /* Add space at the top so it doesn't overlap the header icons */
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #4a6075;
            border-radius: 5px;
            height: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3090D0;
            cursor: pointer;
            border: 3px solid #F0F0F0;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3090D0;
            cursor: pointer;
            border: 3px solid #F0F0F0;
        }

        .settings-option:has(input:disabled) label,
        .settings-option:has(input:disabled) span {
            color: #809090;
            cursor: not-allowed;
        }
        input[type="range"]:disabled {
            background: #2c3e50;
            cursor: not-allowed;
        }
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #809090;
            cursor: not-allowed;
        }
        input[type="range"]:disabled::-moz-range-thumb {
            background: #809090;
            cursor: not-allowed;
        }

        input[type="checkbox"]:disabled {
            background: #4a6075;
            border-color: #809090;
            cursor: not-allowed;
        }
        input[type="checkbox"]:disabled::before {
            box-shadow: inset 1em 1em #809090;
        }

        h1.text-4xl {
             font-family: 'Geostar', cursive;
        }

#confettiContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allows clicks to go through to the game */
    z-index: 9999; /* On top of everything */
    overflow: hidden;
}

.confetti-piece {
    position: absolute;
    width: 10px;
    height: 20px;
    opacity: 0.9;
    transform-origin: center;
}

#connectionStatusContainer {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 2000;
}

#connectionStatusIcon {
    /* Sets the transition target to the 'color' property */
    transition: color 0.4s ease-in-out;
}
.status-online {
    /* We now control the color using the standard CSS 'color' property */
    color: #2ecc71; 
}
.status-offline {
    color: #E04030; /* Bright Red */
}

#topLeftControlsContainer {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 2000;
    display: flex;
    align-items: center;
    gap: 15px;
}
#gameMenuTrigger {
    background-color: #34495e;
    border: 2px solid #F0F0F0;
    border-radius: 8px;
    padding: 6px 15px;
    cursor: pointer;
    transition: background-color 0.3s;
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 1.2em;
    font-weight: bold;
}

#gameIconLink {
    background-color: transparent;
    border: none;
    padding: 5px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background-color 0.3s;
}

#gameMenuTrigger:hover {
    background-color: #4a6075;
}
#gameIconLink:hover {
    background-color: rgba(74, 96, 117, 0.5);
}
.menu-options-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 100%;
}
.menu-options-container .action-button {
    width: 100%;
    padding: 12px 20px;
    font-size: 1.1em;
    margin: 0;
}

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 12px 8px;
            background-color: var(--bg-color);
            border-radius: 5px;
            margin-bottom: 12px;
            border: 1px solid #4a6075;
        }

        .settings-option label {
            font-size: 1.1em;
            color: #F0F0F0;
            cursor: pointer;
        }

        .settings-option input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            background-color: #4a6075;
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.6em;
            height: 1.6em;
            border: 0.15em solid #809090;
            border-radius: 0.25em;
            transform: translateY(-0.075em);
            display: grid;
            place-content: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .settings-option input[type="checkbox"]::before {
            content: "";
            width: 0.9em; 
            height: 0.9em;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            background-color: #20B060; 
            transform-origin: center; 
        }

        .settings-option input[type="checkbox"]:checked {
            border-color: #304860; 
        }

        .settings-option input[type="checkbox"]:checked::before {
            transform: scale(1);
        }

        #gameLayoutContainer {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            padding-left: 10px;
            padding-right: 10px;
            box-sizing: border-box;
        }
        canvas {
            background-color: var(--panel-color);
            border-radius: 10px;
            display: block;
            cursor: default;
            touch-action: none;
        }

        .ui-panel {
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #F0F0F0;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 0 0 280px;
            box-sizing: border-box;
            min-height: 595px;
            justify-content: flex-start;
            position: relative;
        }

        #turnDisplay {
            font-size: 1.5em;
            margin-bottom: 0;
            color: #FFC020;
            text-align: center;
        }

        .ui-panel p {
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .buttons-container { /* This is the PARENT container for bottom buttons */
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: center;
            gap: 0; /* Gaps are handled by margins now */
            margin-top: auto; /* Pushes the whole block to the bottom */
            padding-top: 15px;
        }
        .ui-panel .buttons-container button { /* End Turn specifics */
             background-color: #E04030;
             box-shadow: 0 3px #C03020;
             color: white;
             border: none;
             padding: 10px 15px;
             border-radius: 5px;
             font-family: 'Exo 2', sans-serif;
             cursor: pointer;
             transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
             display: flex;
             align-items: center;
             justify-content: center;
             gap: 8px;
        }
        .ui-panel .buttons-container button:hover:not(:disabled) {
            background-color: #C03020;
        }
         .ui-panel .buttons-container button:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }

        #settingsButton:hover:not(:disabled) {
        background-color: #708080;
    }

        #generateMapButtonContainer {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-top: 20px; /* Space above button container */
            margin-bottom: 20px; /* Space below button container */
        }

        #downloadButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #27B060; 
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            box-shadow: 0 4px #208050; 
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 1001;
        }
        #downloadButton:hover:not(:disabled) {
            background-color: #208050; 
            box-shadow: 0 4px #207040; 
        }
        #downloadButton:active:not(:disabled) {
            box-shadow: 0 1px #207040; 
            transform: translateY(3px);
        }
        #downloadButton svg {
            width: 28px;
            height: 28px;
            stroke: white;
        }

        #tutorialButton {
            position: fixed;
            bottom: 90px; 
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #9040B0; 
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            box-shadow: 0 4px #703090;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 1002;
        }
        #tutorialButton:hover:not(:disabled) {
            background-color: #703090; 
            box-shadow: 0 4px #502070; 
        }
        #tutorialButton:active:not(:disabled) {
            box-shadow: 0 1px #502070; 
            transform: translateY(3px);
        }
        #tutorialButton svg {
            width: 32px; 
            height: 32px;
            fill: white; 
        }


        .action-button {
            background-color: #3090D0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 3px #2080B0;
            margin-left: 5px;
            margin-right: 5px;
        }
    .action-button.selecting {
        background-color: #E04030; /* Red base for cancel state */
        box-shadow: 0 3px #C03020;
    }
    .action-button.selecting:hover:not(:disabled) {
        background-color: #C03020; /* Dark red on hover */
    }
    .action-button:not(.selecting):hover:not(:disabled) {
         background-color: #2080B0;
    }
    .action-button:disabled {
        background-color: #90A0A0;
        color: #bdc3c7;
        cursor: not-allowed;
        box-shadow: 0 3px #809090;
    }
    .action-button:active:not(:disabled) {
         box-shadow: none;
        transform: translateY(3px);
    }

    /* --- Corrected Cancel Button Rules --- */
    .action-button-cancel {
        background-color: #E04030;
        box-shadow: 0 3px #C03020;
    }
    /* By specifying both classes, this rule becomes more specific and will override the generic blue hover. */
    .action-button.action-button-cancel:hover:not(:disabled) {
        background-color: #C03020;
    }
        #generateMapButtonContainer .action-button {
            width: 160px; 
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 15px; 
            margin: 0; 
        }

        #saveGameButton {
            background-color: #F0A010; 
            box-shadow: 0 3px #D05000;
        }
        #saveGameButton:hover:not(:disabled) {
            background-color: #E08020;
        }
        #saveGameButton:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }
        #loadGameButton {
            background-color: #60B0E0; 
            box-shadow: 0 3px #3090D0;
        }
        #loadGameButton:hover:not(:disabled) {
            background-color: #3090D0;
        }
         #loadGameButton:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }

        #saveGameButton:disabled,
        #loadGameButton:disabled,
        #newMapButton:disabled {
            background-color: #90A0A0;
            color: #bdc3c7;
            cursor: not-allowed;
            box-shadow: 0 3px #809090;
        }

        .unit-info-container {
            width: 100%;
        }
        .unit-info-container p { font-size: 1em; margin: 4px 0; }

        .actions-panel {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }
        .actions-panel h3 {
            font-size: 1.em;
            color: #FFC020;
            width: 100%;
            text-align: center;
        }
        .message-box {
            position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%); background-color: #E04030;
            color: white; padding: 15px 25px; border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 2001;
            font-size: 1em; display: none;
            text-align: center;
            max-width: 90%;
        }
        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2ecc71;
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            z-index: 2000;
            font-size: 2em;
            text-align: center;
            display: none;
        }
        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 3000; 
            opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
        }
        .modal-overlay.modal-visible { 
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0s; 
        }

        .modal-content {
            background-color: var(--panel-color);
            padding: 25px 30px;
            border-radius: 10px;
            border: 2px solid #F0F0F0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 90%;
            max-width: 400px;
            color: #F0F0F0;
            position: relative;
        }
        .modal-content p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }
        .modal-buttons button {
            font-family: 'Exo 2', sans-serif;
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s, box-shadow 0.3s;
            color: white;
        }
        .modal-button-ok {
            background-color: #20B060;
            box-shadow: 0 3px #208040;
        }
        .modal-button-ok:hover {
            background-color: #209050;
        }
        .modal-button-cancel {
            background-color: #E04030;
            box-shadow: 0 3px #C03020;
        }
        .modal-button-cancel:hover {
            background-color: #C03020;
        }

#loadOptionsContainer .action-button {
    width: 100%;
    padding: 12px 20px;
    font-size: 1.1em;
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 0;
}
#loadFromAutosaveButton {
    background-color: #3090D0;
    box-shadow: 0 3px #2080B0;
}
#loadFromAutosaveButton:hover:not(:disabled) {
    background-color: #2080B0;
}
#loadFromFileButton {
    background-color: #20B060;
    box-shadow: 0 3px #208040;
}
#loadFromFileButton:hover:not(:disabled) {
    background-color: #209050;
}

#newMapButton {
    width: 160px;
    background-color: #FFC020; 
    box-shadow: 0 3px #D0B000;
}

#newMapButton:hover:not(:disabled) {
    background-color: #D0B000;
}

#selectMapButton {
    background-color: #20B060; /* Green */
    box-shadow: 0 3px #208040;
}
#selectMapButton:hover:not(:disabled) {
    background-color: #209050; /* Darker Green */
}
#selectMapButton:active:not(:disabled) {
    box-shadow: none;
    transform: translateY(3px);
}

#customMapButton {
    background-color: #F0A010; /* Orange */
    box-shadow: 0 3px #D05000;
}
#customMapButton:hover:not(:disabled) {
    background-color: #E08020; /* Darker Orange */
}
#customMapButton:active:not(:disabled) {
    box-shadow: none;
    transform: translateY(3px);
}

#customMapButton.return-to-game-button {
    background-color: #3090D0; /* Standard Blue */
    box-shadow: 0 3px #2080B0;
}
#customMapButton.return-to-game-button:hover:not(:disabled) {
    background-color: #2080B0; /* Darker Blue */
}

#newMapOptionsContainer {
    display: flex;
    justify-content: center;
    gap: 15px;
    width: 100%;
}

#generateMapFromModalButton {
    background-color: #9040B0; /* Purple */
    box-shadow: 0 3px #703090;
}
#generateMapFromModalButton:hover:not(:disabled) {
    background-color: #703090; /* Darker Purple */
}
#generateMapFromModalButton:active:not(:disabled) {
    box-shadow: none;
    transform: translateY(3px);
}

#generateMapFromModalButton:disabled {
    background-color: #90A0A0;
    color: #bdc3c7;
    cursor: not-allowed;
    box-shadow: 0 3px #809090;
}

.action-button-cancel {
    background-color: #E04030;
    box-shadow: 0 3px #C03020;
}
.action-button-cancel:hover:not(:disabled) {
    background-color: #C03020;
}

        /* Tutorial Modal Styles */
        #tutorialModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.7); 
            -webkit-backdrop-filter: blur(3px); 
            backdrop-filter: blur(3px);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 2900; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s; 
        }
        #tutorialModalOverlay.modal-visible { 
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0s; 
        }

        #tutorialModalContent {
            background-color: var(--panel-color);
            padding: 20px 30px;
            border-radius: 10px;
            border: 2px solid #F0F0F0;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            color: #F0F0F0;
            width: 90%;
            max-width: 700px; 
            max-height: 80vh; 
            overflow-y: auto;
            position: relative; 
            text-align: left; 
        }
        #tutorialModalContent h2 {
            font-family: 'Geostar', cursive;
            font-size: 2em;
            text-align: center;
            margin-bottom: 15px;
            color: #FFC020;
        }
        #tutorialModalContent p, #tutorialModalContent li {
            font-size: 0.95em;
            margin-bottom: 10px;
            line-height: 1.6;
        }
        #tutorialModalContent strong {
            color: #FFC020;
        }
        #tutorialModalContent ul {
            list-style-type: disc;
            padding-left: 20px;
            margin-bottom:10px;
        }
        .tutorial-modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #F0F0F0;
            font-size: 2em;
            cursor: pointer;
            line-height: 1;
        }
        .tutorial-modal-close-button:hover {
            color: #E04030;
        }
        .tutorial-section {
            margin-bottom: 15px;
            border-bottom: 1px solid #4a6075;
            padding-bottom: 10px;
        }
        .tutorial-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .tutorial-section-header {
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #20C0A0; 
        }
        .tutorial-section-header:hover {
            color: #10A080;
        }
        .tutorial-section-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            padding-left: 15px; 
            padding-top: 0px; 
            transition: max-height 0.35s ease-in-out, opacity 0.3s ease-in-out, padding-top 0.35s ease-in-out;
        }
        .tutorial-section-content.open {
            opacity: 1;
            padding-top: 5px; 
             max-height: 1000px; 
        }
        .tutorial-arrow {
            font-size: 0.8em;
            margin-left: 10px;
            transition: transform 0.2s ease-in-out;
        }
        .tutorial-section-header.active .tutorial-arrow {
            transform: rotate(90deg);
        }

        .action-info-header {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #FFC020;
            width: 100%;
            text-align: center;
            font-weight: bold;
        }
        
         #actionInfoContainer {
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        #actionLogWrapper {
            position: relative;
            height: 400px; 
        }

        #actionLogWrapper::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(to bottom, rgba(48, 72, 96, 0), var(--panel-color) 75%);
            pointer-events: none;
            z-index: 5;
        }
        
        #actionLogWrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 50px;
            background: linear-gradient(to top, rgba(48, 72, 96, 0), var(--panel-color) 75%);
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }

        #actionLogWrapper.is-scrolled::before {
            opacity: 1; 
        }
        
        #actionLogContent {
            overflow-y: auto;
            padding-right: 10px;
            padding-bottom: 150px; 
            margin-right: -10px; 
            display: flex;
            flex-direction: column; 
            justify-content: flex-start;
            height: 100%;
        }

        #actionLogContent::-webkit-scrollbar {
            width: 8px;
        }
        #actionLogContent::-webkit-scrollbar-track {
            background: #2c3e50;
            border-radius: 4px;
        }
        #actionLogContent::-webkit-scrollbar-thumb {
            background: #4a6075;
            border-radius: 4px;
        }
        #actionLogContent::-webkit-scrollbar-thumb:hover {
            background: #5e7a97;
        }
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px;
            background-color: var(--bg-color);
            border-radius: 4px;
            margin-top: 5px;
            animation: fadeIn 0.3s ease-in-out;
            transition: border-color 0.4s ease-in-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .log-entry.log-p1 {
            border: 2px solid #5dade2; 
        }
        .log-entry.log-p2 {
            border: 2px solid #E04030; 
        }

        .log-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            margin-top: 0px;
        }
        .log-message {
            font-size: 0.9em;
            line-height: 1.5;
            color: #bdc3c7;
            word-break: break-word;
        }
        .log-message strong { font-weight: bold; }
        .p1-log { color: #5dade2 !important; } 
        .p2-log { color: #E04030 !important; }
        .log-message .damage-text { color: #FFC020; }
        .log-message .heal-text { color: #2ecc71; }
        .log-message .shield-text { color: #30C4C4; }
        .log-message .advantage-text { color: #2ecc71; }
        .log-message .disadvantage-text { color: #E04030; }
        .log-message .keyword-text { color: #F0A010; }

        .respawn-queue-container {
            border-top: 1px solid #809090;
            padding-top: 15px;
            position: absolute;
            bottom: 20px;       
            left: 20px;        
            right: 20px;        
            background-color: var(--panel-color); 
        }
        .respawn-queue-header {
            text-align: center;
            color: #FFC020;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .respawn-queue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .respawn-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--bg-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .respawn-unit-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .respawn-unit-symbol {
            font-weight: bold;
            font-size: 1.2em;
        }
        .respawn-timer {
            font-weight: bold;
            color: #FFC020;
        }

        /* RESPAWN MODAL STYLES */
        #respawnModalContent {
            text-align: center;
            width: auto;
            max-width: 500px;
            /* Border color will be set by JS */
            transition: border-color 0.3s ease-in-out; 
        }
        #respawnModalContent.modal-p1 { border-color: #5dade2; }
        #respawnModalContent.modal-p2 { border-color: #E04030; }

        #respawnModalContent h3 {
            font-family: 'Geostar', cursive;
            font-size: 1.8em;
            color: #FFC020;
            margin-bottom: 10px;
        }
        #respawnModalContent p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        #respawnChoices {
            display: flex; 
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .respawn-button {
            background-color: #20B060; 
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%; 
            font-family: 'Exo 2', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.2s;
            box-shadow: 0 4px #208040; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .respawn-button svg {
            width: 40px;
            height: 40px;
            stroke: white;
            fill: white;
        }
        .respawn-button:hover:not(:disabled) {
            background-color: #209050;
            transform: translateY(-2px);
        }
        .respawn-button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px #208040;
        }
        .respawn-button:disabled {
            background-color: #809090;
            cursor: not-allowed;
            box-shadow: 0 4px #525a5b;
            opacity: 0.6;
        }
        #buildVersionDisplay {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 0.8em;
            color: #F0F0F0;
            opacity: 0.6;
            z-index: 1000;
            pointer-events: none; /* Prevents it from blocking clicks on anything underneath */
        }

/* --- ARCADE MODE STYLES --- */
#endTurnButton.arcade-timer-active {
    position: relative;
    z-index: 1;
    overflow: hidden;
    color: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.5);
    /* Background is handled by JS gradient */
    transition: background-color 0s !important; 
}

/* Reuse Respawn Modal for Swap Phase */
#respawnModalContent.swap-mode {
    border-color: #9b59b6 !important; /* Purple */
}
#respawnModalContent.swap-mode h3 {
    color: #9b59b6 !important;
}

    </style>
    <style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.mb-6{margin-bottom:1.5rem}.text-center{text-align:center}.text-4xl{font-size:2.25rem;line-height:2.5rem}.font-bold{font-weight:700}.text-amber-400{--tw-text-opacity:1;color:rgb(251 191 36 / var(--tw-text-opacity, 1))}</style>
        <style>
        :root {
            --p1-color-secondary: #60B0E0;
            --p2-color-secondary: #F05040;
            --bg-color: #304050;
            --panel-color: #304860;
        }
        #turnDisplay.player1, .log-entry.log-p1, #respawnModalContent.modal-p1 {
            border-color: var(--p1-color-secondary);
        }
        #turnDisplay.player2, .log-entry.log-p2, #respawnModalContent.modal-p2 {
            border-color: var(--p2-color-secondary);
        }
        .p1-log, #p1Supply {
            color: var(--p1-color-secondary) !important;
        }
        .p2-log, #p2Supply {
            color: var(--p2-color-secondary) !important;
        }

        #p1Supply, #p2Supply {
            transition: color 0.4s ease-in-out;
        }
        
        .log-message strong {
            transition: color 0.4s ease-in-out;
        }

        #turnDisplay {
            transition: border-color 0.4s ease-in-out;
        }
        #gameCanvas {
             outline-width: 4px;
             outline-style: solid;
             outline-offset: 2px;
             transition: outline-color 0.4s ease-in-out;
        }


/* --- Color Picker Drawer Styles --- */
#colorPickerDrawer {
    position: fixed;
    top: 50%;
    right: -130px;
    width: 130px;
    transform: translateY(-50%);
    background-color: var(--panel-color);
    border: 2px solid #F0F0F0;
    border-right: none;
    border-radius: 15px 0 0 15px;
    z-index: 2500;
    box-shadow: -5px 0 15px rgba(0,0,0,0.3);
    /* Explicitly define all transitions here */
    transition-property: right, border-color;
    transition-duration: 0.4s, 0.4s;
    transition-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94), ease-in-out;
}

#colorPickerDrawer.drawer-open {
    /* End position: drawer is flush with the right edge */
    right: 0;
}

#drawerHandle {
    position: absolute;
    top: 50%;
    left: -40px; /* Adjusted handle width */
    transform: translateY(-50%);
    width: 40px; /* Adjusted handle width */
    height: 70px;
    background-color: var(--panel-color);
    border: 2px solid #F0F0F0;
    border-right: none;
    border-radius: 12px 0 0 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #F0F0F0;
    transition: border-color 0.4s ease-in-out;
}

#drawerHandle svg {
    stroke: #F0F0F0;
    transition: transform 0.3s ease-in-out, stroke 0.4s ease-in-out;
}

#colorPickerDrawer.drawer-open #drawerHandle svg {
    transform: rotate(90deg);
}

#drawerContent {
    padding: 20px;
    height: 400px; /* Example height */
    display: flex;
    flex-direction: column;
}

#drawerTabs {
    display: flex;
    border-bottom: 2px solid #4a6075;
    margin-bottom: 15px;
}

.drawer-tab-button {
    flex-grow: 1;
    padding: 10px;
    background-color: transparent;
    border: none;
    color: #bdc3c7;
    font-size: 1.1em;
    font-family: 'Exo 2', sans-serif;
    font-weight: bold;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: color 0.4s ease-in-out, border-color 0.4s ease-in-out;
}

.drawer-tab-button:hover {
    color: #F0F0F0;
}

.drawer-tab-button.active.p1-tab {
    color: var(--p1-color-secondary);
    border-bottom-color: var(--p1-color-secondary);
}
.drawer-tab-button.active.p2-tab {
    color: var(--p2-color-secondary);
    border-bottom-color: var(--p2-color-secondary);
}

.drawer-tab-panel {
    display: none; /* Hide all panels by default */
}

.drawer-tab-panel.active {
    display: block; /* Show only the active panel */
}

.color-options-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center; /* Center the whole group vertically */
    gap: 10px; 
    padding-top: 15px;
    padding-bottom: 15px;
    width: 100%;
    height: 100%; 
}

.color-option-circle {
    width: 45px;  /* Increased size */
    height: 45px; /* Increased size */
    border-radius: 50%;
    background-color: #4a6075; 
    border: 3px solid #bdc3c7; /* A slightly thicker border */
    cursor: pointer;
    transition: transform 0.2s ease-in-out, border-color 0.2s ease-in-out, background-color 0.4s ease-in-out; 
}

.color-option-circle:hover {
    transform: scale(1.1);
    border-color: #F0F0F0; /* Brighten border on hover */
}

.color-option-circle.active {
    border-color: #FFC020;
    transform: scale(1.15);
}

#changelogButton {
    background-color: #20B060;
    box-shadow: 0 3px #208040;
}
#changelogButton:hover:not(:disabled) {
    background-color: #209050;
}

/* --- Main Menu Button Colors --- */
#singleplayerButton {
    background-color: #E07060; /* Faded Red */
    box-shadow: 0 3px #C05040;
}
#singleplayerButton:hover:not(:disabled) {
    background-color: #D06050; /* Darker Faded Red */
}

    </style>
<style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.mb-6{margin-bottom:1.5rem}.text-center{text-align:center}.text-4xl{font-size:2.25rem;line-height:2.5rem}.font-bold{font-weight:700}.text-amber-400{--tw-text-opacity:1;color:rgb(251 191 36 / var(--tw-text-opacity, 1))}</style></head>
<body>
<h1 class="text-4xl font-bold mb-6 text-center text-amber-400">FortHex</h1>

<div id="connectionStatusContainer">       
<svg id="connectionStatusIcon" fill="currentColor" height="34" width="34" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 494.45 494.45" class="status-online">
        <g>
            <path d="M395.225,277.325c-6.8,0-13.5-2.6-18.7-7.8c-71.4-71.3-187.4-71.3-258.8,0c-10.3,10.3-27.1,10.3-37.4,0 s-10.3-27.1,0-37.4c92-92,241.6-92,333.6,0c10.3,10.3,10.3,27.1,0,37.4C408.725,274.725,401.925,277.325,395.225,277.325z"></path>
            <path d="M323.625,348.825c-6.8,0-13.5-2.6-18.7-7.8c-15.4-15.4-36-23.9-57.8-23.9s-42.4,8.5-57.8,23.9 c-10.3,10.3-27.1,10.3-37.4,0c-10.3-10.3-10.3-27.1,0-37.4c25.4-25.4,59.2-39.4,95.2-39.4s69.8,14,95.2,39.5 c10.3,10.3,10.3,27.1,0,37.4C337.225,346.225,330.425,348.825,323.625,348.825z"></path>
            <circle cx="247.125" cy="398.925" r="35.3"></circle>
            <path d="M467.925,204.625c-6.8,0-13.5-2.6-18.7-7.8c-111.5-111.4-292.7-111.4-404.1,0c-10.3,10.3-27.1,10.3-37.4,0 s-10.3-27.1,0-37.4c64-64,149-99.2,239.5-99.2s175.5,35.2,239.5,99.2c10.3,10.3,10.3,27.1,0,37.4 C481.425,202.025,474.625,204.625,467.925,204.625z"></path>
        </g>
    </svg>
</div>

<!-- MENU TRIGGER BUTTON -->
<div id="topLeftControlsContainer">
    <a id="gameIconLink" title="Restart Game">
        <svg version="1.0" width="38" height="38" viewBox="0 0 225 225" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <g transform="translate(0,225)scale(.075,.075)">
                <path fill="white" d="M 929 -2512 c -294 169 -547 315 -562 325 l -27 17 0 670 0 670 37 24 c 21 13 275 160 565 325 372 212 537 301 558 301 21 0 186 -89 558 -301 290 -165 544 -312 564 -325 l 38 -24 0 -670 0 -670 -38 -24 c -20 -13 -274 -160 -564 -325 -404 -231 -535 -301 -560 -300 -24 0 -177 82 -569 307 z m 972 39 l 397 227 -297 169 c -163 93 -319 182 -347 198 l -51 29 -196 -329 c -108 -182 -198 -335 -199 -342 -2 -10 273 -179 292 -179 3 0 183 102 401 227 z m -506 503 c 158 267 393 661 521 877 129 216 237 398 239 405 4 9 -39 39 -126 88 -72 41 -133 74 -136 73 -4 -2 -251 -423 -528 -903 -172 -297 -495 -852 -510 -875 -12 -20 -6 -25 113 -93 70 -39 130 -68 133 -64 3 4 136 225 294 492 z m 1143 -137 c 9 7 12 35 10 94 l -3 85 -370 208 c -203 115 -370 208 -371 207 -12 -13 -134 -225 -134 -232 0 -5 168 -105 373 -222 l 372 -211 55 31 c 30 16 61 35 68 40 z m 10 764 l -3 447 -135 78 c -74 43 -138 78 -141 78 -7 0 -399 -656 -399 -668 1 -7 659 -381 673 -382 4 0 6 201 5 447 z m -1281 -22 c 35 61 62 113 61 117 -2 5 -170 102 -373 217 l -370 209 -55 -30 c -83 -47 -80 -42 -80 -129 l 0 -78 368 -210 c 202 -115 371 -209 376 -207 5 1 38 51 73 111 z "></path>
            </g>
        </svg>
    </a>
    <a id="gameMenuTrigger">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
    Menu
</a>
</div>

<!-- ARCADE TIMER UI -->
<div id="arcadeTimerContainer" style="position: absolute; top: 80px; left: 50%; transform: translateX(-50%); width: 400px; display: none; z-index: 1500; flex-direction: column; align-items: center;">
    <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 5px; color: #F0F0F0; font-weight: bold; text-shadow: 1px 1px 2px black;">
        <span id="arcadeTimerLabel">Time Remaining</span>
        <span id="arcadeTimerValue">45s</span>
    </div>
    <div style="width: 100%; height: 12px; background-color: #34495e; border: 2px solid #F0F0F0; border-radius: 6px; overflow: hidden;">
        <div id="arcadeTimerBar" style="width: 100%; height: 100%; background-color: #2ecc71; transition: width 0.1s linear, background-color 0.3s;"></div>
    </div>
</div>

<!-- UNIFIED GAME MENU MODAL -->
<div id="gameMenuModal" class="modal-overlay">
    <div class="modal-content">
        <button id="mainMenuCloseButton" class="tutorial-modal-close-button" title="Close"></button>
        <!-- Main Menu Content (Visible by default) -->
        <div id="mainMenuContent">
            <h2 class="text-4xl" style="font-family: 'Geostar', cursive; color: #FFC020; margin-bottom: 30px;">Main Menu</h2>
            <div class="menu-options-container">
                <button id="singleplayerButton" class="action-button">Singleplayer (WIP)</button>
                <button id="multiplayerButton" class="action-button">Multiplayer</button>
                <button id="changelogButton" class="action-button">Changelog</button>
                <button id="settingsButton" class="action-button" style="background-color: #90A0A0; box-shadow: 0 3px #708080; margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    Settings
                </button>
            </div>
        </div>

        <!-- Singleplayer Menu Content (Hidden by default) -->
        <div id="singleplayerMenuContent" style="display: none;">
            <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Choose Your Side</h3>
            <div class="menu-options-container">
                <button id="playAsBlueButton" class="action-button" style="background-color: #5dade2; box-shadow: 0 3px #3090D0;">Play as Blue (P1)</button>
                <button id="playAsRedButton" class="action-button" style="background-color: #E04030; box-shadow: 0 3px #C03020;">Play as Red (P2)</button>
            </div>
            <button id="backToMainMenuButtonSP" class="action-button action-button-cancel" style="margin-top: 25px;">Back</button>
        </div>

        <!-- Multiplayer Menu Content (Hidden by default) -->
        <div id="multiplayerMenuContent" style="display: none;">
             <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Multiplayer</h3>
            <div class="menu-options-container">
                <button id="localMultiplayerButton" class="action-button">Local</button>
                <button id="onlineMultiplayerButton" class="action-button" disabled="">Online (Coming Soon)</button>
            </div>
             <button id="backToMainMenuButtonMP" class="action-button action-button-cancel" style="margin-top: 25px;">Back</button>
        </div>
    </div>
</div>

<!-- SETTINGS MODAL -->
<div id="settingsModal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Settings</h3>
        <div id="settingsOptionsContainer">
            <div class="settings-option">
                <label for="settingFancyVisuals">Fancy Visuals</label>
                <input type="checkbox" id="settingFancyVisuals" name="fancyVisuals" checked="">
            </div>
            <div class="settings-option">
                <label for="settingAnimations">Animations</label>
                <input type="checkbox" id="settingAnimations" name="animations" checked="">
            </div>
            <div class="settings-option">
                <label for="settingPassTurnConfirmation">Pass Turn Confirmation</label>
                <input type="checkbox" id="settingPassTurnConfirmation" name="passTurnConfirmation" checked="">
            </div>
            <div class="settings-option">
                <label for="settingTooltips">Tooltips</label>
                <input type="checkbox" id="settingTooltips" name="tooltips" disabled="">
            </div>
            <div class="settings-option" style="flex-direction: column; align-items: flex-start; padding-top: 15px; padding-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 10px;">
                    <label for="settingUiScale">UI Scale</label>
                    <span id="uiScaleValueLabel">NaN%</span>
                </div>
                <input type="range" id="settingUiScale" min="0.5" max="1.5" value="1" step="0.05" style="width: 100%;" disabled="">
            </div>

    
        </div>
        <button id="settingsBackButton" class="action-button action-button-cancel" style="margin-top: 30px; width: 100%;">Back</button>
    </div>
</div>

<!-- COMPLETE CHANGELOG MODAL -->
<div id="changelogModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 500px; text-align: left;">
        <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px; text-align: center;">Changelog</h3>
        <div id="changelogList" style="max-height: 50vh; overflow-y: auto; padding-right: 15px;">

            <h4 style="font-weight: bold; color: #20C0A0; margin-bottom: 10px; font-size: 1.2em;">B28 Patch 2</h4>
            <ul style="list-style-type: none; padding-left: 0;">
                <!-- Features -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Features</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Map Maker Fill Tool:</strong> Added a new "Fill" (paint bucket) tool to the Options panel, allowing for rapid painting of large, contiguous areas of terrain.</li>
                    </ul>
                </li>
                <!-- Improvements -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Improvements</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Left Panel Layout Overhaul:</strong> The left UI panel no longer stretches. The Action Log is now a fixed-height, scrollable area, and the Reinforcements list is correctly anchored to the bottom.</li>
                        <li><strong>Action Log Polish:</strong> Added dynamic fade-out effects to the top and bottom of the Action Log to clearly indicate scrollable content.</li>
                        <li><strong>Action Log Functionality:</strong> Increased the log's capacity from 10 to 25 entries and inverted the display order to show the most recent actions at the top.</li>
                        <li><strong>Map Maker Palette:</strong> Slightly reduced the size of unit icons in the palette for a cleaner look and better panel spacing.</li>
                        <li><strong>Visual Consistency:</strong> Adjusted the color of Water tiles to be consistent between the 'Fancy' and 'Simple' rendering modes.</li>
                    </ul>
                </li>
                <!-- Fixes -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Fixes</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li>Fixed a critical bug in the Map Maker where placing a Mountain or Water tile would incorrectly remove units from adjacent valid edges (like beaches).</li>
                    </ul>
                </li>
            </ul>
            <hr style="border-color: #4a6075; margin: 20px 0;">

            <h4 style="font-weight: bold; color: #20C0A0; margin-bottom: 10px; font-size: 1.2em;">B28 Patch 1</h4>
            <ul style="list-style-type: none; padding-left: 0;">
                <!-- Features -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Features</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Map Maker "Test Map" Feature:</strong> Added a button to the editor to instantly test custom maps in a sandboxed gameplay session. The editor state is saved and perfectly restored upon exiting the test.</li>
                    </ul>
                </li>
                <!-- Improvements -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Improvements</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Supply Lines Over Bridges:</strong> Supply lines can now correctly pathfind across built bridges.</li>
                        <li><strong>Editor UI Polish:</strong> Added a white canvas border, dividers to panels, and improved spacing and layout for a cleaner, more professional look.</li>
                        <li><strong>Visuals:</strong> Adjusted rendering order to ensure units and animations always appear correctly on top of bridges. Updated the UI theme to a brighter white.</li>
                    </ul>
                </li>
                <!-- Fixes -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Fixes</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li>Fixed a critical bug where returning to Local Multiplayer from Singleplayer would not reset the game state correctly.</li>
                        <li><strong>Map Maker Fixes:</strong> Resolved bugs preventing unit placement on beaches, allowing enemy units on the same edge, and incorrect visual selection in the unit palette.</li>
                        <li>Added validation to the "Test Map" feature to require units for both players before starting a test.</li>
                    </ul>
                </li>
            </ul>
            <hr style="border-color: #4a6075; margin: 20px 0;">

            <h4 style="font-weight: bold; color: #20C0A0; margin-bottom: 10px; font-size: 1.2em;">B28: The Editor Update</h4>
            <ul style="list-style-type: none; padding-left: 0;">
                <!-- Features -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Features</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Custom Map Maker:</strong> A full-featured editor to create, save, and share battlefields, complete with a tile/unit palette and a base camp rotation slider.</li>
                        <li><strong>New Map File System (.fhmap):</strong> Save and load custom maps with a new lightweight file format, including autosave support for the editor.</li>
                    </ul>
                </li>
                <!-- Improvements -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Improvements</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Traversable Beaches:</strong> Edges between Land and Water are now playable terrain with a movement cost of 3, and can be bridged by Melee units.</li>
                        <li><strong>Visual & UI Overhaul:</strong> Added pulsating bridge highlights, modernized the Settings checkboxes with a new green square style, and applied consistent colors and 'X' close buttons to all modals.</li>
                        <li><strong>Quality of Life:</strong> Implemented a "Return to Game" button for the editor, improved click detection for bridge building, and added extensive validation rules for map creation.</li>
                    </ul>
                </li>
                <!-- Fixes -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Fixes</strong>
                    <p style="font-style: italic; font-size: 0.85em; color: #bdc3c7; margin-top: 5px; margin-bottom: 5px; padding-left: 20px;">(Note: Most fixes are compared to the in-development version, addressing bugs introduced during the B28 development cycle.)</p>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li>Fixed critical bugs preventing units from regaining movement points, healing, and achieving a Capture the Flag victory.</li>
                        <li>Resolved a crash when generating a new map, and fixed a visual bug causing duplicated units on generated maps.</li>
                        <li>Fixed an animation bug allowing units to move while building a bridge.</li>
                        <li>Corrected several UI layout and styling issues in the Map Maker interface.</li>
                    </ul>
                </li>
            </ul>
            <hr style="border-color: #4a6075; margin: 20px 0;">

            <h4 style="font-weight: bold; color: #20C0A0; margin-bottom: 10px; font-size: 1.2em;">B27: The Color Update</h4>
            <ul style="list-style-type: none; padding-left: 0;">
                <!-- Features -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Features</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Team Color Customizer:</strong> Added a slide-out drawer to change between 5 distinct color themes for each player, with choices saved to the browser.</li>
                        <li><strong>Changelog System:</strong> Implemented this changelog modal to keep track of updates.</li>
                    </ul>
                </li>
                <!-- Improvements -->
                <li style="margin-bottom: 15px;">
                    <strong style="color: #F0C020; font-size: 1.1em;">Improvements</strong>
                    <ul style="list-style-type: disc; padding-left: 20px; margin-top: 5px;">
                        <li><strong>Complete Color System Overhaul:</strong> Unified all team and UI colors into a central, consistent system.</li>
                        <li><strong>Smooth Visual Transitions:</strong> All UI elements, units, and in-game highlights now transition their colors smoothly when a new theme is selected.</li>
                    </ul>
                </li>
            </ul>

        </div>
        <button id="changelogBackButton" class="action-button action-button-cancel" style="margin-top: 30px; width: 100%;">Back</button>
    </div>
</div>

<div id="gameLayoutContainer">
        <div id="leftPanel" class="ui-panel" style="min-height: 805px;">
            <div>
                <div id="globalTurnCounterDisplay" class="text-center" style="font-size: 1.5em; color: #FFC020;">Turn: 1</div>
                <div id="supplyPointsContainer" class="text-center" style="font-size: 0.9em; margin-top: 8px;">
                    <span>P1 Supply: <span id="p1Supply">10</span></span> | 
                    <span>P2 Supply: <span id="p2Supply">10</span></span>
                </div>
                <hr style="width: 100%; border-color: #4a6075; margin-top: 10px;">
            </div>
            <div id="selectedUnitInfoContainer" class="unit-info-container" style="display: none;">
                <div id="selectedUnitInfo">
                    <p><strong>Selected Unit:</strong> <span id="unitName"></span></p>
                    <p><strong>HP:</strong> <span id="unitHP"></span>/<span id="unitMaxHP"></span></p>
                    <p><strong>Movement:</strong> <span id="unitMovement"></span></p>
                    <p><strong>Position:</strong> <span id="unitPosition"></span></p>
                    <p><strong>Status:</strong> <span id="unitStatus"></span></p>
                </div>
            </div>
            <div id="actionInfoContainer" class="unit-info-container" style="display: block;">
                <h3 class="action-info-header">Action Log</h3>
                <div id="actionLogWrapper">
                    <div id="actionLogContent"></div>
                </div>
            </div>
            <!-- UNIFIED Respawn Queue Display -->
            <div id="reinforcementsContainer" class="respawn-queue-container" style="display: none;">
                <h4 class="respawn-queue-header">Reinforcements</h4>
                <div id="reinforcementsList" class="respawn-queue-list"></div>
            </div>
        </div>

        <canvas id="gameCanvas" width="909" height="805" style="outline-color: rgb(96, 176, 224); cursor: default;"></canvas>

        <div id="rightPanel" class="ui-panel" style="min-height: 805px;">
            <h2 id="turnDisplay">Player 1's Turn</h2>
            <hr id="gameplayDivider" style="width: 100%; border-color: #4a6075; margin-top: 15px; margin-bottom: 15px;">
            <div id="actionsPanel" class="actions-panel" style="display: none;">
                <h3>Actions</h3>
                <button id="fortifyUnfortifyButton" class="action-button">Fortify</button>
                <button id="buildBridgeButton" class="action-button">Build Bridge</button>
                <button id="attackButton" class="action-button">Attack</button>
            </div>
            <div id="bottomButtonsParent" class="buttons-container">
                <div id="testButtonContainer" style="display: none; width: 100%;">
                    <button id="testStopButton" class="action-button" style="width: 100%; margin: 0 0 15px 0;"></button>
                </div>
                <div id="endTurnButtonContainer" style="width: 100%;">
                    <button id="endTurnButton" style="width: 100%; margin: 0;">End Turn</button>
                </div>
            </div>
        </div>
    </div>

<div id="generateMapButtonContainer" style="display: flex; justify-content: center; gap: 15px; width: 100%; margin-top: 20px; margin-bottom: 20px;">
    <!-- SAVE GAME BUTTON -->
    <button id="saveGameButton" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
        </svg>
        Save Game
    </button>

    <!-- NEW MAP BUTTON -->
    <button id="newMapButton" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;">
            <polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon>
            <line x1="8" y1="2" x2="8" y2="18"></line>
            <line x1="16" y1="6" x2="16" y2="22"></line>
        </svg>
        New Map
    </button>

    <!-- LOAD GAME BUTTON -->
    <button id="loadGameButton" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
        </svg>
        Load Game
    </button>
</div>

<div id="gameWrapper"> 
    <div id="gameLayoutContainer">
        <!-- ... (left panel, canvas, right panel) ... -->
    </div>
    <div id="generateMapButtonContainer">
        <!-- ... (save, new map, load buttons) ... -->
    </div>
</div>

    <button id="tutorialButton" title="Game Tutorial">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"></path>
        </svg>
    </button>

    <button id="downloadButton" title="Download Game">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
    </button>

    <div id="messageBox" class="message-box" style="display: block;">Project Hexblade Loaded. Player 1's Turn.</div>
    <div id="victoryMessage" class="victory-message" style="display: none;"></div>

    <div id="customConfirmModal" class="modal-overlay" style="display: none;"> <!-- Will be controlled by JS -->
        <div class="modal-content">
            <p id="customConfirmMessage">Are you sure you want to generate a new map? This will reset the current game.</p>
            <div class="modal-buttons">
                <button id="customConfirmOkButton" class="modal-button-ok">Confirm</button>
                <button id="customConfirmCancelButton" class="modal-button-cancel">Cancel</button>
            </div>
        </div>
    </div>

<div id="loadGameModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <button id="loadGameModalCloseButton" class="tutorial-modal-close-button" title="Close"></button>
        <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Load Game</h3>
        <div id="loadOptionsContainer" style="display: flex; flex-direction: row; justify-content: center; gap: 20px;">
            <button id="loadFromAutosaveButton" class="action-button">Load Autosave</button>
            <button id="loadFromFileButton" class="action-button">Load Save File</button>
        </div>
    </div>
</div>

<!-- Hidden file input for loading game saves -->
<input type="file" id="fileLoaderInput" style="display: none;" accept=".fhsave, .json">

<!-- NEW MAP MODAL -->
<div id="newMapModal" class="modal-overlay" style="display: none;">
<div class="modal-content">
<button id="newMapModalCloseButton" class="tutorial-modal-close-button" title="Close"></button>
<h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">New Map</h3>
<div id="newMapOptionsContainer">
<button id="selectMapButton" class="action-button">Select Map</button>
<button id="generateMapFromModalButton" class="action-button">Generate Map</button>
<button id="customMapButton" class="action-button">Custom Map</button>
</div>
</div>
</div>

    <div id="tutorialModalOverlay" style="display: none;"> <!-- Will be controlled by JS -->
        <div id="tutorialModalContent">
            <button id="tutorialCloseButton" class="tutorial-modal-close-button" title="Close Tutorial"></button>
            <h2>FortHex: Guide</h2>
            <p>Welcome to FortHex! This is a turn-based strategy game of wits, warfare, and area control. This guide will teach you everything you need to know to claim victory.</p>

            <div class="tutorial-section">
                <div class="tutorial-section-header">1. How to Play: The Basics <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                    <ul>
                        <li><strong>Selecting &amp; Deselecting:</strong> Click on one of your units to select it. Its stats and available actions will appear in the UI panels. To deselect, click the unit again or any empty space.</li>
                        <li><strong>Movement:</strong> With a unit selected, valid destinations will be highlighted in green. You can either <strong>drag-and-drop</strong> your unit to a highlighted road, or simply <strong>click</strong> on it.</li>
                        <li><strong>Actions:</strong> With a unit selected, click an action button in the right panel (e.g., "Attack," "Fortify"). The game will highlight valid targets. Click a target to confirm. To cancel, click the action button again.</li>
                        <li><strong>Ending Your Turn:</strong> When you have finished all your moves, click the "End Turn" button to pass control to your opponent.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">2. The Objective: How to Win <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                    <p>There are two paths to victory:</p>
                    <ul>
                        <li><strong>Annihilation:</strong> Eliminate all of your opponent's units.</li>
                        <li><strong>Capture the Flag (CTF):</strong> Move one of your units to the enemy's starting base to capture their flag. Successfully bring that unit back to your own starting base to win the game instantly.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">3. The Battlefield: Tiles &amp; Roads <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                    <p>The map is made of hexagonal tiles and the roads connecting them. Your units are positioned on roads.</p>
                    <p><strong>Tiles:</strong> Each tile type affects gameplay.</p>
                    <ul>
                        <li><strong>Plains:</strong> Standard, open ground.</li>
                        <li><strong>Forest:</strong> Provides cover, but slows movement. Blocks Line of Sight.</li>
                        <li><strong>Mountain:</strong> Difficult to cross and blocks Line of Sight.</li>
                        <li><strong>Water:</strong> Impassable.</li>
                    </ul>
                    <p><strong>Roads:</strong> The paths your units travel on. Up to two friendly units can share a road.</p>
                    <ul>
                        <li>Movement costs vary by the terrain on either side of a road (e.g., a road next to a Forest is slower to cross).</li>
                        <li>Moving onto a road next to an enemy-controlled fort costs an extra Movement Point (MP).</li>
                    </ul>
                </div>
            </div>
            
            <div class="tutorial-section">
                <div class="tutorial-section-header">4. Core Mechanic: Fortification <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                    <p>Fortifying is a key strategic action. A unit on a road can move into the center of an adjacent tile to fortify it.</p>
                    <ul>
                        <li><strong>Fortifiable Tiles:</strong> You can only fortify <strong>Plains</strong> and <strong>Forest</strong> tiles.</li>
                        <li><strong>Benefits of Fortification:</strong>
                            <ul>
                                <li><strong>Defense:</strong> Reduces incoming damage. A fortified Pikeman is especially tough.</li>
                                <li><strong>Zone of Control (ZoC):</strong> Automatically damages adjacent enemies, creating a dangerous area for your opponent.</li>
                                <li><strong>Healing &amp; Supply:</strong> A fortified unit can heal 1 HP at the start of your turn. Healing can even grant a temporary 1 HP "shield" above its maximum health.</li>
                            </ul>
                        </li>
                        <li><strong>Unfortify:</strong> A fortified unit can perform an action to move back onto an adjacent road, removing the fortification.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">5. Your Army: The Units <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                    <p>You control four distinct unit types, each with a unique role.</p>
                     <ul>
                        <li><strong>Melee (Symbol: Sword):</strong> A versatile front-line fighter.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 12 | Move: 4 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> The only unit that can build Bridges over Water roads.</li>
                                <li><strong>Weak against:</strong> Horseman | <strong>Strong against:</strong> Archer</li>
                            </ul>
                        </li>
                        <li style="margin-top:10px;"><strong>Archer (Symbol: Arrow):</strong> A ranged unit that attacks from a distance. Must have Line of Sight to its target.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 10 | Move: 3 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> Gains +1 Attack when attacking from a fortified position.</li>
                                <li><strong>Weak against:</strong> Melee | <strong>Strong against:</strong> Pikeman</li>
                            </ul>
                        </li>
                        <li style="margin-top:10px;"><strong>Pikeman (Symbol: Pike):</strong> A defensive powerhouse and anti-cavalry specialist.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 13 | Move: 3 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> Gets a superior defensive bonus when fortified. Its attack can pierce some of an enemy's fortification defense.</li>
                                <li><strong>Weak against:</strong> Archer | <strong>Strong against:</strong> Horseman</li>
                            </ul>
                        </li>
                        <li style="margin-top:10px;"><strong>Horseman (Symbol: Horse Head):</strong> A fast, mobile flanker designed for hit-and-run tactics.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 11 | Move: 5 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> Can use its remaining Movement Points *after* attacking. Cannot fortify.</li>
                                <li><strong>Weak against:</strong> Pikeman | <strong>Strong against:</strong> Melee</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">6. Advanced Combat: Synergies &amp; Counters <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                     <p>Unit interactions are the key to victory.</p>
                    <ul>
                        <li><strong>Advantage/Disadvantage:</strong> Units get an attack bonus against types they are "strong" against, and a penalty against those they are "weak" against.</li>
                        <li><strong>Spear Wall:</strong> An enemy Horseman attacking a unit next to your fortified Pikeman is stopped in its tracks and cannot move away after the attack.</li>
                        <li><strong>Combined Arms:</strong> An attack from a road with both a friendly Melee and Archer on it will ignore the target's fortification bonus.</li>
                        <li><strong>Cavalry Screen:</strong> If an enemy Melee unit attacks your Horseman, a friendly Archer on the same road will automatically retaliate with a half-damage shot.</li>
                        <li><strong>Split Damage:</strong> If an Archer attacks a road where two enemies are present, its damage is split between them.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">7. Strategic Systems: The Long Game <span class="tutorial-arrow"></span></div>
                <div class="tutorial-section-content">
                    <p>Mastering these systems will set you apart from your opponent.</p>
                    <ul>
                        <li><strong>Supply Points:</strong> Each player starts with <strong>10 Supply Points</strong>, a global resource used to maintain supply lines. The cost of a supply line is based on the length and terrain of the path back to your base. If you cannot afford the cost, your unit will fortify but will be "unsupplied" and cannot heal. When a supplied unit is destroyed or unfortifies, its supply cost is refunded.</li>
                        <li><strong>Supply Lines &amp; Healing:</strong> For a fortified unit to heal, it must be "in supply." This requires both a valid supply line path AND enough Supply Points to maintain it. An enemy unit standing on any road in that chain will also break the supply line and prevent healing.</li>
                        <li><strong>Capture the Flag &amp; Supply Raids:</strong> Stealing the enemy flag is a devastating move. When you are carrying their flag, <strong>all of their units, no matter where they are, lose their supply lines and cannot heal.</strong> They must destroy your flag carrier to restore their healing capabilities.</li>
                        <li><strong>Reinforcements (Respawn System):</strong> Destroyed units aren't gone forever. They enter a respawn queue. After 10 turns, you can deploy a new unit at your base. This is limited by a maximum army size (4 units) and a cap on each unit type (2 of each).</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- RESPAWN CHOICE MODAL -->
    <div id="respawnModalOverlay" class="modal-overlay">
        <div id="respawnModalContent" class="modal-content">
            <h3>A Unit Has Fallen!</h3>
            <p>Choose a reinforcement to deploy at your base.</p>
            <div id="respawnChoices">
                <button id="respawnMelee" class="respawn-button" data-unit-type="MELEE" title="Melee"></button>
                <button id="respawnArcher" class="respawn-button" data-unit-type="ARCHER" title="Archer"></button>
                <button id="respawnPikeman" class="respawn-button" data-unit-type="PIKEMAN" title="Pikeman"></button>
                <button id="respawnHorseman" class="respawn-button" data-unit-type="HORSEMAN" title="Horseman"></button>
            </div>
        </div>
    </div>


    <script>
        // --- Game Configuration & Constants ---
        const BUILD_VERSION = "indev B28//3";
        const HEX_SIZE = 70; 
        const CANVAS_WIDTH_NORMAL = (2 * 3 + 1.5) * (HEX_SIZE * Math.sqrt(3));
        const CANVAS_HEIGHT_NORMAL = (2 * 3 + 1) * (HEX_SIZE * 2 * 0.75) + HEX_SIZE;

        // Gameplay Constants
        const RESPAWN_TURN_TIMER = 10;
        const MAX_BASE_CAMP_TURNS = 7;
        const MAX_UNITS_PER_PLAYER = 4;
        const UNIT_CAPS = {
            Melee: 2,
            Archer: 2,
            Pikeman: 2,
            Horseman: 2,
        };
        const FORTIFICATION_DAMAGE = 1; 
        const BRIDGE_MAX_HP = 5;        
        const PROJECTILE_SPEED_PIXELS_PER_MS = 0.8;
        const UNIT_ON_EDGE_OFFSET = HEX_SIZE * 0.3; 
        const ATTACK_COST = 1;          
        const FORTIFY_UNFORTIFY_COST = 1; 
        const BUILD_BRIDGE_COST = 1;    
        const MAX_MOVEMENT_COST = 3;    
        const SHIELD_COLOR = '#30C4C4'; 

        // Visual/Interaction Constants
        const UNIT_DRAW_SIZE_ON_EDGE = HEX_SIZE * 0.25; 
        const FORTIFIED_UNIT_DRAW_SIZE = UNIT_DRAW_SIZE_ON_EDGE * 1.2; 
        const HIGHLIGHT_CLICK_RADIUS = HEX_SIZE * 0.35; 
        const UNIT_CLICK_RADIUS = HEX_SIZE * 0.3;       
        const BRIDGE_CLICK_TOLERANCE = HEX_SIZE * 0.15; 
        const DRAG_SCALE_FACTOR = 1.2;  
        const DRAGGED_DISTANCE_THRESHOLD = 5; 
        const PULSE_DURATION_MS = 2000; 
        const DOUBLE_TAP_THRESHOLD_MS = 200; // Time in ms for a double tap
        const DOUBLE_TAP_MAX_DISTANCE = 30;  // Max distance in pixels between taps
        const COLOR_TRANSITION_DURATION_MS = 400;
        const PATH_DRAW_ANIMATION_DURATION_MS = 750; 
        const PATH_DRAW_PAUSE_DURATION_MS = 500; 
        const PATH_DRAW_HOVER_DELAY_MS = 1000; 

        // Arcade Mode Constants
        const ARCADE_TURN_TIME_SEC = 30;
        const ARCADE_MAX_TURNS = 10;
        const ARCADE_UNIT_CAP = 2;

        // Map Generation Constants (Updated for Radius 3)
        const MAX_MOUNTAIN_TILES_TOTAL = 8;
        const MAX_WATER_TILES_TOTAL = 12;
        const MAX_FOREST_TILES_TOTAL = 12;
        const MAX_PLAINS_TILES_TOTAL = 18;

        const MAX_MOUNTAIN_TILES_PER_CLUSTER = 3; // Kept the same for cluster density

        const MOUNTAIN_SPAWN_CHANCE = 0.35;
        const WATER_SPAWN_CHANCE = 0.25;
        const FOREST_SPAWN_CHANCE = 0.5;

        const MIN_WATER_TILES_SOFT = 4;
        const MIN_FOREST_TILES_SOFT = 6;
        const MIN_PLAINS_TILES_SOFT = 12;
        const MIN_CENTRAL_PLAINS_SOFT = 3;

        // Action State Constants
        const ACTION_STATES = {
            IDLE: 'idle',
            UNIT_SELECTED: 'unit_selected',
            SELECTING_FORTIFY_TILE: 'selecting_fortify_tile',
            SELECTING_UNFORTIFY_EDGE: 'selecting_unfortify_edge',
            SELECTING_BRIDGE_EDGE: 'selecting_bridge_edge',
            SELECTING_ATTACK_TARGET: 'selecting_attack_target',
        };

        // All available color themes
        const COLOR_THEMES = [
            { // Theme 1
                player1: { primary: '#4060E0', secondary: '#60D0F0', accent: '#40B0FF' },
                player2: { primary: '#E06040', secondary: '#FF7040', accent: '#FF8060' }
            },
            { // Theme 2
                player1: { primary: '#4050D0', secondary: '#60C0E8', accent: '#50A0FF' },
                player2: { primary: '#D05040', secondary: '#F86040', accent: '#FF7070' }
            },
            { // Theme 3 (Default)
                player1: { primary: '#4040C0', secondary: '#60B0E0', accent: '#6090FF' },
                player2: { primary: '#C04040', secondary: '#F05040', accent: '#FF6080' }
            },
            { // Theme 4
                player1: { primary: '#4030B0', secondary: '#60A0D8', accent: '#7080FF' },
                player2: { primary: '#B03040', secondary: '#E84040', accent: '#FF5090' }
            },
            { // Theme 5
                player1: { primary: '#4020A0', secondary: '#6090D0', accent: '#8070FF' },
                player2: { primary: '#A02040', secondary: '#E03040', accent: '#E03040' }
            }
        ];

        //Team Color Definitions
        const TEAM_COLORS = {
            player1: { ...COLOR_THEMES[2].player1 },
            player2: { ...COLOR_THEMES[2].player2 }
        };

        // Tile Definitions
        const TILE_TYPES = {
            PLAINS:   { name: 'Plains',   color: '#90EE90', baseMoveCost: 1, canFortify: true },
            FOREST:   { name: 'Forest',   color: '#228B22', baseMoveCost: 2, canFortify: true },
            WATER:    { name: 'Water',    color: '#87CEEB', baseMoveCost: Infinity, crossable: false, canFortify: false },
            MOUNTAIN: { name: 'Mountain', color: '#808080', baseMoveCost: 3, canFortify: false, blocksLOS: true } 
        };

        // Unit Definitions
        const UNIT_TYPES = {
            MELEE:    { name: 'Melee',    hp: 12, baseMove: 4, attack: 3, symbol: 'M', canBuildBridge: true,  canFortify: true,  fortificationBonus: 1, attackType: 'melee', defenseNegation: 0, canMoveAfterAttack: false, strengths: ['Archer'],   weaknesses: ['Horseman'] },
            ARCHER:   { name: 'Archer',   hp: 10, baseMove: 3, attack: 3, symbol: 'A', canBuildBridge: false, canFortify: true,  fortificationBonus: 1, attackType: 'ranged', defenseNegation: 0, canMoveAfterAttack: false, strengths: ['Pikeman'],  weaknesses: ['Melee'] },
            PIKEMAN:  { name: 'Pikeman',  hp: 13, baseMove: 3, attack: 3, symbol: 'P', canBuildBridge: false, canFortify: true,  fortificationBonus: 2, attackType: 'melee', defenseNegation: 1, canMoveAfterAttack: false, strengths: ['Horseman'], weaknesses: ['Archer'] },
            HORSEMAN: { name: 'Horseman', hp: 11, baseMove: 5, attack: 3, symbol: 'H', canBuildBridge: false, canFortify: false, fortificationBonus: 0, attackType: 'melee', defenseNegation: 0, canMoveAfterAttack: true,  strengths: ['Melee'],    weaknesses: ['Pikeman'] }
        };

        const UNIT_SVGS = {
            MELEE: `<svg viewBox="170 60 110 280" fill="white">
                        <path d="M 224.613 61.934 L 243.516 108 L 208.709 108.172 L 224.613 61.934 Z"></path>
                        <rect x="210.709" y="108.172" width="31.807" height="192.313"></rect>
                        <rect x="172.161" y="233.27" width="103.853" height="22.254"></rect>
                        <ellipse cx="224.526" cy="312.975" rx="20.582" ry="20.615"></ellipse>
                    </svg>`,
            ARCHER: `<svg viewBox="-10 -18 20 36" fill="white">
                        <path d="M 0 -17.5 L -5 -10 L -1.875 -8.75 L -1.875 5 L -6.25 17.5 L 0 13.75 L 6.25 17.5 L 1.875 5 L 1.875 -8.75 L 5 -10 Z" />
                    </svg>`,
            PIKEMAN: `<svg viewBox="-14 -20 28 40" fill="white">
                        <path d="M -1.35 16.875 L -1.35 1.125 Q -13.5 -3.375 -1.35 -11.25 L 0 -18 L 1.35 -11.25 L 1.35 -7.5 L 8.75 -4.5 L 1.35 -2.25 L 1.35 16.875 Z" />
                    </svg>`,
            HORSEMAN: `<svg viewBox="-12 -16 24 32" fill="white">
                        <path d="M-6 10 L 6 10 L 6 3 L 3 -1 L 9 -3 L 9 -7 L 2 -7 L -2 -12 L -4 -8 L -6 2 Z" />
                    </svg>`
        };

        // Hex Grid Directions (Axial Coordinates)
        const AXIAL_DIRECTIONS = [ { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 }, { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 } ];
        const MAP_DIRECTION_TO_EDGE_INDEX = [0, 5, 4, 3, 2, 1];



        const PRESET_MAP_1 = {
            name: "River Fork",
            radius: 3,
            tiles: new Map([
                ['-3,0', TILE_TYPES.FOREST], ['-3,1', TILE_TYPES.FOREST], ['-3,2', TILE_TYPES.MOUNTAIN], ['-3,3', TILE_TYPES.WATER],
                ['-2,-1', TILE_TYPES.PLAINS], ['-2,0', TILE_TYPES.PLAINS], ['-2,1', TILE_TYPES.FOREST], ['-2,2', TILE_TYPES.WATER], ['-2,3', TILE_TYPES.MOUNTAIN],
                ['-1,-2', TILE_TYPES.PLAINS], ['-1,-1', TILE_TYPES.PLAINS], ['-1,0', TILE_TYPES.FOREST], ['-1,1', TILE_TYPES.PLAINS], ['-1,2', TILE_TYPES.WATER], ['-1,3', TILE_TYPES.FOREST],
                ['0,-3', TILE_TYPES.FOREST], ['0,-2', TILE_TYPES.PLAINS], ['0,-1', TILE_TYPES.WATER], ['0,0', TILE_TYPES.WATER], ['0,1', TILE_TYPES.WATER], ['0,2', TILE_TYPES.PLAINS], ['0,3', TILE_TYPES.FOREST],
                ['1,-3', TILE_TYPES.FOREST], ['1,-2', TILE_TYPES.WATER], ['1,-1', TILE_TYPES.PLAINS], ['1,0', TILE_TYPES.FOREST], ['1,1', TILE_TYPES.PLAINS], ['1,2', TILE_TYPES.PLAINS],
                ['2,-3', TILE_TYPES.MOUNTAIN], ['2,-2', TILE_TYPES.WATER], ['2,-1', TILE_TYPES.FOREST], ['2,0', TILE_TYPES.PLAINS], ['2,1', TILE_TYPES.PLAINS],
                ['3,-3', TILE_TYPES.WATER], ['3,-2', TILE_TYPES.MOUNTAIN], ['3,-1', TILE_TYPES.FOREST], ['3,0', TILE_TYPES.FOREST]
            ]),
            units: [
                { player: 1, typeName: 'MELEE', position: '1,1_2,0' }, { player: 1, typeName: 'ARCHER', position: '0,2_1,1' },
                { player: 1, typeName: 'HORSEMAN', position: '0,2_0,3' }, { player: 1, typeName: 'PIKEMAN', position: '2,0_3,0' },
                { player: 2, typeName: 'ARCHER', position: '-1,-1_0,-2' }, { player: 2, typeName: 'MELEE', position: '-2,0_-1,-1' },
                { player: 2, typeName: 'HORSEMAN', position: '0,-3_0,-2' }, { player: 2, typeName: 'PIKEMAN', position: '-3,0_-2,0' }
            ],
            baseCampPositions: { player1: '1,2_2,1', player2: '-2,-1_-1,-2' }
        };

        const PRESET_MAP_2 = {
            name: "Alpha Grounds",
            radius: 2,
            tiles: new Map([
                ['-2,0', TILE_TYPES.WATER], ['-2,1', TILE_TYPES.FOREST], ['-2,2', TILE_TYPES.MOUNTAIN],
                ['-1,-1', TILE_TYPES.WATER], ['-1,0', TILE_TYPES.PLAINS], ['-1,1', TILE_TYPES.FOREST], ['-1,2', TILE_TYPES.WATER],
                ['0,-2', TILE_TYPES.WATER], ['0,-1', TILE_TYPES.PLAINS], ['0,0', TILE_TYPES.PLAINS], ['0,1', TILE_TYPES.PLAINS], ['0,2', TILE_TYPES.FOREST],
                ['1,-2', TILE_TYPES.FOREST], ['1,-1', TILE_TYPES.FOREST], ['1,0', TILE_TYPES.PLAINS], ['1,1', TILE_TYPES.FOREST],
                ['2,-2', TILE_TYPES.MOUNTAIN], ['2,-1', TILE_TYPES.WATER], ['2,0', TILE_TYPES.FOREST]
            ]),
            units: [
                { player: 1, typeName: 'MELEE', position: '0,-1_1,-1' }, { player: 1, typeName: 'ARCHER', position: '-1,0_0,-1' },
                { player: 2, typeName: 'MELEE', position: '-1,1_0,1' }, { player: 2, typeName: 'ARCHER', position: '0,1_1,0' }
            ],
            baseCampPositions: { player1: null, player2: null }
        };

        const DEFAULT_MAP_LAYOUT_RADIUS_3 = new Map([
            // q=-3
            ['-3,0', TILE_TYPES.WATER], ['-3,1', TILE_TYPES.WATER], ['-3,2', TILE_TYPES.MOUNTAIN], ['-3,3', TILE_TYPES.MOUNTAIN],
            // q=-2
            ['-2,-1', TILE_TYPES.PLAINS], ['-2,0', TILE_TYPES.PLAINS], ['-2,1', TILE_TYPES.FOREST], ['-2,2', TILE_TYPES.FOREST], ['-2,3', TILE_TYPES.MOUNTAIN],
            // q=-1
            ['-1,-2', TILE_TYPES.PLAINS], ['-1,-1', TILE_TYPES.PLAINS], ['-1,0', TILE_TYPES.PLAINS], ['-1,1', TILE_TYPES.PLAINS], ['-1,2', TILE_TYPES.FOREST], ['-1,3', TILE_TYPES.WATER],
            // q=0
            ['0,-3', TILE_TYPES.WATER], ['0,-2', TILE_TYPES.PLAINS], ['0,-1', TILE_TYPES.PLAINS], ['0,0', TILE_TYPES.FOREST], ['0,1', TILE_TYPES.PLAINS], ['0,2', TILE_TYPES.PLAINS], ['0,3', TILE_TYPES.WATER],
            // q=1
            ['1,-3', TILE_TYPES.WATER], ['1,-2', TILE_TYPES.FOREST], ['1,-1', TILE_TYPES.PLAINS], ['1,0', TILE_TYPES.PLAINS], ['1,1', TILE_TYPES.PLAINS], ['1,2', TILE_TYPES.PLAINS],
            // q=2
            ['2,-3', TILE_TYPES.MOUNTAIN], ['2,-2', TILE_TYPES.FOREST], ['2,-1', TILE_TYPES.FOREST], ['2,0', TILE_TYPES.PLAINS], ['2,1', TILE_TYPES.PLAINS],
            // q=3
            ['3,-3', TILE_TYPES.MOUNTAIN], ['3,-2', TILE_TYPES.MOUNTAIN], ['3,-1', TILE_TYPES.WATER], ['3,0', TILE_TYPES.WATER]
        ]);
        
        const BASE_CAMP_DEFAULTS = {
            2: { // Compact
                player1: { tiles: ['2,0'], edge: null }, // No flag edge for now
                player2: { tiles: ['-2,0'], edge: null }
            },
            3: { // Normal (Current)
                player1: { tiles: ['-2,-1', '-1,-2'], edge: '-2,-1_-1,-2' },
                player2: { tiles: ['1,2', '2,1'], edge: '1,2_2,1' }
            },
            4: { // Expansive
                player1: { tiles: ['-3,-1', '-2,-2', '-1,-3'], edge: null }, // No flag edge for now
                player2: { tiles: ['1,3', '2,2', '3,1'], edge: null }
            }
        };

        const DEFAULT_FLAG_HOME_POSITIONS = {
            player1: getEdgeKey(-2, -1, -1, -2), // Edge between P1's base tiles
            player2: getEdgeKey(1, 2, 2, 1)      // Edge between P2's base tiles
        };

        // --- Canvas & UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const ui = {
            turnDisplay: document.getElementById('turnDisplay'),
            globalTurnCounterDisplay: document.getElementById('globalTurnCounterDisplay'),
            selectedUnitInfoContainer: document.getElementById('selectedUnitInfoContainer'),
            unitName: document.getElementById('unitName'),
            unitHP: document.getElementById('unitHP'),
            unitMaxHP: document.getElementById('unitMaxHP'),
            unitMovement: document.getElementById('unitMovement'),
            unitPosition: document.getElementById('unitPosition'),
            unitStatus: document.getElementById('unitStatus'),
            actionsPanel: document.getElementById('actionsPanel'),
            fortifyUnfortifyButton: document.getElementById('fortifyUnfortifyButton'),
            buildBridgeButton: document.getElementById('buildBridgeButton'),
            attackButton: document.getElementById('attackButton'),
            endTurnButton: document.getElementById('endTurnButton'),
            downloadButton: document.getElementById('downloadButton'),
            tutorialButton: document.getElementById('tutorialButton'), 
            messageBox: document.getElementById('messageBox'),
            victoryMessage: document.getElementById('victoryMessage'),
            customConfirmModal: document.getElementById('customConfirmModal'),
            customConfirmOkButton: document.getElementById('customConfirmOkButton'),
            customConfirmCancelButton: document.getElementById('customConfirmCancelButton'),
            tutorialModalOverlay: document.getElementById('tutorialModalOverlay'), 
            tutorialCloseButton: document.getElementById('tutorialCloseButton'), 
            tutorialSectionHeaders: document.querySelectorAll('.tutorial-section-header'), 
            actionInfoContainer: document.getElementById('actionInfoContainer'),
            actionLogContent: document.getElementById('actionLogContent'),
        };

        let dragOperationJustConcluded = false;
        let lastTap = 0;
        let lastTapPosition = { x: 0, y: 0 };
        let fileLoadContext = 'game_save'; // 'game_save', 'edit_map', or 'play_map'

// --- Game State ---
let gameState = {
    gameMode: 'local', // 'local' or 'singleplayer'
    playerSide: null, // 1 or 2, for singleplayer mode
    gridRadius: 3,
    renderScale: 1.0,
    renderOffset: { x: 0, y: 0 },
    playerColorSelections: { player1: 2, player2: 2 },
    colorTransition: { active: false, startTime: 0, from: {}, to: {} },
    tiles: new Map(),
    edges: new Map(),
    units: [],
    currentPlayer: 1,
    globalTurnNumber: 1,
    selectedUnit: null,
    hoveredUnitId: null,
    currentReachableMoves: new Map(),
    gameOver: false,
    actionLog: [], 
    flags: null,
    respawnQueue: { player1: [], player2: [] },
    unitCounts: null,
    supplyPoints: { player1: 10, player2: 10 },
    activeAnimations: [],

    // Physical UI states
    isDragging: false,
    draggingUnit: null,
    dragStartX: 0, dragStartY: 0,
    dragUnitRenderX: 0, dragUnitRenderY: 0,
    dragUnitOriginalPosition: null, dragUnitOriginalType: null,
    draggedDistance: 0,
    dragStartTime: null,
    
    // Logical Game State
    currentActionState: ACTION_STATES.IDLE,
    mapMakerMode: false,
    mapMakerBrush: { type: 'tile', value: TILE_TYPES.PLAINS, player: null },
    mapMakerLastPaintedHexKey: null,
    baseCampPositions: JSON.parse(JSON.stringify(DEFAULT_FLAG_HOME_POSITIONS)),

    // Data for actions
    validFortifyTargetTileKeys: [],
    validUnfortifyTargetEdgeKeys: [],
    validBridgeTargetEdgeKeys: [],
    validMeleeAttackTargets: [],
    validArcherAttackTargets: [],
    
    // Debug / Animation data
    potentialDebugPathToDraw: null, 
    debugPathHoverStartTime: null,  
    debugPathToDraw: null,          
    debugPathAnimationStartTime: null,
    debugPathPauseStartTime: null, 
    lastDebugPathKey: null, 
    debugAttackRangeHighlights: [],
    visualEffects: [],
    playerActionTaken: { player1: false, player2: false },
    isTestingMap: false,
    fillToolActive: false,
};

let currentDrawingColors = JSON.parse(JSON.stringify(TEAM_COLORS));

let gameSettings = {
    animationsEnabled: true, //Enable/Disable All Animations
    fancyVisualsEnabled: true, //Enable/Disable New Tile Textures
    passTurnConfirmationEnabled: true, //Enable/Disable the Skip Turn Confirmation Modal
    tooltipsEnabled: true, //Enable/Disable Tooltips
    //uiScale: 1.0
};

const SETTINGS_STORAGE_KEY = 'forthex_user_settings';
const COLOR_PREF_STORAGE_KEY = 'forthex_color_preferences';
const MAP_MAKER_AUTOSAVE_KEY = 'forthex_map_maker_autosave';

function saveSettings() {
    try {
        const settingsString = JSON.stringify(gameSettings);
        localStorage.setItem(SETTINGS_STORAGE_KEY, settingsString);
    } catch (error) {
        console.error("Could not save settings:", error);
    }
}

function loadSettings() {
    try {
        const savedSettingsString = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (savedSettingsString) {
            const loadedSettings = JSON.parse(savedSettingsString);
            // Merge loaded settings with defaults to handle new settings in future updates
            gameSettings = Object.assign({}, gameSettings, loadedSettings);
        }
        // If no saved settings, the default gameSettings object is used.
    } catch (error) {
        console.error("Could not load settings:", error);
    }
}

function saveColorPreferences() {
    try {
        const prefsString = JSON.stringify(gameState.playerColorSelections);
        localStorage.setItem(COLOR_PREF_STORAGE_KEY, prefsString);
    } catch (error) {
        console.error("Could not save color preferences:", error);
    }
}

function loadColorPreferences() {
    try {
        const savedPrefsString = localStorage.getItem(COLOR_PREF_STORAGE_KEY);
        if (savedPrefsString) {
            const loadedPrefs = JSON.parse(savedPrefsString);
            // Update the game state with the loaded selections
            gameState.playerColorSelections = Object.assign({}, gameState.playerColorSelections, loadedPrefs);

            // CRITICAL: Update the main TEAM_COLORS object to reflect the loaded preferences
            // This ensures the game starts with the correct colors.
            TEAM_COLORS.player1 = { ...COLOR_THEMES[gameState.playerColorSelections.player1].player1 };
            TEAM_COLORS.player2 = { ...COLOR_THEMES[gameState.playerColorSelections.player2].player2 };
        }
    } catch (error) {
        console.error("Could not load color preferences:", error);
    }
}

        let currentConfirmAction = null;
        let mapMakerStateBackup = null;
        let currentCancelAction = null; // NEW: Stores logic to run if a modal is cancelled

        // --- Utility Functions ---

        // Hex Color to RGBA
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Helper to darken/lighten hex color for shadows
        function adjustBrightness(hex, percent) {
            const num = parseInt(hex.replace('#', ''), 16);
            const amt = Math.round(2.55 * percent);
            const R = (num >> 16) + amt;
            const G = (num >> 8 & 0x00FF) + amt;
            const B = (num & 0x0000FF) + amt;
            return '#' + (
                0x1000000 +
                (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
                (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
                (B < 255 ? (B < 1 ? 0 : B) : 255)
            ).toString(16).slice(1);
        }

        // Linearly interpolates between two hex colors
        function lerpColor(colorA, colorB, amount) {
            const ah = parseInt(colorA.replace(/#/g, ''), 16);
            const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
            const bh = parseInt(colorB.replace(/#/g, ''), 16);
            const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
            const rr = ar + amount * (br - ar);
            const rg = ag + amount * (bg - ag);
            const rb = ab + amount * (bb - ab);
            const newHex = ((1 << 24) + (Math.round(rr) << 16) + (Math.round(rg) << 8) + Math.round(rb)).toString(16).slice(1);
            return `#${newHex}`;
        }

        function axialToPixel(q, r) {
            const rawX = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r);
            const rawY = HEX_SIZE * (3 / 2 * r);
            const x = (rawX * gameState.renderScale) + gameState.renderOffset.x + canvas.width / 2;
            const y = (rawY * gameState.renderScale) + gameState.renderOffset.y + canvas.height / 2;
            return { x, y };
        }

        function pixelToAxial(x, y) {
            const adjX = (x - canvas.width / 2 - gameState.renderOffset.x) / gameState.renderScale;
            const adjY = (y - canvas.height / 2 - gameState.renderOffset.y) / gameState.renderScale;
            const q_calc = (Math.sqrt(3) / 3 * adjX - 1 / 3 * adjY) / HEX_SIZE;
            const r_calc = (2 / 3 * adjY) / HEX_SIZE;
            return roundAxial({ q: q_calc, r: r_calc });
        }

        function roundAxial({ q, r }) {
            const s = -q - r;
            let rq = Math.round(q); let rr = Math.round(r); let rs = Math.round(s);
            const q_diff = Math.abs(rq - q); const r_diff = Math.abs(rr - r); const s_diff = Math.abs(rs - s);
            if (q_diff > r_diff && q_diff > s_diff) rq = -rr - rs;
            else if (r_diff > s_diff) rr = -rq - rs;
            return { q: rq, r: rr };
        }

        function getTileKey(q, r) { return `${q},${r}`; }

        function getEdgeKey(q1, r1, q2, r2) {
            if (q1 > q2 || (q1 === q2 && r1 > r2)) {
                [q1, q2] = [q2, q1]; [r1, r2] = [r2, r1];
            }
            return `${q1},${r1}_${q2},${r2}`;
        }

        function getEdgeMidpoint(q1, r1, q2, r2) {
            const p1 = axialToPixel(q1, r1); const p2 = axialToPixel(q2, r2);
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function getNeighbors(q, r) { return AXIAL_DIRECTIONS.map(dir => ({ q: q + dir.q, r: r + dir.r })); }

        function axialDistance(q1, r1, q2, r2) {
            const dq = q1 - q2; const dr = r1 - r2; const ds = (-q1 - r1) - (-q2 - r2);
            return (Math.abs(dq) + Math.abs(dr) + Math.abs(ds)) / 2;
        }

        function calculateBaseCentroid(baseTileKeys) {
            if (!Array.isArray(baseTileKeys) || baseTileKeys.length !== 3) return null;

            let sumX = 0, sumY = 0;
            const tiles = baseTileKeys.map(k => {
                const [q, r] = k.split(',').map(Number);
                const pos = axialToPixel(q, r);
                sumX += pos.x;
                sumY += pos.y;
                return { q, r };
            });

            // Check topology: Do they form a tight triangle?
            // A touches B, B touches C, C touches A
            const [t1, t2, t3] = tiles;
            const d12 = axialDistance(t1.q, t1.r, t2.q, t2.r);
            const d23 = axialDistance(t2.q, t2.r, t3.q, t3.r);
            const d31 = axialDistance(t3.q, t3.r, t1.q, t1.r);

            if (d12 === 1 && d23 === 1 && d31 === 1) {
                // Triangle: Use true geometric centroid
                return { x: sumX / 3, y: sumY / 3 };
            } else {
                // Line or 'L': Find the center tile (the one connected to the other two)
                let centerTileIndex = 0;
                if (d12 === 1 && d31 === 1) centerTileIndex = 0;      // 1 connects to 2 and 3
                else if (d12 === 1 && d23 === 1) centerTileIndex = 1; // 2 connects to 1 and 3
                else centerTileIndex = 2;                             // 3 connects to 1 and 2
        
                const [q, r] = baseTileKeys[centerTileIndex].split(',').map(Number);
                return axialToPixel(q, r);
            }
        }

        function isSetContiguous(tileKeyArray) {
            if (tileKeyArray.length <= 1) return true;
    
            // Convert strings "q,r" to objects {q, r, key}
            const tiles = tileKeyArray.map(k => {
                const [q, r] = k.split(',').map(Number);
                return { q, r, key: k };
            });

            // Perform a simple BFS/flood fill to count connected tiles
            const visited = new Set();
            const queue = [tiles[0]]; // Start from the first tile
            visited.add(tiles[0].key);
            let count = 0;

            while (queue.length > 0) {
                const current = queue.shift();
                count++;

                // Check against all other tiles in the set
                for (const other of tiles) {
                    if (!visited.has(other.key)) {
                        if (axialDistance(current.q, current.r, other.q, other.r) === 1) {
                            visited.add(other.key);
                            queue.push(other);
                        }
                    }
                }
            }

            // If the number of visited tiles equals the total set size, it's contiguous
            return count === tileKeyArray.length;
        }

        function findDirectionIndex(dir) {
            for (let i = 0; i < AXIAL_DIRECTIONS.length; i++) {
                if (AXIAL_DIRECTIONS[i].q === dir.q && AXIAL_DIRECTIONS[i].r === dir.r) return i;
            }
            return -1;
        }

        function parseEdgeKey(edgeKey) {
            if (!edgeKey || typeof edgeKey !== 'string' || !edgeKey.includes('_')) {
                return [{q:NaN, r:NaN}, {q:NaN, r:NaN}];
            }
            const parts = edgeKey.split('_');
            const [q1, r1] = parts[0].split(',').map(Number);
            const [q2, r2] = parts[1].split(',').map(Number);
            return [{q: q1, r: r1}, {q: q2, r: r2}];
        }

        function clearDebugPath() { 
            gameState.potentialDebugPathToDraw = null;
            gameState.debugPathHoverStartTime = null;
            gameState.debugPathToDraw = null; 
            gameState.debugPathAnimationStartTime = null;
            gameState.debugPathPauseStartTime = null; 
            gameState.lastDebugPathKey = null;
        }

        function resetActionSelectionStates() {
            gameState.currentActionState = gameState.selectedUnit ? ACTION_STATES.UNIT_SELECTED : ACTION_STATES.IDLE;
            
            gameState.validFortifyTargetTileKeys = [];
            gameState.validUnfortifyTargetEdgeKeys = [];
            gameState.validBridgeTargetEdgeKeys = [];
            gameState.validMeleeAttackTargets = [];
            gameState.validArcherAttackTargets = [];
            gameState.debugAttackRangeHighlights = [];
            
            clearDebugPath();
        }

        function distSq(p1, p2) { return (p1.x - p2.x)**2 + (p1.y - p2.y)**2; }

        function pointDistance(p1, p2) { return Math.sqrt(distSq(p1,p2)); }

function isInternalBaseEdge(edgeKey) {
    // Checks if an edge is between two tiles of the SAME base camp
    const [h1, h2] = parseEdgeKey(edgeKey);
    const t1 = getTileKey(h1.q, h1.r);
    const t2 = getTileKey(h2.q, h2.r);

    for (let i = 1; i <= 2; i++) {
        const base = gameState.baseCampPositions[`player${i}`];
        if (Array.isArray(base)) {
            if (base.includes(t1) && base.includes(t2)) return true;
        }
    }
    return false;
}

function getMapMakerBaseCampTileKeys() {
    const baseCampTileKeys = new Set();
    
    // Debug: See what the raw state looks like
    // console.log("[DEBUG-KEYS] Raw Base Camp Positions:", JSON.stringify(gameState.baseCampPositions));

    // Helper to process a player's data safely
    const processPlayerData = (data) => {
        if (!data) return; // Skip null/undefined

        if (Array.isArray(data)) {
            // Expansive Mode: Array of Tile Keys
            data.forEach(k => baseCampTileKeys.add(k));
        } else if (typeof data === 'string') {
            // Standard Mode: Edge Key String
            const [h1, h2] = parseEdgeKey(data);
            if (!isNaN(h1.q)) baseCampTileKeys.add(getTileKey(h1.q, h1.r));
            if (!isNaN(h2.q)) baseCampTileKeys.add(getTileKey(h2.q, h2.r));
        }
    };

    processPlayerData(gameState.baseCampPositions.player1);
    processPlayerData(gameState.baseCampPositions.player2);
    
    // console.log("[DEBUG-KEYS] Final Protected Set:", Array.from(baseCampTileKeys));
    return baseCampTileKeys;
}

        function distToSegmentSquared(p, v, w) {
            const l2 = distSq(v, w); if (l2 === 0) return distSq(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return distSq(p, projection);
        }

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function lerp(start, end, amount) {
    return start + (end - start) * amount;
}

function getUnitScreenPosition(unit) {
    if (!unit) return null;
    let unitX, unitY;

    if (unit.isFortified) {
        const tile = gameState.tiles.get(unit.position);
        if (tile) {
            const center = axialToPixel(tile.q, tile.r);
            unitX = center.x;
            unitY = center.y;
        }
    } else {
        const edge = gameState.edges.get(unit.position);
        if (edge) {
            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            unitX = mid.x;
            unitY = mid.y;
            const unitsOnEdge = edge.units.filter(u => u.positionType === 'edge');
            const unitIndex = unitsOnEdge.findIndex(u => u.id === unit.id);
            if (unitsOnEdge.length > 1 && unitIndex !== -1) {
                const offsetSign = (unitIndex % 2 === 0) ? -1 : 1;
                const p1 = axialToPixel(edge.q1, edge.r1);
                const p2 = axialToPixel(edge.q2, edge.r2);
                let dx = p2.x - p1.x, dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                let perpX = -dy / len, perpY = dx / len;
                unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
                unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
            }
        }
    }
    if (unitX !== undefined) {
        return { x: unitX, y: unitY };
    }
    return null;
}

        function padZero(num) {
            return String(num).padStart(2, '0');
        }

        function isLand(tileType) {
            return tileType === TILE_TYPES.PLAINS || tileType === TILE_TYPES.FOREST || tileType === TILE_TYPES.MOUNTAIN;
        }

function isEdgeAdjacentToSpearWall(unit, edgeKey) {
    if (!unit || !edgeKey) return false;

    const enemyPlayer = unit.player === 1 ? 2 : 1;
    const [h1, h2] = parseEdgeKey(edgeKey);
    if (isNaN(h1.q) || isNaN(h2.q)) return false;

    // This set now ONLY contains the two tiles that form the edge.
    const tilesThatFormTheEdge = new Set();
    tilesThatFormTheEdge.add(getTileKey(h1.q, h1.r));
    tilesThatFormTheEdge.add(getTileKey(h2.q, h2.r));

    for (const tileKey of tilesThatFormTheEdge) {
        const tile = gameState.tiles.get(tileKey);
        if (tile && tile.fortifiedByPlayer === enemyPlayer) {
            const fortifiedUnit = gameState.units.find(u => u.position === tileKey && u.isFortified);
            if (fortifiedUnit && fortifiedUnit.type.name === 'Pikeman') {
                return true; 
            }
        }
    }
    return false;
}

        function isRoad(edgeKey) {
            const edge = gameState.edges.get(edgeKey);
            if (!edge) return false;

            if (edge.bridge) {
                return true;
            }

            const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
            const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));

            if (!tile1 || !tile2) return false;

            return !(tile1.type === TILE_TYPES.WATER && tile2.type === TILE_TYPES.WATER);
        }

        function isEdgePlaceable(edgeKey) {
            const edge = gameState.edges.get(edgeKey);
            if (!edge) return false;

            // Cannot place on a player's home base/flag edge
            if (edgeKey === gameState.baseCampPositions.player1 || edgeKey === gameState.baseCampPositions.player2) {
                return false;
            }

            // cannot place on a water-water edge 
            const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
            const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
            if (!tile1 || !tile2) return false; // Should not happen on a valid map

            if (tile1.type === TILE_TYPES.WATER && tile2.type === TILE_TYPES.WATER) {
                return false;
            }

            // If no rules failed, the edge is placeable.
            return true;
        }

        // --- LOS Helper Functions ---
        function getEdgesOfTile(q, r) {
            const edges = new Set(); 
            getNeighbors(q, r).forEach(neighborCoords => {
                if (gameState.tiles.has(getTileKey(neighborCoords.q, neighborCoords.r))) {
                    edges.add(getEdgeKey(q, r, neighborCoords.q, neighborCoords.r));
                }
            });
            return Array.from(edges);
        }

        function isEdgePartOfTile(tileQ, tileR, edgeKey) {
            if (!edgeKey) return false;
            const [h1, h2] = parseEdgeKey(edgeKey);
            return (h1.q === tileQ && h1.r === tileR) || (h2.q === tileQ && h2.r === tileR);
        }

        function isEdgeRotationallyAdjacentToEdgeOnTile(centerTileQ, centerTileR, referenceEdgeKey, targetEdgeKey) {
            if (!isEdgePartOfTile(centerTileQ, centerTileR, referenceEdgeKey) || 
                !isEdgePartOfTile(centerTileQ, centerTileR, targetEdgeKey) ||
                referenceEdgeKey === targetEdgeKey) {
                return false;
            }

            const [ref_h1, ref_h2] = parseEdgeKey(referenceEdgeKey);
            const [tar_h1, tar_h2] = parseEdgeKey(targetEdgeKey);

            let pivotHex, otherHexFromRefEdge, otherHexFromTargetEdge;

            if (ref_h1.q === centerTileQ && ref_h1.r === centerTileR) { pivotHex = ref_h1; otherHexFromRefEdge = ref_h2; }
            else if (ref_h2.q === centerTileQ && ref_h2.r === centerTileR) { pivotHex = ref_h2; otherHexFromRefEdge = ref_h1; }
            else { return false; }
            
            if (tar_h1.q === centerTileQ && tar_h1.r === centerTileR) { otherHexFromTargetEdge = tar_h2; }
            else if (tar_h2.q === centerTileQ && tar_h2.r === centerTileR) { otherHexFromTargetEdge = tar_h1; }
            else { return false; }

            const dirToRefOther = { q: otherHexFromRefEdge.q - pivotHex.q, r: otherHexFromRefEdge.r - pivotHex.r };
            const dirToTargetOther = { q: otherHexFromTargetEdge.q - pivotHex.q, r: otherHexFromTargetEdge.r - pivotHex.r };

            const refDirIdx = findDirectionIndex(dirToRefOther);
            const targetDirIdx = findDirectionIndex(dirToTargetOther);

            if (refDirIdx === -1 || targetDirIdx === -1) return false;

            return (targetDirIdx === (refDirIdx + 1) % 6) || (targetDirIdx === (refDirIdx + 5) % 6);
        }


        // --- Initialization ---
function initializeGrid(tileLayoutMap = null, customUnits = null) {
    // 1. Setup Base Camp Defaults if needed
    if (!tileLayoutMap && !customUnits) {
        gameState.baseCampPositions = JSON.parse(JSON.stringify(DEFAULT_FLAG_HOME_POSITIONS));
    }

    // 2. Setup Canvas & UI
    canvas.width = CANVAS_WIDTH_NORMAL;
    canvas.height = CANVAS_HEIGHT_NORMAL;
    document.querySelectorAll('.ui-panel').forEach(panel => {
        panel.style.minHeight = canvas.height + 'px';
    });

    // 3. Reset Game State
    gameState.tiles.clear();
    gameState.edges.clear();
    gameState.units = [];
    gameState.gameOver = false;
    ui.victoryMessage.style.display = 'none';
    ui.endTurnButton.disabled = false;
    gameState.selectedUnit = null;
    gameState.hoveredUnitId = null;
    gameState.currentPlayer = 1;
    gameState.globalTurnNumber = 1;
    updateGlobalTurnDisplay();
    gameState.isDragging = false;
    gameState.draggingUnit = null;
    gameState.currentReachableMoves.clear();
    resetActionSelectionStates();
    gameState.actionLog = [];
    gameState.respawnQueue = {
        player1: [],
        player2: []
    };
    updateActionLogDisplay();
    updateRespawnQueueDisplay();

    // 4. Initialize Unit Counts
    gameState.unitCounts = {
        player1: { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 },
        player2: { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 }
    };

    // 5. Initialize Mode Specifics
    gameState.arcadeTurnTimer = ARCADE_TURN_TIME_SEC;
    gameState.swapState = 'none';
    gameState.unitToSwap = null;
    gameState.arcadeTotalTurns = 0;

    ui.endTurnButton.classList.remove('arcade-timer-active');
    ui.endTurnButton.style.background = '';
    ui.endTurnButton.textContent = "End Turn";

    if (gameState.gameMode === 'arcade') {
        gameState.supplyPoints = { player1: 0, player2: 0 };
        document.getElementById('supplyPointsContainer').style.display = 'block';
        ui.endTurnButton.classList.add('arcade-timer-active');
        gameState.flags = null; 
    } else {
        gameState.supplyPoints = { player1: 10, player2: 10 };
        document.getElementById('supplyPointsContainer').style.display = 'block';
    }

    // 6. Load Tiles
    if (tileLayoutMap) {
        const standardizedMap = (tileLayoutMap instanceof Map) ? tileLayoutMap : new Map(tileLayoutMap);
        const firstValue = standardizedMap.values().next().value;
        const isComplexObject = firstValue && (firstValue.type !== undefined) && (firstValue.type.name !== undefined);

        standardizedMap.forEach((value, key) => {
            const keyStr = String(key); 
            const [q, r] = keyStr.split(',').map(Number);
            
            if (isComplexObject) {
                if (value.type && value.type.name) {
                    const typeName = value.type.name.toUpperCase();
                    const rehydratedType = TILE_TYPES[typeName] || TILE_TYPES.PLAINS;
                    gameState.tiles.set(keyStr, { q, r, type: rehydratedType, fortifiedByPlayer: null });
                }
            } else {
                gameState.tiles.set(keyStr, { q, r, type: value, fortifiedByPlayer: null });
            }
        });
    } else {
        DEFAULT_MAP_LAYOUT_RADIUS_3.forEach((type, key) => {
            const [q, r] = key.split(',').map(Number);
            gameState.tiles.set(key, { q, r, type, fortifiedByPlayer: null });
        });
    }

    // 7. Generate Edges
    gameState.tiles.forEach(tile => {
        const { q, r } = tile;
        getNeighbors(q, r).forEach(n_coord => {
            if (gameState.tiles.has(getTileKey(n_coord.q, n_coord.r))) {
                const edgeKey = getEdgeKey(q, r, n_coord.q, n_coord.r);
                if (!gameState.edges.has(edgeKey)) {
                    gameState.edges.set(edgeKey, {
                        q1: q, r1: r, q2: n_coord.q, r2: n_coord.r,
                        units: [], bridge: false, bridgeHp: null, isPathway: true
                    });
                }
            }
        });
    });

    // 8. Place Units
    if (customUnits) {
        customUnits.forEach(unitInfo => {
            if (!unitInfo || !unitInfo.typeName) return;
            const typeName = unitInfo.typeName.toUpperCase();
            const type = UNIT_TYPES[typeName];
            if (type && gameState.edges.has(unitInfo.position)) {
                const newUnit = createUnit(unitInfo.player, type, unitInfo.position);
                gameState.units.push(newUnit);
            }
        });
    } else if (tileLayoutMap && tileLayoutMap !== DEFAULT_MAP_LAYOUT_RADIUS_3) {
        // Auto-place units for custom/generated maps based on the new dynamic limit
        const limit = getMaxUnitsForCurrentMap();
        placeUnitsOnNewGeneratedMap(limit);
    } else {
        // Default Starting Units
        if (gameState.gameMode === 'arcade') {
            gameState.units.push(createUnit(1, UNIT_TYPES.MELEE, getEdgeKey(1, -2, 0, -2)));
            gameState.units.push(createUnit(1, UNIT_TYPES.ARCHER, getEdgeKey(-2, 0, -1, -1)));
            gameState.units.push(createUnit(2, UNIT_TYPES.MELEE, getEdgeKey(-1, 2, 0, 2)));
            gameState.units.push(createUnit(2, UNIT_TYPES.ARCHER, getEdgeKey(1, 1, 2, 0)));
        } else {
            gameState.units.push(createUnit(1, UNIT_TYPES.MELEE, getEdgeKey(1, -2, 0, -2)));
            gameState.units.push(createUnit(1, UNIT_TYPES.ARCHER, getEdgeKey(-2, 0, -1, -1)));
            gameState.units.push(createUnit(1, UNIT_TYPES.PIKEMAN, getEdgeKey(-1, -1, 0, -2)));
            gameState.units.push(createUnit(1, UNIT_TYPES.HORSEMAN, getEdgeKey(-2, 0, -2, 1)));
            
            gameState.units.push(createUnit(2, UNIT_TYPES.MELEE, getEdgeKey(-1, 2, 0, 2)));
            gameState.units.push(createUnit(2, UNIT_TYPES.ARCHER, getEdgeKey(1, 1, 2, 0)));
            gameState.units.push(createUnit(2, UNIT_TYPES.PIKEMAN, getEdgeKey(0, 2, 1, 1)));
            gameState.units.push(createUnit(2, UNIT_TYPES.HORSEMAN, getEdgeKey(2, 0, 2, -1)));
        }
    }

    // 9. Link Units to Edges
    gameState.units.forEach(unit => {
        const edge = gameState.edges.get(unit.position);
        if (edge) edge.units.push(unit);
    });

    // 10. Initialize Unit State
    gameState.units.forEach(unit => {
        unit.currentMove = unit.type.baseMove;
        unit.hasPerformedMajorAction = false;
    });

    // 11. Initialize Flags
    if (gameState.gameMode !== 'arcade') {
        if (gameState.baseCampPositions.player1 && gameState.baseCampPositions.player2) {
            gameState.flags = {
                'p1_flag': { id: 'p1_flag', player: 1, homePosition: gameState.baseCampPositions.player1, status: 'at_base', carrierId: null },
                'p2_flag': { id: 'p2_flag', player: 2, homePosition: gameState.baseCampPositions.player2, status: 'at_base', carrierId: null }
            };
        }
    }

    updateTurnDisplay();
    updateSelectedUnitInfoPanel();
    checkVictoryCondition();
    updateSupplyPointsDisplay();
}

        function createUnit(player, type, edgeKey) {
            const unitId = `unit_${player}_${type.name.toLowerCase()}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
            
            if (gameState.unitCounts) {
                gameState.unitCounts[`player${player}`][type.name]++;
            }

            return {
    id: unitId, player, type, hp: type.hp, maxHp: type.hp,
    currentMove: type.baseMove, positionType: 'edge', position: edgeKey,
    isFortified: false, fortifiedTileKey: null, hasPerformedMajorAction: false,
    isCarryingFlag: false,
    turnsFortifiedAtBase: 0,
    turnsFortified: 0,
    fortifyCooldown: 0,
    canHeal: true,
    supplyLine: null,
    lastAttackedByHostileOnTurn: 0,
};
        }

        function spawnUnit(player, unitType) {
            const homeBaseEdgeKey = gameState.baseCampPositions[`player${player}`];
            let spawnEdgeKey = null;

            const isEdgeValidForSpawn = (edgeKey) => {
                const edge = gameState.edges.get(edgeKey);
                // A valid edge must exist, have less than 2 units, and have NO enemy units.
                // Also ensure it's not the home flag edge itself.
                if (edgeKey === homeBaseEdgeKey) return false;
                return edge && edge.units.length < 2 && !edge.units.some(u => u.player !== player);
            };

            // Search rotationally adjacent edges for a valid spawn point
            const adjacentEdges = getRotationallyAdjacentEdges(homeBaseEdgeKey);
            for (const edgeKey of adjacentEdges) {
                if (isEdgeValidForSpawn(edgeKey)) {
                    spawnEdgeKey = edgeKey;
                    break; 
                }
            }

            if (spawnEdgeKey) {
                const newUnit = createUnit(player, unitType, spawnEdgeKey);
                gameState.units.push(newUnit);
                const edge = gameState.edges.get(spawnEdgeKey);
                edge.units.push(newUnit);
                logAction(`P${player} ${unitType.name} has returned to the fight!`, player);
                return true;
            }
            
            logAction(`P${player} Base is blocked! Cannot respawn ${unitType.name}.`, player);
            return false;
        }

        function pointDistance(p1, p2) { return Math.sqrt(distSq(p1,p2)); }

function drawHexFill(q, r, tileType) {
            const { x, y } = axialToPixel(q, r);
            const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE

            // If we are in map maker mode, force fancy visuals to be off for this draw call.
            const useFancyVisuals = gameSettings.fancyVisualsEnabled && !gameState.mapMakerMode;

            if (useFancyVisuals) {
                // --- FANCY VISUALS ON ---
                if (tileType === TILE_TYPES.MOUNTAIN) {
                    const mountainColors = [
                        '#808080', '#707070', '#606060', '#707070', '#808080', '#A0A0A0'
                    ];
                    const vertices = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        vertices.push({ x: x + currentHexSize * Math.cos(angle), y: y + currentHexSize * Math.sin(angle) });
                    }
                    for (let i = 0; i < 6; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % 6];
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.closePath();
                        ctx.fillStyle = mountainColors[i];
                        ctx.fill();
                    }
                } else if (tileType === TILE_TYPES.FOREST) {
                    const forestEdgeColors = [
                        '#209020', '#207020', '#206020', '#207020', '#209020', '#209F20'
                    ];
                    const baseVertices = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        baseVertices.push({ x: x + currentHexSize * Math.cos(angle), y: y + currentHexSize * Math.sin(angle) });
                    }
                    for (let i = 0; i < 6; i++) {
                        const v1 = baseVertices[i];
                        const v2 = baseVertices[(i + 1) % 6];
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.closePath();
                        ctx.fillStyle = forestEdgeColors[i];
                        ctx.fill();
                    }
                    const topHexSize = currentHexSize * 0.75;
                    const topHexColor = '#208020';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = x + topHexSize * Math.cos(angle);
                        const vy = y + topHexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath();
                    ctx.fillStyle = topHexColor;
                    ctx.fill();
                } else if (tileType === TILE_TYPES.WATER) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(-60 * Math.PI / 180);
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = currentHexSize * Math.cos(angle);
                        const vy = currentHexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath();
                    ctx.clip();
                    const stripeColors = ['#60B0CF', '#6AC0D4', '#75D0DA', '#80E0E0'];
                    const stripeCount = 4;
                    const hexTotalWidth = currentHexSize * Math.sqrt(3);
                    const stripeWidth = hexTotalWidth / stripeCount;
                    const startX = -(hexTotalWidth / 2);
                    for (let i = 0; i < stripeCount; i++) {
                        ctx.fillStyle = stripeColors[i];
                        const stripeX = startX + (i * stripeWidth);
                        ctx.fillRect(stripeX, -currentHexSize, stripeWidth + 1, currentHexSize * 2);
                    }
                    ctx.restore();
                } else if (tileType === TILE_TYPES.PLAINS) {
                    // --- Logic for concentric Plains hexagons ---
                    const plainsColors = ['#70E070', '#7AE07A', '#85E085', '#90E090']; 
                    const plainsSizeMultipliers = [1.0, 0.75, 0.50, 0.25]; 

                    for (let i = 0; i < plainsSizeMultipliers.length; i++) {
                        const currentSize = currentHexSize * plainsSizeMultipliers[i];
                        ctx.fillStyle = plainsColors[i];
                        
                        ctx.beginPath();
                        for (let j = 0; j < 6; j++) {
                            const angle = Math.PI / 180 * (60 * j - 30);
                            const vx = x + currentSize * Math.cos(angle);
                            const vy = y + currentSize * Math.sin(angle);
                            if (j === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }

                } else { 
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = x + currentHexSize * Math.cos(angle); 
                        const vy = y + currentHexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath(); 
                    ctx.fillStyle = tileType.color;
                    ctx.fill();
                }
            } else {
                // --- FANCY VISUALS OFF (SIMPLE SOLID COLORS) ---
                let fallbackColor;
                switch (tileType) {
                    case TILE_TYPES.MOUNTAIN: fallbackColor = '#808080'; break;
                    case TILE_TYPES.FOREST: fallbackColor = '#208020'; break;
                    case TILE_TYPES.WATER: fallbackColor = '#80C0E0'; break;
                    case TILE_TYPES.PLAINS: fallbackColor = '#90E090'; break;
                    default: fallbackColor = tileType.color;
                }
                
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 180 * (60 * i - 30);
                    const vx = x + currentHexSize * Math.cos(angle); 
                    const vy = y + currentHexSize * Math.sin(angle);
                    if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                }
                ctx.closePath(); 
                ctx.fillStyle = fallbackColor;
                ctx.fill();
            }
        }

function drawHexEdgesAndBoundaries() {
            const edgeLineWidth = 2;
            const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE

            gameState.edges.forEach(edge => {
                const tileA = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
                const tileB = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
                if (!tileA || !tileB) return;
                const typeA = tileA.type; const typeB = tileB.type; let edgeStrokeColor;
                const landEdgeColor = '#A05030'; const beachEdgeColor = '#F0E090'; const waterEdgeColor = '#4080C0';
                if (isLand(typeA) && isLand(typeB)) edgeStrokeColor = landEdgeColor;
                else if ((isLand(typeA) && typeB === TILE_TYPES.WATER) || (typeA === TILE_TYPES.WATER && isLand(typeB))) edgeStrokeColor = beachEdgeColor;
                else if (typeA === TILE_TYPES.WATER && typeB === TILE_TYPES.WATER) edgeStrokeColor = waterEdgeColor;
                else edgeStrokeColor = '#1a252f';

                const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
                const edgeMidX = (p1_center.x + p2_center.x) / 2; const edgeMidY = (p1_center.y + p2_center.y) / 2;
                const dx_centers = p2_center.x - p1_center.x; const dy_centers = p2_center.y - p1_center.y;
                let perp_dx = -dy_centers; let perp_dy = dx_centers;
                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                if (len_perp_vec === 0) return;
                
                // Apply SCALED size here
                perp_dx = (perp_dx / len_perp_vec) * (currentHexSize / 2); 
                perp_dy = (perp_dy / len_perp_vec) * (currentHexSize / 2);
                
                ctx.beginPath(); ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy); ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                ctx.strokeStyle = edgeStrokeColor; ctx.lineWidth = edgeLineWidth; ctx.stroke();
            });

             const boundaryEdgeColor = '#000000';
             gameState.tiles.forEach(tile => {
                 const {q, r} = tile; const {x: centerX, y: centerY} = axialToPixel(q,r);
                 for (let directionIndex = 0; directionIndex < 6; directionIndex++) {
                     const neighborDir = AXIAL_DIRECTIONS[directionIndex];
                     const neighborQ = q + neighborDir.q; const neighborR = r + neighborDir.r;
                     if (!gameState.tiles.has(getTileKey(neighborQ, neighborR))) {
                         const edgeIndexOfCurrentHex = MAP_DIRECTION_TO_EDGE_INDEX[directionIndex];
                         const v1_idx = edgeIndexOfCurrentHex; const v2_idx = (edgeIndexOfCurrentHex + 1) % 6;
                         const vert1_angle = Math.PI / 180 * (60 * v1_idx - 30);
                         
                         // Apply SCALED size for boundary vertices
                         const edge_v1_x = centerX + currentHexSize * Math.cos(vert1_angle); 
                         const edge_v1_y = centerY + currentHexSize * Math.sin(vert1_angle);
                         
                         const vert2_angle = Math.PI / 180 * (60 * v2_idx - 30);
                         const edge_v2_x = centerX + currentHexSize * Math.cos(vert2_angle); 
                         const edge_v2_y = centerY + currentHexSize * Math.sin(vert2_angle);
                         
                         ctx.beginPath(); ctx.moveTo(edge_v1_x, edge_v1_y); ctx.lineTo(edge_v2_x, edge_v2_y);
                         ctx.strokeStyle = boundaryEdgeColor; ctx.lineWidth = edgeLineWidth; ctx.stroke();
                     }
                 }
             });
        }

        function drawUnitHealthBar(ctx, unitX, unitY, ringOuterRadius, ringThickness, currentHp, maxHp) {
            if (maxHp <= 0) return;
            
            const displayHpPercentage = Math.max(0, Math.min(1, currentHp / maxHp)); 
            const isShielded = currentHp > maxHp;

            const startAngle = -Math.PI / 2; 
            const fullAngle = 2 * Math.PI;
            const healthRingCenterlineRadius = ringOuterRadius - (ringThickness / 2);
            
            const originalLineWidth = ctx.lineWidth; 
            const originalLineCap = ctx.lineCap;
            ctx.lineWidth = ringThickness; 
            ctx.lineCap = 'butt';

            if (displayHpPercentage < 1) {
                ctx.beginPath(); 
                ctx.strokeStyle = '#4A4A4A'; 
                const healthEndAngle = startAngle + displayHpPercentage * fullAngle;
                ctx.arc(unitX, unitY, healthRingCenterlineRadius, healthEndAngle, startAngle + fullAngle, false);
                ctx.stroke();
            }

            if (displayHpPercentage > 0) {
                ctx.beginPath(); 
                ctx.strokeStyle = isShielded ? SHIELD_COLOR : '#32CD32'; 
                const currentHealthEndAngle = startAngle + displayHpPercentage * fullAngle;
                ctx.arc(unitX, unitY, healthRingCenterlineRadius, startAngle, currentHealthEndAngle, false);
                ctx.stroke();
            }
            
            ctx.lineWidth = originalLineWidth; 
            ctx.lineCap = originalLineCap;
        }


        function drawFortificationOutlines() {
            const currentHexSize = HEX_SIZE * gameState.renderScale; 
            const fortifiedTilesP1 = new Set();
            const fortifiedTilesP2 = new Set();

            gameState.tiles.forEach((tile, key) => {
                if (tile.fortifiedByPlayer === 1) fortifiedTilesP1.add(key);
                else if (tile.fortifiedByPlayer === 2) fortifiedTilesP2.add(key);
            });

            // --- Handle Base Camp Tiles (Array or String) ---
            const addBaseTiles = (baseData, set) => {
                if (Array.isArray(baseData)) {
                    baseData.forEach(key => set.add(key));
                } else if (baseData) {
                    const [h1, h2] = parseEdgeKey(baseData);
                    if (!isNaN(h1.q)) set.add(getTileKey(h1.q, h1.r));
                    if (!isNaN(h2.q)) set.add(getTileKey(h2.q, h2.r));
                }
            };
            addBaseTiles(gameState.baseCampPositions.player1, fortifiedTilesP1);
            addBaseTiles(gameState.baseCampPositions.player2, fortifiedTilesP2);

            const drawBordersForPlayer = (tileSet, color) => {
                tileSet.forEach(tileKey => {
                    const tile = gameState.tiles.get(tileKey);
                    if (!tile) return;

                    const { x: centerX, y: centerY } = axialToPixel(tile.q, tile.r);

                    for (let i = 0; i < 6; i++) {
                        const neighborDir = AXIAL_DIRECTIONS[i];
                        const neighborQ = tile.q + neighborDir.q;
                        const neighborR = tile.r + neighborDir.r;
                        const neighborKey = getTileKey(neighborQ, neighborR);

                        // Only draw edge if neighbor is NOT in the same set (internal edges hidden)
                        if (!tileSet.has(neighborKey)) {
                             const v1_idx = MAP_DIRECTION_TO_EDGE_INDEX[i];
                             const v2_idx = (v1_idx + 1) % 6;
                             
                             const vert1_angle = Math.PI / 180 * (60 * v1_idx - 30);
                             const edge_v1_x = centerX + currentHexSize * Math.cos(vert1_angle);
                             const edge_v1_y = centerY + currentHexSize * Math.sin(vert1_angle);

                             const vert2_angle = Math.PI / 180 * (60 * v2_idx - 30);
                             const edge_v2_x = centerX + currentHexSize * Math.cos(vert2_angle);
                             const edge_v2_y = centerY + currentHexSize * Math.sin(vert2_angle);
                             
                             ctx.beginPath();
                             ctx.moveTo(edge_v1_x, edge_v1_y);
                             ctx.lineTo(edge_v2_x, edge_v2_y);
                             ctx.strokeStyle = color;
                             ctx.lineWidth = 5;
                             ctx.stroke();
                        }
                    }
                });
            };

            drawBordersForPlayer(fortifiedTilesP1, currentDrawingColors.player1.primary);
            drawBordersForPlayer(fortifiedTilesP2, currentDrawingColors.player2.primary);
}

function drawContestedEdgeIndicator() {
            const CONTESTED_EDGE_COLOR = '#C440C4';
            const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE

            gameState.edges.forEach(edge => {
                if (edge.units.length < 2) return;

                const playerOnEdge = edge.units[0].player;
                const allUnitsSamePlayer = edge.units.every(u => u.player === playerOnEdge);
                if (!allUnitsSamePlayer) return;

                const hasArcher = edge.units.some(u => u.type.name === 'Archer');
                const hasMelee = edge.units.some(u => u.type.name === 'Melee');
                
                if (!hasArcher || !hasMelee) return;

                const opponentPlayer = playerOnEdge === 1 ? 2 : 1;
                const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
                const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
                const isContested = (tile1 && tile1.fortifiedByPlayer === opponentPlayer) || 
                                  (tile2 && tile2.fortifiedByPlayer === opponentPlayer);

                if (isContested) {
                    const p1_center = axialToPixel(edge.q1, edge.r1);
                    const p2_center = axialToPixel(edge.q2, edge.r2);
                    const edgeMidX = (p1_center.x + p2_center.x) / 2;
                    const edgeMidY = (p1_center.y + p2_center.y) / 2;

                    let perp_dx = -(p2_center.y - p1_center.y);
                    let perp_dy = p2_center.x - p1_center.x;
                    const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                    if (len_perp_vec > 0) {
                        const scale = currentHexSize / 2;
                        perp_dx = (perp_dx / len_perp_vec) * scale;
                        perp_dy = (perp_dy / len_perp_vec) * scale;
                        
                        const startX = edgeMidX + perp_dx;
                        const startY = edgeMidY + perp_dy;
                        const endX = edgeMidX - perp_dx;
                        const endY = edgeMidY - perp_dy;

                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = CONTESTED_EDGE_COLOR;
                        ctx.lineWidth = 5;
                        ctx.stroke();
                    }
                }
            });
        }

function drawPulsatingBridgeHighlights() {
    if (gameState.currentActionState !== ACTION_STATES.SELECTING_BRIDGE_EDGE) return;
    if (!gameState.validBridgeTargetEdgeKeys || gameState.validBridgeTargetEdgeKeys.length === 0) return;

    // Calculate pulsating opacity using a sine wave
    const currentTime = Date.now();
    const pulseDuration = 1750; 
    const progress = (currentTime % pulseDuration) / pulseDuration; // 0.0 to 1.0
    const sinValue = (Math.sin(progress * 2 * Math.PI) + 1) / 2; // 0.0 to 1.0, smoothly oscillating

    const minOpacity = 0.33;
    const maxOpacity = 0.66;
    const opacity = minOpacity + sinValue * (maxOpacity - minOpacity);

    ctx.save();
    ctx.globalAlpha = opacity; // Apply the translucency to the entire drawing operation

    gameState.validBridgeTargetEdgeKeys.forEach(edgeKey => {
        const edge = gameState.edges.get(edgeKey);
        if (edge) {
            // Call with simpleRender = true to hide the planks
            drawBridge(edge, undefined, undefined, undefined, true);
        }
    });

    ctx.restore(); // Restore globalAlpha to 1.0
}

function drawMapMakerHighlights() {
    if (!gameState.mapMakerMode) return;
    
    const brush = gameState.mapMakerBrush;
    if (brush.type === 'base_camp' && gameState.gridRadius === 4) {
        const player = brush.player;
        const currentBase = gameState.baseCampPositions[`player${player}`];
        
        // Show suggestions if base is not full
        if (Array.isArray(currentBase) && currentBase.length > 0 && currentBase.length < 3) {
            const validNeighbors = new Set();
            const enemyPlayer = player === 1 ? 2 : 1;
            const enemyBaseData = gameState.baseCampPositions[`player${enemyPlayer}`];
            const enemyBaseSet = new Set(Array.isArray(enemyBaseData) ? enemyBaseData : []);

            // Iterate over all existing base tiles to find potential neighbors
            currentBase.forEach(key => {
                const [q,r] = key.split(',').map(Number);
                getNeighbors(q,r).forEach(n => {
                    const nKey = getTileKey(n.q, n.r);
                    // Basic Checks: On map, not in own base, not in enemy base
                    if (gameState.tiles.has(nKey) && !currentBase.includes(nKey) && !enemyBaseSet.has(nKey)) {
                        
                        // --- CRITICAL FIX: Check Contiguity ---
                        // Would adding this tile make the set contiguous?
                        // This handles the "Split Base" scenario: only the tile connecting the split parts will pass this check.
                        const testSet = [...currentBase, nKey];
                        if (isSetContiguous(testSet)) {
                            validNeighbors.add(nKey);
                        }
                    }
                });
            });
            
            // Draw highlights
            drawActionSelectionHighlights(Array.from(validNeighbors), 'fortify');
        }
    }
}

function drawActionSelectionHighlights(targetKeys, type) {
            if (!targetKeys || targetKeys.length === 0) return;
            const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE
            let fillColor, strokeColor;
            switch(type) {
                case 'fortify':
                    fillColor = 'rgba(255, 255, 0, 0.3)'; strokeColor = '#FFD700';
                    targetKeys.forEach(tileKey => {
                        const tile = gameState.tiles.get(tileKey);
                        if (tile) {
                           const { x, y } = axialToPixel(tile.q, tile.r); ctx.beginPath();
                           for (let i = 0; i < 6; i++) {
                               const angle = Math.PI / 180 * (60 * i - 30);
                               const vx = x + currentHexSize * Math.cos(angle); const vy = y + currentHexSize * Math.sin(angle);
                               if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                           }
                           ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill();
                           ctx.strokeStyle = strokeColor; ctx.lineWidth = 3; ctx.stroke();
                        }
                    });
                    break;
                case 'unfortify':
                    fillColor = 'rgba(0, 150, 255, 0.4)';
                    strokeColor = '#007ACC';
                    targetKeys.forEach(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        if (edge) {
                            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                            ctx.beginPath(); ctx.arc(mid.x, mid.y, currentHexSize * 0.25, 0, 2 * Math.PI);
                            ctx.fillStyle = fillColor; ctx.fill();
                            ctx.strokeStyle = strokeColor; ctx.lineWidth = 2; ctx.stroke();
                        }
                    });
                    break;
                
                case 'bridge': // Adding case for bridge highlights if needed, generally covered by pulsating bridge
                     break;
            }
        }

function drawBridge(edge, color = '#8B4513', outlineColor = null, outlineWidth = 0, simpleRender = false) {
    const p1_center = axialToPixel(edge.q1, edge.r1);
    const p2_center = axialToPixel(edge.q2, edge.r2);
    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
    const angle = Math.atan2(p2_center.y - p1_center.y, p2_center.x - p1_center.x);
    
    const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE

    // The main bridge body dimensions
    const bridgeLength = currentHexSize * 0.9; 
    const bridgeThickness = currentHexSize * 0.15;

    ctx.save();
    ctx.translate(mid.x, mid.y);
    ctx.rotate(angle + Math.PI / 2); // Rotate to align with the edge itself

    // --- Draw the main bridge body (darker brown) ---
    ctx.fillStyle = color; 
    ctx.fillRect(-bridgeLength / 2, -bridgeThickness / 2, bridgeLength, bridgeThickness);
    
    // --- Conditionally draw the 4 perpendicular planks ---
    if (!simpleRender) {
        const plankColor = '#A0522D'; 
        const plankLength = bridgeThickness * 1.2; 
        const plankWidth = 5 * gameState.renderScale; // Scale the plank width too
        const gap = bridgeLength / 4.5; 

        ctx.fillStyle = plankColor;
        ctx.fillRect(-gap * 1.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
        ctx.fillRect(-gap * 0.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
        ctx.fillRect(gap * 0.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
        ctx.fillRect(gap * 1.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
    }

    if (outlineColor && outlineWidth > 0) {
        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = outlineWidth;
        ctx.strokeRect(-bridgeLength / 2, -bridgeThickness / 2, bridgeLength, bridgeThickness);
    }

    ctx.restore();
}

        function drawBridges() { gameState.edges.forEach(edge => { if (edge.bridge) drawBridge(edge); }); }

        function drawBridgeAttackHighlightsOnly(targetsToHighlight) {
            if (!targetsToHighlight || targetsToHighlight.length === 0) return;
            targetsToHighlight.forEach(targetInfo => {
                if (targetInfo.isBridgeTarget && targetInfo.edgeKey) {
                    const edge = gameState.edges.get(targetInfo.edgeKey);
                    if (edge && edge.bridge) drawBridge(edge, 'rgba(139, 69, 19, 0.5)', 'rgba(255, 0, 0, 0.9)', 3);
                }
            });
        }

function drawFlags() {
    if (gameState.gameMode === 'arcade') return;
    
    const renderFlagAt = (player, x, y) => {
        const teamColor = currentDrawingColors[`player${player}`].secondary;
        const flagIconColor = '#F0F0F0'; 
        const flagPoleColor = '#2c3e50';
        const circleRadius = HEX_SIZE * 0.18;
        const flagSize = circleRadius * 1.2; 

        ctx.save();
        ctx.translate(x, y);
        ctx.beginPath();
        ctx.arc(0, 0, circleRadius, 0, 2 * Math.PI);
        ctx.fillStyle = teamColor; 
        ctx.fill();
        ctx.strokeStyle = '#1a252f';
        ctx.lineWidth = 2;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-3, flagSize * 0.5);
        ctx.lineTo(-3, -flagSize * 0.5);
        ctx.strokeStyle = flagPoleColor;
        ctx.lineWidth = 3;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-2, -flagSize * 0.5);
        ctx.lineTo(flagSize * 0.45, -flagSize * 0.3);
        ctx.lineTo(-2, -flagSize * 0);
        ctx.closePath();
        ctx.fillStyle = flagIconColor; 
        ctx.fill(); 
        ctx.restore();
    };

    // 1. GAMEPLAY MODE (Uses gameState.flags)
    if (!gameState.mapMakerMode && gameState.flags) {
        Object.values(gameState.flags).forEach(flag => {
            if (flag.status === 'at_base' && flag.homePosition) {
                if (Array.isArray(flag.homePosition)) {
                    // Expansive Mode (Tile Array)
                    const pos = calculateBaseCentroid(flag.homePosition);
                    if (pos) renderFlagAt(flag.player, pos.x, pos.y);
                } else {
                    // Standard Mode (Edge String)
                    const edge = gameState.edges.get(flag.homePosition);
                    if (edge) {
                        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                        renderFlagAt(flag.player, mid.x, mid.y);
                    }
                }
            }
        });
    }
    // 2. MAP MAKER MODE (Expansive Preview)
    else if (gameState.mapMakerMode && gameState.gridRadius === 4) {
        for(let p = 1; p <= 2; p++) {
            const base = gameState.baseCampPositions[`player${p}`];
            if (Array.isArray(base) && base.length === 3) {
                const pos = calculateBaseCentroid(base);
                if (pos) renderFlagAt(p, pos.x, pos.y);
            }
        }
    }
    // 3. MAP MAKER MODE (Standard Preview)
    else if (gameState.mapMakerMode && gameState.gridRadius === 3) {
        // Standard mode in Map Maker usually sets flags in initializeGrid,
        // but if we are live editing rotation, we might need to fallback to baseCampPositions edge key
        // if flags aren't synced yet. However, `updateBaseCampLocations` syncs flags.
        if (gameState.flags) {
             Object.values(gameState.flags).forEach(flag => {
                const edge = gameState.edges.get(flag.homePosition);
                if (edge) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    renderFlagAt(flag.player, mid.x, mid.y);
                }
            });
        }
    }
}

        function drawSupplyLines() {
            if (gameState.gameMode === 'arcade') return;
            const currentTime = Date.now();
            const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE
            
            gameState.units.forEach(unit => {
                if (unit.isFortified && unit.supplyLine && unit.supplyLine.path) {
                    const path = unit.supplyLine.path;
                    if (path.length === 0) return;

                    const isIntercepted = path.some(edgeKey => {
                    const edge = gameState.edges.get(edgeKey);
                    if (!edge) return false;
                    return edge.units.some(u => u.player !== unit.player && (!gameState.isDragging || u.id !== gameState.draggingUnit.id));
                });

                    let lineColor, lineWidth, isDashed;
                    if (isIntercepted) {
                        lineColor = '#F0A010'; 
                        lineWidth = 4;
                        isDashed = true;
                    } else {
                        lineColor = unit.player === 1 ? hexToRgba(currentDrawingColors.player1.accent, 0.8) : hexToRgba(currentDrawingColors.player2.accent, 0.8);
                        const pulse = (Math.sin(currentTime / 300) + 1) / 2; 
                        lineWidth = 2 + pulse * 3; 
                        isDashed = false;
                    }

                    ctx.save();
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = lineWidth;
                    ctx.lineCap = 'round';
                    if (isDashed) {
                        ctx.setLineDash([15, 10]);
                    }

                    path.forEach(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        if(edge) {
                            const p1_center = axialToPixel(edge.q1, edge.r1);
                            const p2_center = axialToPixel(edge.q2, edge.r2);
                            const edgeMidX = (p1_center.x + p2_center.x) / 2;
                            const edgeMidY = (p1_center.y + p2_center.y) / 2;
                            
                            let perp_dx = -(p2_center.y - p1_center.y);
                            let perp_dy = p2_center.x - p1_center.x;
                            const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                            
                            if (len_perp_vec > 0) {
                                // Use SCALED size for the offset
                                const scale = currentHexSize / 2;
                                perp_dx = (perp_dx / len_perp_vec) * scale;
                                perp_dy = (perp_dy / len_perp_vec) * scale;

                                ctx.beginPath();
                                ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy);
                                ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                                ctx.stroke();
                            }
                        }
                    });
                    
                    ctx.restore();
                }
            });
        }

        function drawUnitAttackHighlightsOnly(targetsToHighlight) {
            if (!targetsToHighlight || targetsToHighlight.length === 0) return;
            targetsToHighlight.forEach(targetInfo => {
                if (!targetInfo.isBridgeTarget && targetInfo.unit) {
                    const targetUnit = targetInfo.unit; let unitX, unitY;
                    const unitSizeToHighlight = HEX_SIZE * 0.3;
                    if (targetUnit.isFortified && targetUnit.positionType === 'center' && targetInfo.tileKeyForTarget) {
                        const tile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                        if (tile) { const centerPixel = axialToPixel(tile.q, tile.r); unitX = centerPixel.x; unitY = centerPixel.y; }
                        else return;
                    } else if (targetInfo.edgeKey) {
                        const edge = gameState.edges.get(targetInfo.edgeKey); if (!edge) return;
                        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2); unitX = mid.x; unitY = mid.y;
                        const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                        const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === targetUnit.id);
                        if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                            const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                            let dx = p2.x - p1.x, dy = p2.y - p1.y; const len = Math.sqrt(dx*dx + dy*dy) || 1;
                            let perpX = -dy / len, perpY = dx / len;
                            unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                            unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                        }
                    } else return;
                    ctx.beginPath(); ctx.arc(unitX, unitY, unitSizeToHighlight, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; ctx.lineWidth = 3; ctx.stroke();
                }
            });
        }

        function drawSword(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 0.75; 
            // --- VISUAL ADJUSTMENT: Shift sword down slightly to center it ---
            const yOffset = scale * 0.1; 

            ctx.strokeStyle = symbolColor;
            ctx.fillStyle = symbolColor;
            ctx.lineWidth = Math.max(1.5, symbolDisplayRadius * 0.08);
            ctx.lineJoin = 'round';
            
            const pommelRadius = scale * 0.15;
            // Apply offset to pommel
            const pommelY = centerY + scale * 0.55 + yOffset;
            
            ctx.beginPath();
            ctx.arc(centerX, pommelY, pommelRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.lineCap = 'round';
            
            const guardWidth = scale * 0.75;
            // Apply offset to guard (rest of sword is derived from this)
            const guardY = centerY + scale * 0.2 + yOffset;
            const guardThickness = scale * 0.15;
            
            ctx.beginPath();
            ctx.moveTo(centerX - guardWidth / 2, guardY);
            ctx.lineTo(centerX + guardWidth / 2, guardY);
            const oldWidth = ctx.lineWidth;
            ctx.lineWidth = guardThickness;
            ctx.stroke();
            ctx.lineWidth = oldWidth;
            ctx.lineCap = 'butt';
            
            // --- Draw the Hilt (Handle) ---
            const hiltWidth = scale * 0.18;
            const hiltHeight = pommelY - guardY; 
            ctx.beginPath();
            ctx.rect(centerX - hiltWidth / 2, guardY, hiltWidth, hiltHeight);
            ctx.fill();

            const bladeWidth = scale * 0.22;
            const bladeHeight = scale * 0.9;
            const bladeY = guardY - bladeHeight;
            ctx.beginPath();
            ctx.rect(centerX - bladeWidth / 2, bladeY, bladeWidth, bladeHeight);
            ctx.fill();
            const tipBaseY = bladeY;
            const tipHeight = scale * 0.35;
            const tipTopY = tipBaseY - tipHeight;
            const tipWidth = bladeWidth * 1.1;
            ctx.beginPath();
            ctx.moveTo(centerX, tipTopY); 
            ctx.lineTo(centerX - tipWidth / 2, tipBaseY); 
            ctx.lineTo(centerX + tipWidth / 2, tipBaseY); 
            ctx.closePath();
            ctx.fill();
        }

        function drawArrow(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 1.0; 
            ctx.fillStyle = symbolColor;
            ctx.strokeStyle = symbolColor; 
            ctx.lineWidth = Math.max(1.0, symbolDisplayRadius * 0.05);
            ctx.lineJoin = 'round';
            ctx.beginPath();
            const tipY = centerY - scale * 0.7;
            ctx.moveTo(centerX, tipY);
            const headBaseY = centerY - scale * 0.4;
            const headWidth = scale * 0.4;
            ctx.lineTo(centerX - headWidth / 2, headBaseY); 
            const shaftWidth = scale * 0.15;
            const shaftTopY = centerY - scale * 0.35;
            ctx.lineTo(centerX - shaftWidth / 2, headBaseY);
            ctx.lineTo(centerX - shaftWidth / 2, shaftTopY);
            const fletchTopY = centerY + scale * 0.2;
            const fletchBottomY = centerY + scale * 0.7;
            const fletchWidth = scale * 0.5;
            ctx.lineTo(centerX - shaftWidth / 2, fletchTopY); 
            ctx.lineTo(centerX - fletchWidth / 2, fletchBottomY); 
            ctx.lineTo(centerX, centerY + scale * 0.55); 
            ctx.lineTo(centerX + fletchWidth / 2, fletchBottomY); 
            ctx.lineTo(centerX + shaftWidth / 2, fletchTopY);
            ctx.lineTo(centerX + shaftWidth / 2, shaftTopY);
            ctx.lineTo(centerX + shaftWidth / 2, headBaseY);
            ctx.lineTo(centerX + headWidth / 2, headBaseY);
            ctx.closePath();
            ctx.fill();
        }

        function drawPikemanSymbol(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 0.9; 
            ctx.strokeStyle = symbolColor;
            ctx.fillStyle = symbolColor;
            ctx.lineWidth = Math.max(1.0, symbolDisplayRadius * 0.05);
            ctx.lineJoin = 'round';
            ctx.beginPath();
            const shaftWidth = scale * 0.12;
            const shaftBottomY = centerY + scale * 0.75;
            ctx.moveTo(centerX - shaftWidth / 2, shaftBottomY);
            const axeBottomY = centerY + scale * 0.05;
            ctx.lineTo(centerX - shaftWidth / 2, axeBottomY);
            const axeTopY = centerY - scale * 0.35;
            ctx.quadraticCurveTo(
                centerX - scale * 0.6, 
                centerY - scale * 0.15,
                centerX - shaftWidth / 2, axeTopY 
            );
            const spearBaseY = centerY - scale * 0.5;
            ctx.lineTo(centerX - shaftWidth / 2, spearBaseY);
            const spearTipY = centerY - scale * 0.8;
            ctx.lineTo(centerX, spearTipY); 
            ctx.lineTo(centerX + shaftWidth / 2, spearBaseY); 
            const spikeTopY = centerY - scale * 0.3;
            ctx.lineTo(centerX + shaftWidth / 2, spikeTopY);
            const spikePointX = centerX + scale * 0.35;
            const spikeMidY = centerY - scale * 0.2;
            const spikeBottomY = centerY - scale * 0.1;
            ctx.lineTo(spikePointX, spikeMidY); 
            ctx.lineTo(centerX + shaftWidth / 2, spikeBottomY); 
            ctx.lineTo(centerX + shaftWidth / 2, shaftBottomY);
            ctx.closePath();
            ctx.fill();
        }

        function drawHorsemanSymbol(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 1.0;
            ctx.fillStyle = symbolColor;
            ctx.beginPath();
            ctx.moveTo(centerX - scale * 0.3, centerY + scale * 0.5);
            ctx.lineTo(centerX + scale * 0.3, centerY + scale * 0.5);
            ctx.lineTo(centerX + scale * 0.3, centerY + scale * 0.15);
            ctx.lineTo(centerX + scale * 0.15, centerY - scale * 0.05);
            ctx.lineTo(centerX + scale * 0.45, centerY - scale * 0.15);
            ctx.lineTo(centerX + scale * 0.45, centerY - scale * 0.35);
            ctx.lineTo(centerX + scale * 0.1, centerY - scale * 0.35);
            ctx.lineTo(centerX - scale * 0.1, centerY - scale * 0.6);
            ctx.lineTo(centerX - scale * 0.2, centerY - scale * 0.4);
            ctx.lineTo(centerX - scale * 0.3, centerY + scale * 0.1);
            ctx.closePath();
            ctx.fill();
        }

        function drawUnitSymbol(ctx, unit, x, y, radius, symbolColor) {
            const symbolDisplaySize = Math.max(1, radius);
            if (unit.type.symbol === 'M') {
                drawSword(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'A') {
                drawArrow(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'P') {
                drawPikemanSymbol(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'H') {
                drawHorsemanSymbol(ctx, x, y, symbolDisplaySize, symbolColor);
            } else { 
                ctx.fillStyle = symbolColor;
                ctx.font = `bold ${symbolDisplaySize * 1.5}px 'Exo 2'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(unit.type.symbol, x, y);
            }
        }

        function drawSingleUnit(ctx, unit, x, y, radius, overrideSymbolColor = null, isPalette = false) {

            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = unit.player === 1 ? currentDrawingColors.player1.primary : currentDrawingColors.player2.primary;
            ctx.fill();

            if (!isPalette && unit.maxHp > 0) { // Only draw health bar if not in palette
                const healthBarVisualThickness = radius * 0.3;
                drawUnitHealthBar(ctx, x, y, radius, healthBarVisualThickness, unit.hp, unit.maxHp);
            }
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            
            let mainBorderColor;
            let mainBorderWidth = 3;

            // In palette mode, don't show selection/hover/flag highlights
            if (isPalette) {
                 mainBorderColor = '#000';
                 mainBorderWidth = 1.5;
            } else {
                if (unit.isCarryingFlag) {
                    const enemyPlayer = unit.player === 1 ? 2 : 1;
                    mainBorderColor = currentDrawingColors[`player${enemyPlayer}`].primary;
                } else if (gameState.selectedUnit && gameState.selectedUnit.id === unit.id) {
                    mainBorderColor = '#FFD700';
                } else if (gameState.hoveredUnitId === unit.id && unit.player === gameState.currentPlayer) {
                    mainBorderColor = '#ADD8E6'; 
                    mainBorderWidth = 2.5;
                } else {
                    mainBorderColor = unit.isFortified ? '#FFF' : '#000';
                    mainBorderWidth = unit.isFortified ? 2 : 1.5;
                }
            }
            
            ctx.strokeStyle = mainBorderColor;
            ctx.lineWidth = mainBorderWidth;
            ctx.stroke();

            const symbolColor = overrideSymbolColor || (unit.isFortified && !isPalette ? '#000' : '#FFF');
            const radiusForSymbol = isPalette ? radius : (radius - (radius * 0.3));
            drawUnitSymbol(ctx, unit, x, y, radiusForSymbol, symbolColor);
        }

        function drawUnits() {
            const isEffectivelyDragging = gameState.isDragging && !gameState.mapMakerMode;
            const animatedUnitIds = new Set(gameState.activeAnimations.map(a => (a.unit || a.attacker).id));
            const offsetDistance = UNIT_ON_EDGE_OFFSET * gameState.renderScale;

            gameState.edges.forEach((edge) => {
                const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge' && (!isEffectivelyDragging || u.id !== gameState.draggingUnit.id));
                if (edgeUnitsOnly.length > 0) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    const p1_hex_center = axialToPixel(edge.q1, edge.r1); const p2_hex_center = axialToPixel(edge.q2, edge.r2);
                    let dx_centers = p2_hex_center.x - p1_hex_center.x; let dy_centers = p2_hex_center.y - p1_hex_center.y;
                    const len_centers = Math.sqrt(dx_centers*dx_centers + dy_centers*dy_centers) || 1;
                    let perpX = -dy_centers / len_centers; let perpY = dx_centers / len_centers;
                    
                    edgeUnitsOnly.forEach((unit, index) => {
                        if (animatedUnitIds.has(unit.id)) return;
                        let unitX = mid.x, unitY = mid.y;
                        if (edgeUnitsOnly.length > 1) {
                            const offsetSign = (index % 2 === 0) ? -1 : 1;
                            unitX += perpX * offsetDistance * offsetSign * (0.5); 
                            unitY += perpY * offsetDistance * offsetSign * (0.5);
                        }
                        drawSingleUnit(ctx, unit, unitX, unitY, UNIT_DRAW_SIZE_ON_EDGE * gameState.renderScale);
                    });
                }
            });

            gameState.units.forEach(unit => {
                if (animatedUnitIds.has(unit.id)) return;
                if (unit.isFortified && unit.positionType === 'center' && (!isEffectivelyDragging || unit.id !== gameState.draggingUnit.id)) {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const {x, y} = axialToPixel(tile.q, tile.r);
                        drawSingleUnit(ctx, unit, x, y, FORTIFIED_UNIT_DRAW_SIZE * gameState.renderScale);
                    }
                }
            });

            if (isEffectivelyDragging && gameState.draggingUnit) {
                const unit = gameState.draggingUnit;
                const unitX = gameState.dragUnitRenderX;
                const unitY = gameState.dragUnitRenderY;
                const baseRadius = unit.isFortified ? FORTIFIED_UNIT_DRAW_SIZE : UNIT_DRAW_SIZE_ON_EDGE;
                const fullRadius = (baseRadius * gameState.renderScale) * DRAG_SCALE_FACTOR;

                if (gameSettings.fancyVisualsEnabled) {
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 25;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    const shadowCasterRadius = fullRadius * 0.8;
                    ctx.beginPath();
                    ctx.arc(unitX, unitY, shadowCasterRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = '#000';
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
                drawSingleUnit(ctx, unit, unitX, unitY, fullRadius);
            }
        }


function drawMovementHighlights() {
    const unitForHighlights = gameState.isDragging ? gameState.draggingUnit : gameState.selectedUnit;
    const isActionSelectionActive = gameState.currentActionState !== ACTION_STATES.IDLE && 
                                    gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED;

    if (!unitForHighlights || unitForHighlights.isFortified || (!gameState.isDragging && isActionSelectionActive)) {
        return;
    }
    
    if (gameState.gameMode === 'singleplayer' && unitForHighlights.player !== gameState.playerSide) {
        return;
    }
            
    if (!gameState.isDragging) {
        if (unitForHighlights.currentMove < 1) return;
        if (unitForHighlights.hasPerformedMajorAction && !unitForHighlights.type.canMoveAfterAttack) {
            return;
        }
    }

    const highlightRadius = (HEX_SIZE * 0.2) * gameState.renderScale; // SCALED SIZE

    gameState.currentReachableMoves.forEach((data, edgeKey) => {
        if (!gameState.isDragging && edgeKey === unitForHighlights.position) return;
        const edge = gameState.edges.get(edgeKey);
        if (edge) {
            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            ctx.beginPath(); ctx.arc(mid.x, mid.y, highlightRadius, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; ctx.fill();
            ctx.strokeStyle = 'rgba(0, 100, 0, 0.6)'; ctx.lineWidth = 2; ctx.stroke();
        }
    });
}

        function drawDebugPath() {
            const currentTime = Date.now();

            if (gameState.potentialDebugPathToDraw && gameState.debugPathHoverStartTime !== null) {
                if (currentTime - gameState.debugPathHoverStartTime >= PATH_DRAW_HOVER_DELAY_MS) {
                    if (gameState.debugPathToDraw !== gameState.potentialDebugPathToDraw) {
                        gameState.debugPathToDraw = gameState.potentialDebugPathToDraw;
                        gameState.debugPathAnimationStartTime = currentTime; 
                        gameState.debugPathPauseStartTime = null;
                        gameState.lastDebugPathKey = gameState.debugPathToDraw ? gameState.debugPathToDraw.join('-') : null;
                    }
                }
            } else if (!gameState.potentialDebugPathToDraw && gameState.debugPathToDraw !== null) {
                gameState.debugPathToDraw = null;
                gameState.debugPathAnimationStartTime = null;
                gameState.debugPathPauseStartTime = null;
                gameState.lastDebugPathKey = null;
            }

            const pathEdgeKeysArray = gameState.debugPathToDraw;
            if (!pathEdgeKeysArray || pathEdgeKeysArray.length < 2) {
                return; 
            }
            
            let progress = 0;
            if (gameState.debugPathPauseStartTime !== null) { 
                if (currentTime - gameState.debugPathPauseStartTime >= PATH_DRAW_PAUSE_DURATION_MS) {
                    gameState.debugPathAnimationStartTime = currentTime; 
                    gameState.debugPathPauseStartTime = null;
                    progress = 0; 
                } else {
                    progress = 1.0; 
                }
            } else if (gameState.debugPathAnimationStartTime !== null) { 
                const elapsedTime = currentTime - gameState.debugPathAnimationStartTime;
                progress = elapsedTime / PATH_DRAW_ANIMATION_DURATION_MS;

                if (progress >= 1.0) {
                    progress = 1.0;
                    if (gameState.lastDebugPathKey === pathEdgeKeysArray.join('-')) {
                        gameState.debugPathPauseStartTime = currentTime; 
                    }
                }
            } else {
                return; 
            }
            
            progress = Math.min(1, progress); 


            ctx.save();
            ctx.strokeStyle = '#E6C410'; 
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const points = pathEdgeKeysArray.map(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (!edge) return null;
                return getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            }).filter(p => p !== null);

            if (points.length < 2) { ctx.restore(); return; }

            let totalPathLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalPathLength += pointDistance(points[i], points[i+1]);
            }
            if (totalPathLength === 0) { ctx.restore(); return; }

            const drawableLength = totalPathLength * progress;
            let lengthDrawn = 0;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const segmentLength = pointDistance(p1, p2);

                if (lengthDrawn + segmentLength <= drawableLength) {
                    ctx.lineTo(p2.x, p2.y);
                    lengthDrawn += segmentLength;
                } else {
                    const remainingLengthToDraw = drawableLength - lengthDrawn;
                    if (remainingLengthToDraw > 0 && segmentLength > 0) {
                        const fraction = remainingLengthToDraw / segmentLength;
                        const endX = p1.x + (p2.x - p1.x) * fraction;
                        const endY = p1.y + (p2.y - p1.y) * fraction;
                        ctx.lineTo(endX, endY);
                    }
                    break; 
                }
            }
            ctx.stroke();
            ctx.restore();
        }

function drawDebugAttackRangeHighlights() {
            if (gameState.currentActionState !== ACTION_STATES.SELECTING_ATTACK_TARGET) return;
            if (!gameState.debugAttackRangeHighlights || gameState.debugAttackRangeHighlights.length === 0) return;

            const currentHexSize = HEX_SIZE * gameState.renderScale; // SCALED SIZE
            const currentTime = Date.now();
            const pulseProgress = (currentTime % PULSE_DURATION_MS) / PULSE_DURATION_MS; 
            const minOpacity = 0.0;
            const maxOpacity = 0.9;
            const opacity = minOpacity + (Math.sin(pulseProgress * 2 * Math.PI) + 1) / 2 * (maxOpacity - minOpacity);
            
            ctx.save();
            ctx.strokeStyle = `rgba(255, 140, 0, ${opacity})`; 
            ctx.lineWidth = 5; 

            gameState.debugAttackRangeHighlights.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (!edge) return;

                const p1_center = axialToPixel(edge.q1, edge.r1);
                const p2_center = axialToPixel(edge.q2, edge.r2);

                const edgeMidX = (p1_center.x + p2_center.x) / 2;
                const edgeMidY = (p1_center.y + p2_center.y) / 2;

                let dx_centers = p2_center.x - p1_center.x;
                let dy_centers = p2_center.y - p1_center.y;

                let perp_dx = -dy_centers;
                let perp_dy = dx_centers;

                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                if (len_perp_vec === 0) return; 

                const scale = (currentHexSize / 2) * 0.95; 
                perp_dx = (perp_dx / len_perp_vec) * scale;
                perp_dy = (perp_dy / len_perp_vec) * scale;

                ctx.beginPath();
                ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy);
                ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                ctx.stroke();
            });
            ctx.restore();
        }

function triggerDamageVisual(targetUnit, attackStatus = 'normal') {
    // Get the unit's screen position and size for the effect
    let targetX, targetY, targetRadius;
    if (targetUnit.isFortified) {
        const tile = gameState.tiles.get(targetUnit.position);
        if (tile) {
            const center = axialToPixel(tile.q, tile.r);
            targetX = center.x;
            targetY = center.y;
            targetRadius = FORTIFIED_UNIT_DRAW_SIZE;
        }
    } else {
        const edge = gameState.edges.get(targetUnit.position);
        if (edge) {
            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            targetX = mid.x;
            targetY = mid.y;
            targetRadius = UNIT_DRAW_SIZE_ON_EDGE;
            // Adjust for stacked units
            const unitsOnEdge = edge.units.filter(u => u.positionType === 'edge');
            const unitIndex = unitsOnEdge.findIndex(u => u.id === targetUnit.id);
            if(unitsOnEdge.length > 1 && unitIndex !== -1) {
                const offsetSign = (unitIndex % 2 === 0) ? -1 : 1;
                const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                let dx = p2.x - p1.x, dy = p2.y - p1.y; const len = Math.sqrt(dx*dx + dy*dy) || 1;
                let perpX = -dy / len, perpY = dx / len;
                targetX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                targetY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
            }
        }
    }

    if (targetX !== undefined) {
        // --- DAMAGE RING LOGIC (Unchanged) ---
        const baseEffect = {
            type: 'damage_ring',
            x: targetX, y: targetY,
            unitRadius: targetRadius,
            startTime: Date.now(),
            duration: 500
        };

        if (attackStatus === 'disadvantage') {
            baseEffect.subType = 'disadvantage';
            gameState.visualEffects.push(baseEffect);
        } else if (attackStatus === 'advantage') {
            const effect1 = { ...baseEffect, subType: 'advantage' };
            const effect2 = { ...baseEffect, subType: 'advantage', startTime: Date.now() + 250 };
            gameState.visualEffects.push(effect1, effect2);
        } else {
            baseEffect.subType = 'normal';
            gameState.visualEffects.push(baseEffect);
        }

        // --- UPDATED UNIT FLASH LOGIC ---
        const flashEffect = {
            type: 'unit_flash',
            targetUnitId: targetUnit.id,
            startTime: Date.now(),
            flashCount: 1,
            color: 'rgba(255, 0, 0, 0.5)', // Default: Red
            duration: 300, // Shorter duration for single flashes
        };

        if (attackStatus === 'advantage') {
            flashEffect.flashCount = 2;
            flashEffect.duration = 600; // Longer duration for two flashes
        } else if (attackStatus === 'disadvantage') {
            flashEffect.color = 'rgba(255, 165, 0, 0.5)'; // Orange color
        }
        // For 'normal', the default red, single-flash settings are correct.

        gameState.visualEffects.push(flashEffect);
    }
}

function drawVisualEffects() {
    if (gameState.visualEffects.length === 0) return;

    const currentTime = Date.now();
    const effectsToRemove = [];
    
    ctx.save();
    gameState.visualEffects.forEach((effect, index) => {
        const elapsedTime = currentTime - effect.startTime;
        const progress = elapsedTime / effect.duration;

        if (progress >= 1) {
            effectsToRemove.push(index);
            if (effect.onComplete) {
                effect.onComplete();
            }
            return;
        }

        if (effect.type === 'damage_ring') {
            const startRadius = effect.unitRadius;
            const endRadius = startRadius * 1.8;
            
            const currentRadius = startRadius + (endRadius - startRadius) * progress;
            const opacity = 1.0 - progress;

            ctx.beginPath();
            ctx.arc(effect.x, effect.y, currentRadius, 0, 2 * Math.PI);

            let ringColor = `rgba(255, 50, 50, ${opacity})`;
            if (effect.subType === 'disadvantage') {
                ringColor = `rgba(255, 165, 0, ${opacity})`;
            }
            
            ctx.strokeStyle = ringColor;
            ctx.lineWidth = 3 + (4 * (1 - progress));
            ctx.stroke();
        } else if (effect.type === 'shield_ring') {
            const startRadius = effect.unitRadius;
            const endRadius = startRadius * 2.0;
            
            const currentRadius = startRadius + (endRadius - startRadius) * progress;
            const opacity = 1.0 - progress;

            ctx.beginPath();
            ctx.arc(effect.x, effect.y, currentRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(48, 196, 196, ${opacity})`; 
            ctx.lineWidth = 4 + (3 * (1 - progress));
            ctx.stroke();
        } else if (effect.type === 'unit_flash') {
            const unit = gameState.units.find(u => u.id === effect.targetUnitId);
            if (!unit) return;

            let isVisible = false;
            if (effect.flashCount === 2) {
                isVisible = (progress >= 0 && progress < 0.15) || (progress >= 0.25 && progress < 0.40);
            } else {
                isVisible = (progress >= 0 && progress < 0.40);
            }

            if (isVisible) {
                let unitX, unitY, unitRadius;
                if (unit.isFortified) {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const center = axialToPixel(tile.q, tile.r);
                        unitX = center.x;
                        unitY = center.y;
                        unitRadius = FORTIFIED_UNIT_DRAW_SIZE;
                    }
                } else {
                    const edge = gameState.edges.get(unit.position);
                    if (edge) {
                        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                        unitX = mid.x;
                        unitY = mid.y;
                        unitRadius = UNIT_DRAW_SIZE_ON_EDGE;
                        const unitsOnEdge = edge.units.filter(u => u.positionType === 'edge');
                        const unitIndex = unitsOnEdge.findIndex(u => u.id === unit.id);
                        if (unitsOnEdge.length > 1 && unitIndex !== -1) {
                            const offsetSign = (unitIndex % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edge.q1, edge.r1);
                            const p2 = axialToPixel(edge.q2, edge.r2);
                            let dx = p2.x - p1.x, dy = p2.y - p1.y;
                            const len = Math.sqrt(dx * dx + dy * dy) || 1;
                            let perpX = -dy / len, perpY = dx / len;
                            unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
                            unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
                        }
                    }
                }
                
                if (unitX !== undefined) {
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(unitX, unitY, unitRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        } else if (effect.type === 'flag_capture_burst') {
            const easedProgress = 1 - Math.pow(1 - progress, 3); // A strong ease-out for the expansion

            // The maximum length the line will grow to, using your adjusted factor.
            const maxLineLength = HEX_SIZE * 0.4; 
            
            // The line's length at the current moment in the animation.
            const currentLineLength = maxLineLength * easedProgress;

            // Overall effect opacity (fades out the whole effect over time).
            const globalOpacity = 1.0 - progress;

            const baseColor = effect.player === 1 ? currentDrawingColors.player1.accent : currentDrawingColors.player2.accent;
            
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i; 
                
                // --- Anchor the start and only animate the end ---

                // The START of the line is now FIXED at the unit's border.
                const startRadius = UNIT_DRAW_SIZE_ON_EDGE * 1.1;
                const startX = effect.x + Math.cos(angle) * startRadius;
                const startY = effect.y + Math.sin(angle) * startRadius;
                
                // The END of the line moves outwards from the start point.
                const endX = startX + Math.cos(angle) * currentLineLength;
                const endY = startY + Math.sin(angle) * currentLineLength;

                // The gradient should fade from opaque at the base to transparent at the tip.
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, hexToRgba(baseColor, globalOpacity));
                gradient.addColorStop(1, hexToRgba(baseColor, 0));

                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }
    });
    ctx.restore();

    for (let i = effectsToRemove.length - 1; i >= 0; i--) {
        gameState.visualEffects.splice(effectsToRemove[i], 1);
    }
}

function animateUnitAlongPath(unit, path, duration) {
    const animation = {
        unit: unit,
        path: path,
        startTime: Date.now(),
        duration: duration,
        isFinished: false,
        onComplete: null,
    };

    // Remove the unit from its starting edge immediately so it doesn't get drawn there.
const startEdge = gameState.edges.get(unit.position);
if(startEdge) {
    startEdge.units = startEdge.units.filter(u => u.id !== unit.id);
}
    // The unit is now "in animation" and not on any specific edge or tile.
    unit.positionType = 'animating';
    
    gameState.activeAnimations.push(animation);
    return animation;
}

function drawAnimations() {
    if (gameState.activeAnimations.length === 0) return; 
    
    const stillAnimating = [];
    const currentTime = Date.now();

    gameState.activeAnimations.forEach(anim => {
        const elapsedTime = currentTime - anim.startTime;
        let progress = elapsedTime / anim.duration;

        if (progress >= 1) {
            if (anim.onComplete) anim.onComplete();
            return;
        }

        const unitToAnimate = anim.unit || anim.attacker;
        
        if (anim.type === 'attack_lunge' || anim.type === 'attack_projectile') {
            // ... (All attack animation logic remains unchanged) ...
            const startPos = getUnitScreenPosition(unitToAnimate);
            if (!startPos) { stillAnimating.push(anim); return; }
            const drawRadius = unitToAnimate.isFortified ? FORTIFIED_UNIT_DRAW_SIZE : UNIT_DRAW_SIZE_ON_EDGE;
            if (anim.type === 'attack_lunge') {
                const targetPos = getUnitScreenPosition(anim.target);
                if (!targetPos) { stillAnimating.push(anim); return; }
                let currentPos = { x: startPos.x, y: startPos.y };
                const lungeDistanceFactor = 0.5; const windupDistanceFactor = -0.2;
                if (progress < 0.25) {
                    const phaseProgress = progress / 0.25;
                    currentPos.x = lerp(startPos.x, targetPos.x, phaseProgress * windupDistanceFactor);
                    currentPos.y = lerp(startPos.y, targetPos.y, phaseProgress * windupDistanceFactor);
                } else if (progress < 0.5) {
                    const phaseProgress = (progress - 0.25) / 0.25;
                    const windupX = lerp(startPos.x, targetPos.x, windupDistanceFactor); const windupY = lerp(startPos.y, targetPos.y, windupDistanceFactor);
                    const peakX = lerp(startPos.x, targetPos.x, lungeDistanceFactor); const peakY = lerp(startPos.y, targetPos.y, lungeDistanceFactor);
                    currentPos.x = lerp(windupX, peakX, phaseProgress); currentPos.y = lerp(windupY, peakY, phaseProgress);
                } else {
                    const phaseProgress = (progress - 0.5) / 0.5;
                    const peakX = lerp(startPos.x, targetPos.x, lungeDistanceFactor); const peakY = lerp(startPos.y, targetPos.y, lungeDistanceFactor);
                    currentPos.x = lerp(peakX, startPos.x, phaseProgress); currentPos.y = lerp(peakY, startPos.y, phaseProgress);
                }
                drawSingleUnit(ctx, unitToAnimate, currentPos.x, currentPos.y, drawRadius);
            } else { 
                const totalPreShotDuration = anim.preShotDuration.draw + anim.preShotDuration.hold;
                if (elapsedTime < totalPreShotDuration) {
                    const recoilFactor = -0.1; const someTargetPos = getUnitScreenPosition(anim.targets[0]);
                    if (!someTargetPos) { stillAnimating.push(anim); return; }
                    const recoilX = lerp(startPos.x, someTargetPos.x, recoilFactor); const recoilY = lerp(startPos.y, someTargetPos.y, recoilFactor);
                    if (elapsedTime < anim.preShotDuration.draw) {
                        const phaseProgress = elapsedTime / anim.preShotDuration.draw;
                        const currentX = lerp(startPos.x, recoilX, phaseProgress); const currentY = lerp(startPos.y, recoilY, phaseProgress);
                        drawSingleUnit(ctx, unitToAnimate, currentX, currentY, drawRadius);
                    } else {
                        drawSingleUnit(ctx, unitToAnimate, recoilX, recoilY, drawRadius);
                    }
                } else {
                    drawSingleUnit(ctx, unitToAnimate, startPos.x, startPos.y, drawRadius);
                    const travelElapsedTime = elapsedTime - totalPreShotDuration; const travelProgress = travelElapsedTime / anim.travelDuration;
                    anim.targets.forEach(targetUnit => {
                        const targetPos = getUnitScreenPosition(targetUnit); if (!targetPos) return;
                        const projectileX = lerp(startPos.x, targetPos.x, travelProgress); const projectileY = lerp(startPos.y, targetPos.y, travelProgress);
                        ctx.beginPath(); ctx.moveTo(projectileX, projectileY);
                        const dx = targetPos.x - startPos.x; const dy = targetPos.y - startPos.y;
                        const len = Math.sqrt(dx*dx + dy*dy) || 1;
                        const tailX = projectileX - (dx/len) * 15; const tailY = projectileY - (dy/len) * 15;
                        ctx.lineTo(tailX, tailY);
                        ctx.strokeStyle = '#90A0A0'; ctx.lineWidth = 3; ctx.stroke();
                    });
                }
            }
        } else if (anim.type === 'fortify' || anim.type === 'unfortify') {
             const startPos = getUnitScreenPosition(unitToAnimate);
             if (!startPos && anim.type === 'fortify') { stillAnimating.push(anim); return; }
            if (anim.type === 'fortify') {
                 const [q, r] = anim.targetTileKey.split(',').map(Number);
                 const endPos = axialToPixel(q, r);
                 const fortifyDrawRadius = FORTIFIED_UNIT_DRAW_SIZE;
                 const travelPhaseDuration = 0.4; 
                 if (progress < travelPhaseDuration) {
                     let travelProgress = progress / travelPhaseDuration;
                     const easedTravelProgress = 1 - Math.pow(1 - travelProgress, 3);
                     const currentX = lerp(startPos.x, endPos.x, easedTravelProgress);
                     const currentY = lerp(startPos.y, endPos.y, easedTravelProgress);
                     drawSingleUnit(ctx, anim.unit, currentX, currentY, fortifyDrawRadius);
                 } 
                 else {
                     const newSymbolColor = '#000';
                     drawSingleUnit(ctx, anim.unit, endPos.x, endPos.y, fortifyDrawRadius, newSymbolColor);
                     let ringPhaseProgress = (progress - travelPhaseDuration) / (1 - travelPhaseDuration);
                     const easedRingProgress = Math.pow(ringPhaseProgress, 2);
                     const ringOpacity = easedRingProgress;
                     const ringColor = anim.unit.player === 1 ? `rgba(91, 148, 255, ${ringOpacity})` : `rgba(255, 99, 132, ${ringOpacity})`;
                     const currentHexSize = HEX_SIZE * easedRingProgress;
                     ctx.strokeStyle = ringColor;
                     ctx.lineWidth = 4;
                     ctx.beginPath();
                     for (let i = 0; i < 6; i++) {
                         const angle = Math.PI / 180 * (60 * i - 30);
                         const vx = endPos.x + currentHexSize * Math.cos(angle);
                         const vy = endPos.y + currentHexSize * Math.sin(angle);
                         if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                     }
                     ctx.closePath();
                     ctx.stroke();
                 }
            } else { // unfortify
                 const collapsePhaseDuration = 0.5;
                 const [q, r] = anim.startTileKey.split(',').map(Number);
                 const unfortifyStartPos = axialToPixel(q, r);
                if (progress < collapsePhaseDuration) {
                    drawSingleUnit(ctx, anim.unit, unfortifyStartPos.x, unfortifyStartPos.y, FORTIFIED_UNIT_DRAW_SIZE, '#000');
                    let phaseProgress = progress / collapsePhaseDuration;
                    const easedProgress = Math.pow(phaseProgress, 2);
                    const ringOpacity = 1.0 - easedProgress;
                    const ringColor = anim.unit.player === 1 ? `rgba(91, 148, 255, ${ringOpacity})` : `rgba(255, 99, 132, ${ringOpacity})`;
                    const currentHexSize = HEX_SIZE * (1.0 - easedProgress);
                    ctx.strokeStyle = ringColor;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = unfortifyStartPos.x + currentHexSize * Math.cos(angle);
                        const vy = unfortifyStartPos.y + currentHexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const [endH1, endH2] = parseEdgeKey(anim.targetEdgeKey);
                    const endPos = getEdgeMidpoint(endH1.q, endH1.r, endH2.q, endH2.r);
                    let phaseProgress = (progress - collapsePhaseDuration) / (1 - collapsePhaseDuration);
                    const easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
                    const currentX = lerp(unfortifyStartPos.x, endPos.x, easedProgress);
                    const currentY = lerp(unfortifyStartPos.y, endPos.y, easedProgress);
                    drawSingleUnit(ctx, anim.unit, currentX, currentY, UNIT_DRAW_SIZE_ON_EDGE, '#FFF');
                }
            }
        } else if (anim.type === 'build_bridge') {
            const builder = anim.unit;
            const startPos = getUnitScreenPosition(builder);
            const targetEdge = gameState.edges.get(anim.targetEdgeKey);

            if (!startPos || !targetEdge) { stillAnimating.push(anim); return; }

            const targetEdgePos = getEdgeMidpoint(targetEdge.q1, targetEdge.r1, targetEdge.q2, targetEdge.r2);
            
            // Define the "build" position near the edge
            const buildPos = {
                x: lerp(startPos.x, targetEdgePos.x, 0.4), // Move 40% of the way to the edge
                y: lerp(startPos.y, targetEdgePos.y, 0.4)
            };

            let currentPos = { x: 0, y: 0 };
            
            // --- Phase 1: Move FORWARD, fade in main body (0 -> 0.25) ---
            if (progress < 0.25) {
                const phaseProgress = progress / 0.25;
                currentPos.x = lerp(startPos.x, buildPos.x, phaseProgress);
                currentPos.y = lerp(startPos.y, buildPos.y, phaseProgress);
                
                ctx.globalAlpha = phaseProgress;
                drawBridge(targetEdge, '#8B4513'); // Main body only
                ctx.globalAlpha = 1.0;
            }
            // --- Phase 2: Move BACK (0.25 -> 0.5) ---
            else if (progress < 0.5) {
                const phaseProgress = (progress - 0.25) / 0.25;
                currentPos.x = lerp(buildPos.x, startPos.x, phaseProgress);
                currentPos.y = lerp(buildPos.y, startPos.y, phaseProgress);
                
                drawBridge(targetEdge, '#8B4513'); // Main body is now solid
            }
            // --- Phase 3: Move FORWARD again, fade in planks (0.5 -> 0.75) ---
            else if (progress < 0.75) {
                const phaseProgress = (progress - 0.5) / 0.25;
                currentPos.x = lerp(startPos.x, buildPos.x, phaseProgress);
                currentPos.y = lerp(startPos.y, buildPos.y, phaseProgress);

                drawBridge(targetEdge, '#8B4513'); // Draw solid main body first
                ctx.globalAlpha = phaseProgress;
                drawBridge(targetEdge, 'transparent'); // Draw planks on top with fade
                ctx.globalAlpha = 1.0;
            }
            // --- Phase 4: Move BACK again (0.75 -> 1.0) ---
            else {
                const phaseProgress = (progress - 0.75) / 0.25;
                currentPos.x = lerp(buildPos.x, startPos.x, phaseProgress);
                currentPos.y = lerp(buildPos.y, startPos.y, phaseProgress);
                
                drawBridge(targetEdge); // Draw full, solid bridge
            }
            
            // Draw the builder at its calculated current position for this frame
            drawSingleUnit(ctx, builder, currentPos.x, currentPos.y, UNIT_DRAW_SIZE_ON_EDGE);
        }
        
        stillAnimating.push(anim);
    });

    gameState.activeAnimations = stillAnimating;
}

        function gameLoop() {
            // --- ARCADE LOGIC ---
            if (gameState.gameMode === 'arcade' && !gameState.gameOver && !gameState.mapMakerMode) {
                // ... (timer logic unchanged) ...
                if (gameState.activeAnimations.length === 0) { 
                    gameState.arcadeTurnTimer -= 1/60; 
                    if (gameState.arcadeTurnTimer <= 0) {
                        gameState.arcadeTurnTimer = 0;
                        if (gameState.globalTurnNumber >= 2 && gameState.swapState !== 'complete') {
                            handleForcedSwap();
                        } else {
                            proceedToEndTurn();
                        }
                    }
                }
                const pct = Math.max(0, (gameState.arcadeTurnTimer / ARCADE_TURN_TIME_SEC) * 100);
                const activeColor = '#E04030'; 
                const emptyColor = '#C03020';
                ui.endTurnButton.style.background = `linear-gradient(to right, ${activeColor} ${pct}%, ${emptyColor} ${pct}%)`;
                ui.endTurnButton.textContent = `End Turn (${Math.ceil(gameState.arcadeTurnTimer)}s)`;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ... (color transition logic unchanged) ...
            if (gameState.colorTransition.active) {
                const elapsedTime = Date.now() - gameState.colorTransition.startTime;
                const progress = Math.min(elapsedTime / COLOR_TRANSITION_DURATION_MS, 1);
                currentDrawingColors.player1.primary = lerpColor(gameState.colorTransition.from.player1.primary, gameState.colorTransition.to.player1.primary, progress);
                currentDrawingColors.player2.primary = lerpColor(gameState.colorTransition.from.player2.primary, gameState.colorTransition.to.player2.primary, progress);
                currentDrawingColors.player1.secondary = lerpColor(gameState.colorTransition.from.player1.secondary, gameState.colorTransition.to.player1.secondary, progress); 
                currentDrawingColors.player2.secondary = lerpColor(gameState.colorTransition.from.player2.secondary, gameState.colorTransition.to.player2.secondary, progress); 
                currentDrawingColors.player1.accent = lerpColor(gameState.colorTransition.from.player1.accent, gameState.colorTransition.to.player1.accent, progress);
                currentDrawingColors.player2.accent = lerpColor(gameState.colorTransition.from.player2.accent, gameState.colorTransition.to.player2.accent, progress);
                if (progress >= 1) gameState.colorTransition.active = false;
            } else {
                currentDrawingColors.player1.primary = TEAM_COLORS.player1.primary;
                currentDrawingColors.player2.primary = TEAM_COLORS.player2.primary;
                currentDrawingColors.player1.secondary = TEAM_COLORS.player1.secondary;
                currentDrawingColors.player2.secondary = TEAM_COLORS.player2.secondary;
                currentDrawingColors.player1.accent = TEAM_COLORS.player1.accent;
                currentDrawingColors.player2.accent = TEAM_COLORS.player2.accent;
            }

            // ... (Outline logic unchanged) ...
            if (gameState.mapMakerMode) {
                canvas.style.outlineColor = '#F0F0F0';
            } else if (gameState.gameOver) {
                canvas.style.outlineColor = 'transparent';
            } else if (gameState.gameMode === 'arcade' && gameState.swapState === 'selecting_unit') {
                const time = Date.now();
                const playerColor = TEAM_COLORS[`player${gameState.currentPlayer}`].secondary;
                const alertColor = '#FFC020'; 
                const pulse = (Math.sin(time / 200) + 1) / 2; 
                canvas.style.outlineColor = lerpColor(playerColor, alertColor, pulse);
            } else {
                canvas.style.outlineColor = gameState.currentPlayer === 1 ? TEAM_COLORS.player1.secondary : TEAM_COLORS.player2.secondary;
            }

            gameState.tiles.forEach(tile => drawHexFill(tile.q, tile.r, tile.type));
            drawHexEdgesAndBoundaries();
            drawFortificationOutlines();
            drawContestedEdgeIndicator();
            drawPulsatingBridgeHighlights();
            drawFlags();
            drawBridges();
            drawSupplyLines();
            
            drawDebugAttackRangeHighlights() 

            if (!gameState.isDragging) {
                switch(gameState.currentActionState) {
                    case ACTION_STATES.SELECTING_FORTIFY_TILE:
                        drawActionSelectionHighlights(gameState.validFortifyTargetTileKeys, 'fortify');
                        break;
                    case ACTION_STATES.SELECTING_UNFORTIFY_EDGE:
                        drawActionSelectionHighlights(gameState.validUnfortifyTargetEdgeKeys, 'unfortify');
                        break;
                    case ACTION_STATES.SELECTING_BRIDGE_EDGE:
                        drawActionSelectionHighlights(gameState.validBridgeTargetEdgeKeys, 'bridge');
                        break;
                    case ACTION_STATES.SELECTING_ATTACK_TARGET:
                        const currentAttackTargets = gameState.selectedUnit?.type.attackType === 'melee' 
                            ? gameState.validMeleeAttackTargets 
                            : gameState.validArcherAttackTargets;
                        drawBridgeAttackHighlightsOnly(currentAttackTargets); 
                        break;
                }
                
                // ADDED: Draw map maker highlights if needed
                drawMapMakerHighlights();
            }
            
            drawDebugPath();
            drawAnimations();
            drawMovementHighlights();
            drawUnits();
            drawVisualEffects();

            if (!gameState.isDragging && gameState.currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET) {
                 const currentAttackTargets = gameState.selectedUnit?.type.attackType === 'melee'
                    ? gameState.validMeleeAttackTargets 
                    : gameState.validArcherAttackTargets;
                 drawUnitAttackHighlightsOnly(currentAttackTargets); 
            }
            
            requestAnimationFrame(gameLoop);
        }

            // Function to set CSS Variables from the TEAM_COLORS object
            function updateCssVariables() {
                const root = document.documentElement;
                root.style.setProperty('--p1-color-secondary', TEAM_COLORS.player1.secondary);
                root.style.setProperty('--p2-color-secondary', TEAM_COLORS.player2.secondary);
            }


        function updateTurnDisplay() {
            // This function is now ONLY responsible for text updates.
            // The canvas outline color is handled in the gameLoop.
            if (gameState.mapMakerMode) {
                // If we enter map maker mode, we still want to hide the turn text.
                // The gameLoop will handle hiding the border.
                return;
            }

            if (ui.turnDisplay) {
                ui.turnDisplay.textContent = `Player ${gameState.currentPlayer}'s Turn`;
            }
        }

        function updateGlobalTurnDisplay() {
            if (ui.globalTurnCounterDisplay) {
                ui.globalTurnCounterDisplay.textContent = `Turn: ${gameState.globalTurnNumber}`;
            }
        }

        function updateActionButtonState(button, baseText, cancelText, isSelecting, canPerformCondition, additionalDisabledCondition = false) {
            button.textContent = isSelecting ? cancelText : baseText;
            button.classList.toggle('selecting', isSelecting);
            if (isSelecting) {
                button.disabled = false;
            } else {
                button.disabled = !canPerformCondition || additionalDisabledCondition;
            }
        }
        
        function updateSelectedUnitInfoPanel() {
            if (gameState.mapMakerMode) {
                if (event.button === 0) { // Left Mouse Button
                    applyMapMakerBrush(x, y);
                } else if (event.button === 2) { // Right Mouse Button
                    eraseAt(x, y);
                }
                return;
            }
            const { selectedUnit, currentActionState } = gameState;

            if (currentActionState !== ACTION_STATES.SELECTING_ATTACK_TARGET) {
                gameState.debugAttackRangeHighlights = [];
            }
            
            if (selectedUnit && !gameState.isDragging) {
                ui.selectedUnitInfoContainer.style.display = 'block';
                ui.actionInfoContainer.style.display = 'none';
                ui.actionsPanel.style.display = 'flex';
                ui.unitName.textContent = `${selectedUnit.type.name} (P${selectedUnit.player})`;
                ui.unitHP.textContent = selectedUnit.hp; ui.unitMaxHP.textContent = selectedUnit.maxHp;
                ui.unitMovement.textContent = Math.floor(selectedUnit.currentMove);
                ui.unitPosition.textContent = selectedUnit.positionType === 'edge' ? `Edge (${selectedUnit.position.substring(0,7)}...)` : `Center (${selectedUnit.position})`;
                let statusText = "Ready";
                if (selectedUnit.isCarryingFlag) statusText = "Carrying Flag";
                else if (selectedUnit.hp > selectedUnit.maxHp) statusText = "Shielded";
                else if (selectedUnit.isFortified) statusText = `Fortified on ${selectedUnit.fortifiedTileKey}`;
                else if (selectedUnit.hasPerformedMajorAction) statusText = "Action Taken";
                else if (selectedUnit.currentMove < 1) statusText = "No MP Left";
                ui.unitStatus.textContent = statusText;

                const canPerformMajorAction = !selectedUnit.hasPerformedMajorAction;
                const canAttack = selectedUnit.currentMove >= ATTACK_COST && !selectedUnit.hasPerformedMajorAction;

                if (selectedUnit.type.canFortify) {
                    ui.fortifyUnfortifyButton.style.display = 'inline-block';
                    const isSelectingFortify = currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE;
                    const isSelectingUnfortify = currentActionState === ACTION_STATES.SELECTING_UNFORTIFY_EDGE;
                    const canAffordFortify = selectedUnit.currentMove >= FORTIFY_UNFORTIFY_COST;
                    
                    let fortifyDisabledCondition = false;
                    if (selectedUnit.isFortified) { // Unfortify logic
                        if (!isSelectingUnfortify) {
                           fortifyDisabledCondition = getPotentialUnfortifyTargets(selectedUnit).length === 0;
                        }
                        updateActionButtonState(ui.fortifyUnfortifyButton, "Unfortify", "Cancel Unfortify", isSelectingUnfortify, canPerformMajorAction && canAffordFortify, fortifyDisabledCondition);
                    } else { // Fortify logic
                        if (!isSelectingFortify) {
                            const edgeCoords = parseEdgeKey(selectedUnit.position);
                            if (edgeCoords && edgeCoords.length === 2 && !isNaN(edgeCoords[0].q)) {
                                const tile1 = gameState.tiles.get(getTileKey(edgeCoords[0].q, edgeCoords[0].r));
                                const tile2 = gameState.tiles.get(getTileKey(edgeCoords[1].q, edgeCoords[1].r));
                                const canFortifyTile1 = tile1 && tile1.type.canFortify && tile1.fortifiedByPlayer === null;
                                const canFortifyTile2 = tile2 && tile2.type.canFortify && tile2.fortifiedByPlayer === null;
                                fortifyDisabledCondition = !(canFortifyTile1 || canFortifyTile2) || selectedUnit.positionType === 'center';
                            } else {
                                fortifyDisabledCondition = true;
                            }
                        }
                        updateActionButtonState(ui.fortifyUnfortifyButton, "Fortify", "Cancel Fortify", isSelectingFortify, canPerformMajorAction && canAffordFortify, fortifyDisabledCondition);
                    }
                } else {
                    ui.fortifyUnfortifyButton.style.display = 'none';
                }

                ui.buildBridgeButton.style.display = selectedUnit.type.canBuildBridge ? 'inline-block' : 'none';
                if (selectedUnit.type.canBuildBridge) {
                    const isSelectingBridge = currentActionState === ACTION_STATES.SELECTING_BRIDGE_EDGE;
                    let bridgeDisabledCondition = selectedUnit.isFortified;
                    if (!isSelectingBridge && !bridgeDisabledCondition) {
                        bridgeDisabledCondition = getPotentialBridgeTargets(selectedUnit).length === 0;
                    }
                    const canAffordBridge = selectedUnit.currentMove >= BUILD_BRIDGE_COST;
                    updateActionButtonState(ui.buildBridgeButton, "Build Bridge", "Cancel Bridge", isSelectingBridge, canPerformMajorAction && canAffordBridge, bridgeDisabledCondition);
                }

                ui.attackButton.style.display = selectedUnit.type.attackType ? 'inline-block' : 'none';
                if (selectedUnit.type.attackType) {
                    const isSelectingAttack = currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET;
                    let attackDisabledCondition = false;
                    if (!isSelectingAttack) {
                        if (selectedUnit.type.attackType === 'melee') {
                            attackDisabledCondition = getValidMeleeAttackTargets(selectedUnit).length === 0;
                        } else if (selectedUnit.type.attackType === 'ranged') {
                            attackDisabledCondition = getValidArcherAttackTargets(selectedUnit).length === 0;
                        }
                    }
                    updateActionButtonState(ui.attackButton, "Attack", "Cancel Attack", isSelectingAttack, canAttack, attackDisabledCondition);
                }
            } else if (!gameState.isDragging) {
                ui.selectedUnitInfoContainer.style.display = 'none';
                ui.actionInfoContainer.style.display = 'block';
                ui.actionsPanel.style.display = 'none';
                resetActionSelectionStates();
                ui.fortifyUnfortifyButton.textContent = "Fortify"; ui.fortifyUnfortifyButton.classList.remove('selecting');
                ui.buildBridgeButton.textContent = "Build Bridge"; ui.buildBridgeButton.classList.remove('selecting');
                ui.attackButton.textContent = "Attack"; ui.attackButton.classList.remove('selecting');
            }
        }

        function showRespawnModal(player) {
            const overlay = document.getElementById('respawnModalOverlay');
            const content = document.getElementById('respawnModalContent');
            if (!overlay || !content) return;

            // --- Check for total army size limit using the new helper ---
            const currentUnitCount = gameState.units.filter(u => u.player === player).length;
            if (currentUnitCount >= getMaxUnitsForCurrentMap()) { // CHANGED HERE
                logAction(`P${player} has reached the maximum army size! Cannot reinforce.`, player);
                // Reset the timer for the unit in the queue so it can try again next turn.
                const queueKey = `player${player}`;
                if (gameState.respawnQueue[queueKey][0]) {
                    gameState.respawnQueue[queueKey][0].turnsRemaining = 1;
                }
                updateRespawnQueueDisplay(); 
                return; 
            }

            // --- Original Logic ---
            content.className = `modal-content modal-p${player}`;

            const counts = gameState.unitCounts[`player${player}`];
            
            const meleeButton = document.getElementById('respawnMelee');
            meleeButton.disabled = counts.Melee >= UNIT_CAPS.Melee;
            meleeButton.innerHTML = UNIT_SVGS.MELEE;

            const archerButton = document.getElementById('respawnArcher');
            archerButton.disabled = counts.Archer >= UNIT_CAPS.Archer;
            archerButton.innerHTML = UNIT_SVGS.ARCHER;
            
            const pikemanButton = document.getElementById('respawnPikeman');
            pikemanButton.disabled = counts.Pikeman >= UNIT_CAPS.Pikeman;
            pikemanButton.innerHTML = UNIT_SVGS.PIKEMAN;

            const horsemanButton = document.getElementById('respawnHorseman');
            horsemanButton.disabled = counts.Horseman >= UNIT_CAPS.Horseman;
            horsemanButton.innerHTML = UNIT_SVGS.HORSEMAN;

            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('modal-visible'), 10);
        }

        function hideRespawnModal() {
            const overlay = document.getElementById('respawnModalOverlay');
            const content = document.getElementById('respawnModalContent');
            if (!overlay) return;
            
            overlay.classList.remove('modal-visible');
            setTimeout(() => {
                overlay.style.display = 'none';
                if (content) content.classList.remove('swap-mode'); // Clean up custom swap class
            }, 300);
        }

        function updateRespawnQueueDisplay() {
            const container = document.getElementById('reinforcementsContainer');
            const listEl = document.getElementById('reinforcementsList');

            if (!container || !listEl) return;

            listEl.innerHTML = ''; 

            const p1Queue = gameState.respawnQueue.player1.map(item => ({ ...item, player: 1 }));
            const p2Queue = gameState.respawnQueue.player2.map(item => ({ ...item, player: 2 }));
            const combinedQueue = [...p1Queue, ...p2Queue];

            if (combinedQueue.length > 0) {
                container.style.display = 'block';
                combinedQueue.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `log-entry respawn-item log-p${item.player}`;
                    
                    const unitInfo = `
                        <div class="respawn-unit-info">
                            <span class="respawn-unit-symbol">${item.unitType.symbol}</span>
                            <span>${item.unitType.name}</span>
                        </div>`;
                    const timerInfo = `<div class="respawn-timer">${item.turnsRemaining} Turns</div>`;
                    
                    itemDiv.innerHTML = unitInfo + timerInfo;
                    listEl.appendChild(itemDiv);
                });
            } else {
                container.style.display = 'none';
            }
        }

        function showInstruction(message, duration = 3000) {
            ui.messageBox.textContent = message.replace(/<br>/g, ' '); 
            ui.messageBox.style.display = 'block';
            if (ui.messageBox.timeoutId) clearTimeout(ui.messageBox.timeoutId);
            ui.messageBox.timeoutId = setTimeout(() => { ui.messageBox.style.display = 'none'; }, duration);
        }

function handleUnitDeath(unitToDie, reason = "destroyed") {
    // Check if the unit is still in the game's master list.
    // This is the most reliable way to prevent errors from destroying the same unit twice.
    const unitExists = gameState.units.some(u => u.id === unitToDie.id);
    if (!unitExists) {
        return; // Already destroyed in this action.
    }

    // Immediately call destroyUnit, no animation.
    destroyUnit(unitToDie, reason);
}

        function logAction(message, player, duration = 3000) {
            showInstruction(message, duration);
            gameState.actionLog.push({ message: message, player: player });
            if (gameState.actionLog.length > 25) {
                gameState.actionLog.shift();
            }
            updateActionLogDisplay();
        }
        
        // --- Game Logic Core ---
        function destroyUnit(unitToDestroy, reason = "destroyed") {
            const activePlayer = gameState.currentPlayer;
            const destroyedPlayer = unitToDestroy.player;
            const wasFortified = unitToDestroy.isFortified;

            gameState.unitCounts[`player${destroyedPlayer}`][unitToDestroy.type.name]--;

    if (unitToDestroy.isCarryingFlag) {
        const flag = Object.values(gameState.flags).find(f => f.carrierId === unitToDestroy.id);
        if (flag) {
            flag.status = 'at_base';
            flag.carrierId = null;
            unitToDestroy.isCarryingFlag = false;
            logAction(`The P${flag.player} flag has been returned to base!`, activePlayer);

            // Restore supply points and recalculate the entire network
            updateSupplyPointsBasedOnFlagStatus(flag.player); // This restores points to 10
            recalculatePlayerSupplyNetwork(flag.player);      // This recalculates lines and deducts costs
        }
    }
            
            const queueKey = `player${destroyedPlayer}`;
            gameState.respawnQueue[queueKey].push({
                unitType: unitToDestroy.type,
                turnsRemaining: RESPAWN_TURN_TIMER,
                timerHalved: false
            });
            updateRespawnQueueDisplay();

            if (reason === "bridge_collapse") {
                logAction(`P${destroyedPlayer} ${unitToDestroy.type.name} fell as the bridge collapsed!`, activePlayer, 3500);
            } else if (reason === "zoc_move" || reason === "zoc_turn_start" || reason === "fort_zoc") {
                logAction(`P${destroyedPlayer} ${unitToDestroy.type.name} destroyed by ZoC!`, activePlayer, 3500);
            } else {
                logAction(`P${destroyedPlayer} ${unitToDestroy.type.name} has been destroyed!`, activePlayer, 3000);
            }

            if (unitToDestroy.positionType === 'edge') {
                const edgeOfUnit = gameState.edges.get(unitToDestroy.position);
                if (edgeOfUnit) edgeOfUnit.units = edgeOfUnit.units.filter(u => u.id !== unitToDestroy.id);
            } else if (unitToDestroy.positionType === 'center' && wasFortified) {
                const fortifiedTile = gameState.tiles.get(unitToDestroy.position);
                if (fortifiedTile && fortifiedTile.fortifiedByPlayer === destroyedPlayer) fortifiedTile.fortifiedByPlayer = null;
            }

            gameState.units = gameState.units.filter(u => u.id !== unitToDestroy.id);

        // If the destroyed unit was fortified, its removal might change the supply network
        if (wasFortified) {
            const playerFlag = gameState.flags[`p${destroyedPlayer}_flag`];
            // Only recalculate the network if that player's flag is NOT currently stolen.
            if (playerFlag && playerFlag.status !== 'carried') {
                recalculatePlayerSupplyNetwork(destroyedPlayer);
            } else {
                // If the flag is stolen, just refund the supply points without recalculating the network.
                // This prevents other forts from being re-supplied accidentally.
                if (unitToDestroy.supplyLine && unitToDestroy.supplyLine.cost > 0) {
                    gameState.supplyPoints[`player${destroyedPlayer}`] += Math.round(unitToDestroy.supplyLine.cost);
                    updateSupplyPointsDisplay();
                }
            }
        }
        
        if (gameState.selectedUnit && gameState.selectedUnit.id === unitToDestroy.id) {
                gameState.selectedUnit = null;
                gameState.currentReachableMoves.clear();
                resetActionSelectionStates();
                updateSelectedUnitInfoPanel();
            }
            if (gameState.hoveredUnitId === unitToDestroy.id) {
                gameState.hoveredUnitId = null;
                canvas.style.cursor = 'default';
            }
            if (gameState.draggingUnit && gameState.draggingUnit.id === unitToDestroy.id) {
                gameState.isDragging = false;
                gameState.draggingUnit = null;
                canvas.style.cursor = 'default';
            }

            checkVictoryCondition();
        }

function getMaxUnitsForCurrentMap() {
    if (gameState.gridRadius === 2) return 2; // Compact/Arcade
    if (gameState.gridRadius === 4) return 6; // Expansive
    return 4; // Standard (Radius 3)
}

function getMapMakerBaseCampTileKeys() {
    const baseCampTileKeys = new Set();
    
    // Check Player 1
    const p1Data = gameState.baseCampPositions.player1;
    if (Array.isArray(p1Data)) {
        // Expansive Mode (Array of tile keys)
        p1Data.forEach(k => baseCampTileKeys.add(k));
    } else if (typeof p1Data === 'string') {
        // Standard Mode (Edge key string)
        const [h1, h2] = parseEdgeKey(p1Data);
        if (!isNaN(h1.q)) baseCampTileKeys.add(getTileKey(h1.q, h1.r));
        if (!isNaN(h2.q)) baseCampTileKeys.add(getTileKey(h2.q, h2.r));
    }

    // Check Player 2
    const p2Data = gameState.baseCampPositions.player2;
    if (Array.isArray(p2Data)) {
        p2Data.forEach(k => baseCampTileKeys.add(k));
    } else if (typeof p2Data === 'string') {
        const [h1, h2] = parseEdgeKey(p2Data);
        if (!isNaN(h1.q)) baseCampTileKeys.add(getTileKey(h1.q, h1.r));
        if (!isNaN(h2.q)) baseCampTileKeys.add(getTileKey(h2.q, h2.r));
    }
    
    return baseCampTileKeys;
}

function getEdgeCost(unit, edgeKey) {
    const edge = gameState.edges.get(edgeKey);
    if (!edge) return Infinity;

    const tileCoords = parseEdgeKey(edgeKey);
    const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
    const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
    if (!tile1 || !tile2) return Infinity;

    let baseCost;

    if (edge.bridge) {
        baseCost = 1;
    } else {
        const isT1Water = tile1.type === TILE_TYPES.WATER;
        const isT2Water = tile2.type === TILE_TYPES.WATER;

        if (isT1Water && isT2Water) {
            return Infinity; 
        } else if (isT1Water || isT2Water) {
            baseCost = 3; 
        } else {
            if (tile1.type === TILE_TYPES.MOUNTAIN || tile2.type === TILE_TYPES.MOUNTAIN) {
                baseCost = TILE_TYPES.MOUNTAIN.baseMoveCost;
            } else if (tile1.type === TILE_TYPES.FOREST || tile2.type === TILE_TYPES.FOREST) {
                baseCost = TILE_TYPES.FOREST.baseMoveCost;
            } else {
                baseCost = TILE_TYPES.PLAINS.baseMoveCost;
            }
        }
    }
    
    // Apply fortification penalty
    let fortificationPenalty = 0;
    const enemyPlayer = unit.player === 1 ? 2 : 1;
    
    // --- FIX: Handle Polymorphic Base Camp Data (String or Array) ---
    const enemyBaseData = gameState.baseCampPositions[`player${enemyPlayer}`];
    let enemyBaseTiles = [];
    
    if (Array.isArray(enemyBaseData)) {
        // Expansive Map: Array of Tile Keys
        enemyBaseTiles = enemyBaseData;
    } else if (typeof enemyBaseData === 'string') {
        // Standard Map: Edge Key String "q,r_q,r"
        enemyBaseTiles = enemyBaseData.split('_');
    }
    // ----------------------------------------------------------------

    if ((tile1.fortifiedByPlayer && tile1.fortifiedByPlayer === enemyPlayer) ||
        (tile2.fortifiedByPlayer && tile2.fortifiedByPlayer === enemyPlayer) ||
        enemyBaseTiles.includes(getTileKey(tile1.q, tile1.r)) ||
        enemyBaseTiles.includes(getTileKey(tile2.q, tile2.r)))
    {
        fortificationPenalty = 1;
    }

    const finalCost = baseCost + fortificationPenalty;
    return (baseCost === 3) ? finalCost : Math.min(finalCost, MAX_MOVEMENT_COST);
}
        // --- Pathfinding ---
        function getRotationallyAdjacentEdges(currentEdgeKey) {
            const adjacentEdges = new Set(); const [h1, h2] = parseEdgeKey(currentEdgeKey);
            if (isNaN(h1.q) || isNaN(h2.q)) return [];
            const findEdgesAroundPivot = (pivotHex, fromHex) => {
                const dirToFromHex = { q: fromHex.q - pivotHex.q, r: fromHex.r - pivotHex.r };
                const initialDirIndex = findDirectionIndex(dirToFromHex); if (initialDirIndex === -1) return;
                const ccwDirIndex = (initialDirIndex + 1) % 6; const cwDirIndex = (initialDirIndex + 5) % 6;
                const ccwNeighborCoords = { q: pivotHex.q + AXIAL_DIRECTIONS[ccwDirIndex].q, r: pivotHex.r + AXIAL_DIRECTIONS[ccwDirIndex].r };
                const cwNeighborCoords = { q: pivotHex.q + AXIAL_DIRECTIONS[cwDirIndex].q, r: pivotHex.r + AXIAL_DIRECTIONS[cwDirIndex].r };
                if (gameState.tiles.has(getTileKey(ccwNeighborCoords.q, ccwNeighborCoords.r))) adjacentEdges.add(getEdgeKey(pivotHex.q, pivotHex.r, ccwNeighborCoords.q, ccwNeighborCoords.r));
                if (gameState.tiles.has(getTileKey(cwNeighborCoords.q, cwNeighborCoords.r))) adjacentEdges.add(getEdgeKey(pivotHex.q, pivotHex.r, cwNeighborCoords.q, cwNeighborCoords.r));
            };
            findEdgesAroundPivot(h1, h2); findEdgesAroundPivot(h2, h1);
            return Array.from(adjacentEdges);
        }

        function getPossibleMoves(unit) {
    if (gameState.mapMakerMode) {
        return new Map(); 
    }
    if (!unit || unit.currentMove < 1 || unit.isFortified) return new Map();
    
    if (unit.hasPerformedMajorAction) {
        if (!unit.type.canMoveAfterAttack) {
            return new Map();
        }
        if (isEdgeAdjacentToSpearWall(unit, unit.position)) {
            return new Map(); 
        }
    }

    const playerBaseData = gameState.baseCampPositions[`player${unit.player}`];
    
    let reachable = new Map();
    let frontier = [{ edgeKey: unit.position, pathCost: 0, pathTaken: [unit.position] }];
    let minCostsFound = new Map(); minCostsFound.set(unit.position, 0);
    
    while (frontier.length > 0) {
        frontier.sort((a, b) => a.pathCost - b.pathCost); 
        const current = frontier.shift();

        if (current.pathCost > (minCostsFound.get(current.edgeKey) || Infinity)) continue;
        
        const rotationallyAdjacentEdges = getRotationallyAdjacentEdges(current.edgeKey);

        for (const nextAdjacentEdgeKey of rotationallyAdjacentEdges) {
            
            // --- FIX: Check restricted base edges for both types ---
            let isRestrictedBaseEdge = false;
            
            if (Array.isArray(playerBaseData)) {
                // Expansive Logic: Check if edge is internal to base array
                const [h1, h2] = parseEdgeKey(nextAdjacentEdgeKey);
                const t1 = getTileKey(h1.q, h1.r);
                const t2 = getTileKey(h2.q, h2.r);
                if (playerBaseData.includes(t1) && playerBaseData.includes(t2)) {
                    isRestrictedBaseEdge = true;
                }
            } else if (typeof playerBaseData === 'string') {
                // Standard Logic: Check exact edge key match
                if (nextAdjacentEdgeKey === playerBaseData) {
                    isRestrictedBaseEdge = true;
                }
            }

            // A unit cannot move onto its own team's restricted base edge, UNLESS carrying flag.
            if (isRestrictedBaseEdge && !unit.isCarryingFlag) {
                continue;
            }
            // -------------------------------------------------------

            if (nextAdjacentEdgeKey === unit.position && current.pathTaken.length === 1) continue;
            const nextAdjacentEdgeObject = gameState.edges.get(nextAdjacentEdgeKey); if (!nextAdjacentEdgeObject) continue;
            if (nextAdjacentEdgeObject.units.some(u => u.player !== unit.player)) continue;
            const friendlyUnitsOnNext = nextAdjacentEdgeObject.units.filter(u => u.player === unit.player);
            if (friendlyUnitsOnNext.length >= 2 && !friendlyUnitsOnNext.find(u => u.id === unit.id)) continue;
            const costToTraverseNextEdge = getEdgeCost(unit, nextAdjacentEdgeKey); if (costToTraverseNextEdge === Infinity) continue;
            const newTotalPathCost = current.pathCost + costToTraverseNextEdge;
            if (newTotalPathCost <= unit.currentMove) {
                const knownMinCost = minCostsFound.get(nextAdjacentEdgeKey) || Infinity;
                if (newTotalPathCost < knownMinCost) {
                    minCostsFound.set(nextAdjacentEdgeKey, newTotalPathCost);
                    const newPathTaken = current.pathTaken.concat(nextAdjacentEdgeKey);
                    frontier.push({ edgeKey: nextAdjacentEdgeKey, pathCost: newTotalPathCost, pathTaken: newPathTaken });
                    if (nextAdjacentEdgeKey !== unit.position) reachable.set(nextAdjacentEdgeKey, { cost: newTotalPathCost, path: newPathTaken });
                }
            }
        }
    }
    return reachable;
}

        function findSupplyPath(startFortTileKey, player) {
            // If the player's flag is stolen, they cannot have a supply line.
            const playerFlag = gameState.flags[`p${player}`];
            if (playerFlag && playerFlag.status === 'carried') {
                return null;
            }

            const baseEdgeKey = gameState.baseCampPositions[`player${player}`];
            const [baseH1, baseH2] = parseEdgeKey(baseEdgeKey);
            
            // The "start" for our pathfinding are all edges adjacent to the fort
            const startTile = gameState.tiles.get(startFortTileKey);
            if (!startTile) return null;
            const startEdges = getEdgesOfTile(startTile.q, startTile.r);
            
            // The "goals" are all edges adjacent to either base tile
            const endEdges = new Set([...getEdgesOfTile(baseH1.q, baseH1.r), ...getEdgesOfTile(baseH2.q, baseH2.r)]);

            let frontier = [];
            for (const edge of startEdges) {
                if (isRoad(edge)) {
                     frontier.push({ edgeKey: edge, cost: getEdgeCost({player}, edge), path: [edge] });
                }
            }

            let visited = new Map();
            startEdges.forEach(edge => visited.set(edge, { cost: 0, path: [] }));

            while (frontier.length > 0) {
                frontier.sort((a, b) => a.cost - b.cost);
                const current = frontier.shift();

                if (endEdges.has(current.edgeKey)) {
                    // Path found! Now calculate the adjusted cost.
                    let adjustedCost = current.cost;
                    const fullPath = current.path;

                    // Subtract the cost of the first and last edge segments.
                    if (fullPath.length > 0) {
                        adjustedCost -= getEdgeCost({ player }, fullPath[0]);
                    }
                    if (fullPath.length > 1) {
                        adjustedCost -= getEdgeCost({ player }, fullPath[fullPath.length - 1]);
                    }

                    const visualPath = fullPath.length > 2 ? fullPath.slice(1, -1) : [];
                    return { path: visualPath, cost: Math.max(0, adjustedCost) }; // Ensure cost isn't negative
                }

                const adjacentEdges = getRotationallyAdjacentEdges(current.edgeKey);
                for (const neighborEdgeKey of adjacentEdges) {
                    if (!isRoad(neighborEdgeKey)) continue;

                    const costToNeighbor = getEdgeCost({ player }, neighborEdgeKey);
                    const newCost = current.cost + costToNeighbor;

                    if (!visited.has(neighborEdgeKey) || newCost < visited.get(neighborEdgeKey).cost) {
                        const newPath = [...current.path, neighborEdgeKey];
                        visited.set(neighborEdgeKey, { cost: newCost, path: newPath });
                        frontier.push({ edgeKey: neighborEdgeKey, cost: newCost, path: newPath });
                    }
                }
            }

            return null; // No path found
        }

        function recalculatePlayerSupplyNetwork(playerNum) {
            if (gameState.gameMode === 'arcade') return;

            const playerSupplyKey = `player${playerNum}`;
            const maxSupply = 10;

            // Guard clause to prevent supply calculation if flag is stolen
            const playerFlag = gameState.flags[`p${playerNum}_flag`];
            if (playerFlag && playerFlag.status === 'carried') {
                gameState.units.forEach(unit => {
                    if (unit.player === playerNum) {
                        unit.supplyLine = null;
                    }
                });
                return; 
            }

            // Reset all non-base supply lines for the player to start fresh
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    const baseEdgeKey = DEFAULT_FLAG_HOME_POSITIONS[playerSupplyKey];
                    // Safety check for base edge
                    if (baseEdgeKey) {
                        const playerBaseTiles = [baseEdgeKey.split('_')[0], baseEdgeKey.split('_')[1]];
                        if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                             unit.supplyLine = null;
                        }
                    } else {
                        unit.supplyLine = null;
                    }
                }
            });

            // Find all fortified units and their potential individual paths
            const potentialSupplies = [];
            const fortifiedUnits = gameState.units.filter(u => u.player === playerNum && u.isFortified);

            fortifiedUnits.forEach(unit => {
                const baseEdgeKey = DEFAULT_FLAG_HOME_POSITIONS[playerSupplyKey];
                if (baseEdgeKey) {
                    const playerBaseTiles = [baseEdgeKey.split('_')[0], baseEdgeKey.split('_')[1]];
                    if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                        const pathData = findSupplyPath(unit.fortifiedTileKey, playerNum);
                        if (pathData) {
                            potentialSupplies.push({
                                unit: unit,
                                cost: Math.round(pathData.cost), 
                                pathData: pathData
                            });
                        }
                    }
                }
            });

            potentialSupplies.sort((a, b) => a.cost - b.cost);

            let allUsedRoads = new Set();
            let networkSupplyCost = 0;
            
            potentialSupplies.forEach(supply => {
                const pathEdges = new Set(supply.pathData.path);
                let incrementalCost = 0;
                pathEdges.forEach(road => {
                    if (!allUsedRoads.has(road)) {
                        incrementalCost += getEdgeCost({ player: playerNum }, road);
                    }
                });

                if (networkSupplyCost + incrementalCost <= maxSupply) {
                    networkSupplyCost += incrementalCost;
                    supply.unit.supplyLine = supply.pathData;
                    pathEdges.forEach(road => allUsedRoads.add(road));
                } else {
                    supply.unit.supplyLine = null;
                }
            });

            gameState.supplyPoints[playerSupplyKey] = maxSupply - Math.round(networkSupplyCost);
            updateSupplyPointsDisplay();
        }

function fundNewFortification(unit) {
    const player = unit.player;
    const playerSupplyKey = `player${player}`;

    const pathData = findSupplyPath(unit.fortifiedTileKey, player);

    if (pathData && pathData.cost <= gameState.supplyPoints[playerSupplyKey]) {
        // Can afford it, fund the new line
        unit.supplyLine = pathData;
        gameState.supplyPoints[playerSupplyKey] -= Math.round(pathData.cost);
        logAction(`P${player} ${unit.type.name} established a supply line (Cost: ${Math.round(pathData.cost)}).`, player);
    } else {
        // Cannot afford it or no path exists, remains unsupplied
        unit.supplyLine = null;
        logAction(`P${player} ${unit.type.name} fortified, but is unsupplied.`, player);
    }
    updateSupplyPointsDisplay();
}

        function severSupplyLinesForPlayer(playerNum) {
            logAction(`P${playerNum}'s flag was stolen! Supply lines have been cut.`, playerNum === 1 ? 2 : 1);
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    unit.supplyLine = null;
                }
            });
        }

        function recalculateSupplyLinesForPlayer(playerNum) {
            logAction(`P${playerNum}'s flag has been returned! Supply lines are re-established.`, playerNum);
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    const baseEdgeKey = DEFAULT_FLAG_HOME_POSITIONS[`player${unit.player}`];
                    let playerBaseTiles = [];
                    
                    // --- FIX: Safety check ---
                    if (baseEdgeKey) {
                        playerBaseTiles = [baseEdgeKey.split('_')[0], baseEdgeKey.split('_')[1]];
                    }

                    if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                        unit.supplyLine = findSupplyPath(unit.fortifiedTileKey, unit.player);
                    }
                }
            });
        }

        function attemptToResupplyForts(playerNum) {
            const playerSupplyKey = `player${playerNum}`;
            const unsuppliedForts = gameState.units.filter(u => 
                u.player === playerNum && 
                u.isFortified && 
                u.supplyLine === null
            );

            if (unsuppliedForts.length === 0) return;

            // Find potential supply lines and their costs for all unsupplied forts
            const potentialResupplies = [];
            unsuppliedForts.forEach(unit => {
                const baseEdgeKey = DEFAULT_FLAG_HOME_POSITIONS[playerSupplyKey];
                let playerBaseTiles = [];
                // --- FIX: Safety check ---
                if (baseEdgeKey) {
                    playerBaseTiles = [baseEdgeKey.split('_')[0], baseEdgeKey.split('_')[1]];
                }

                if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                    const supplyPathData = findSupplyPath(unit.fortifiedTileKey, playerNum);
                    if (supplyPathData) {
                        potentialResupplies.push({
                            unit: unit,
                            cost: Math.round(supplyPathData.cost),
                            pathData: supplyPathData
                        });
                    }
                }
            });

            // Prioritize the cheapest supply lines first
            potentialResupplies.sort((a, b) => a.cost - b.cost);

            // Attempt to fund the new supply lines
            potentialResupplies.forEach(resupply => {
                if (gameState.supplyPoints[playerSupplyKey] >= resupply.cost) {
                    gameState.supplyPoints[playerSupplyKey] -= resupply.cost;
                    resupply.unit.supplyLine = resupply.pathData;
                    logAction(`P${playerNum} ${resupply.unit.type.name} is now in supply! (Cost: ${resupply.cost})`, playerNum);
                }
            });
            
            updateSupplyPointsDisplay();
        }

        // --- Action: Fortify / Unfortify ---
function getPotentialUnfortifyTargets(unit) {
    if (!unit || !unit.isFortified || unit.positionType !== 'center') return [];
    const fortifiedTile = gameState.tiles.get(unit.position); if (!fortifiedTile) return [];
    
    const playerHomeFlagEdge = gameState.baseCampPositions[`player${unit.player}`];
    const validTargets = [];

    getNeighbors(fortifiedTile.q, fortifiedTile.r).forEach(neighborCoords => {
        const edgeKey = getEdgeKey(fortifiedTile.q, fortifiedTile.r, neighborCoords.q, neighborCoords.r);
        
        // Prevent unfortifying onto the player's own home flag tile.
        if (edgeKey === playerHomeFlagEdge) {
            return; // Skip this edge, it's not a valid target.
        }

        const edge = gameState.edges.get(edgeKey);
        if (edge && getEdgeCost(unit, edgeKey) !== Infinity) {
             const enemyOnEdge = edge.units.some(u => u.player !== unit.player);
             const friendliesOnEdge = edge.units.filter(u => u.player === unit.player).length;
             if (!enemyOnEdge && friendliesOnEdge < 2) {
                 validTargets.push(edgeKey);
             }
         }
     });
     return validTargets;
}

function completeFortify(unitToFortify, targetTileKeyToFortify) {
    if (!unitToFortify || unitToFortify.hasPerformedMajorAction || unitToFortify.isFortified) { showInstruction("Cannot fortify now.", 2000); return; }
    const targetTileObject = gameState.tiles.get(targetTileKeyToFortify);
    if (!targetTileObject || !targetTileObject.type.canFortify) { showInstruction("Invalid tile to fortify.", 2000); return; }
    if (targetTileObject.fortifiedByPlayer !== null) {
        showInstruction(`Tile ${targetTileKeyToFortify.substring(0,5)}... already fortified.`, 2500);
        resetActionSelectionStates(); 
        updateSelectedUnitInfoPanel(); return;
    }
    
    // --- FIX: Immediately clear move highlights so they don't persist during animation ---
    gameState.currentReachableMoves.clear();

    const animation = {
        type: 'fortify',
        unit: unitToFortify,
        targetTileKey: targetTileKeyToFortify,
        startTime: Date.now(),
        duration: 450,

        onComplete: async () => {
            gameState.playerActionTaken[`player${gameState.currentPlayer}`] = true;
            const fortifyingPlayer = unitToFortify.player;
            
            const currentEdge = gameState.edges.get(unitToFortify.position);
            if (currentEdge) currentEdge.units = currentEdge.units.filter(u => u.id !== unitToFortify.id);
            unitToFortify.isFortified = true; unitToFortify.fortifiedTileKey = targetTileKeyToFortify;
            unitToFortify.positionType = 'center'; unitToFortify.position = targetTileKeyToFortify;
            unitToFortify.currentMove -= FORTIFY_UNFORTIFY_COST; unitToFortify.hasPerformedMajorAction = true;
            targetTileObject.fortifiedByPlayer = fortifyingPlayer;
            logAction(`${unitToFortify.type.name} fortified on tile ${targetTileKeyToFortify.substring(0,5)}...`, fortifyingPlayer, 2500);

            const playerFlag = gameState.flags[`p${fortifyingPlayer}_flag`];
            if (playerFlag && playerFlag.status !== 'carried') {
                // Instead of funding one fort, recalculate the entire player's network
                // to account for shared supply lines.
                recalculatePlayerSupplyNetwork(fortifyingPlayer);

            } else {
                logAction(`P${unitToFortify.player} ${unitToFortify.type.name} fortified, but is unsupplied due to stolen flag.`, fortifyingPlayer, 3000);
            }

            let unitsToDestroy = [];
            getNeighbors(targetTileObject.q, targetTileObject.r).forEach(neighborCoords => {
                 const edgeKey = getEdgeKey(targetTileObject.q, targetTileObject.r, neighborCoords.q, neighborCoords.r);
                 const adjacentEdge = gameState.edges.get(edgeKey);
                 if (adjacentEdge) {
                     adjacentEdge.units.forEach(enemyUnit => {
                         if (enemyUnit.player !== fortifyingPlayer && enemyUnit.positionType === 'edge') {
                             enemyUnit.hp -= FORTIFICATION_DAMAGE;
                             logAction(`P${enemyUnit.player} ${enemyUnit.type.name} takes ZoC. HP: ${enemyUnit.hp}`, fortifyingPlayer);
                             if (enemyUnit.hp <= 0 && !unitsToDestroy.find(u => u.id === enemyUnit.id)) unitsToDestroy.push(enemyUnit);
                         }
                     });
                 }
             });
            unitsToDestroy.forEach(u => handleUnitDeath(u, "zoc_fort"));

            gameState.currentReachableMoves.clear();
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
            if (!gameState.gameOver) checkVictoryCondition();
        }
    };
    
    if (gameSettings.animationsEnabled) {
        gameState.activeAnimations.push(animation);
    } else {
        animation.onComplete();
    }
    
    resetActionSelectionStates(); 
    updateSelectedUnitInfoPanel();
}

        function handleFortifyActionLogic() {
            const { selectedUnit } = gameState;
             if (!selectedUnit || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified || selectedUnit.positionType !== 'edge') { showInstruction("Cannot fortify.", 2000); return; }
            const edgeCoords = parseEdgeKey(selectedUnit.position);
             if (!edgeCoords || edgeCoords.length !== 2 || isNaN(edgeCoords[0].q)) { showInstruction("Unit not on valid edge.", 2000); return; }

            const enemyPlayer = selectedUnit.player === 1 ? 2 : 1;
            const enemyBaseEdgeKey = gameState.baseCampPositions[`player${enemyPlayer}`];
            const [enemy_h1, enemy_h2] = parseEdgeKey(enemyBaseEdgeKey);
            const enemyBaseTileKeys = new Set([getTileKey(enemy_h1.q, enemy_h1.r), getTileKey(enemy_h2.q, enemy_h2.r)]);

            const tile1Key = getTileKey(edgeCoords[0].q, edgeCoords[0].r); 
            const tile2Key = getTileKey(edgeCoords[1].q, edgeCoords[1].r);
            const tile1 = gameState.tiles.get(tile1Key); 
            const tile2 = gameState.tiles.get(tile2Key);
            
            gameState.validFortifyTargetTileKeys = [];
            if (tile1 && tile1.type.canFortify && tile1.fortifiedByPlayer === null && !enemyBaseTileKeys.has(tile1Key)) {
                gameState.validFortifyTargetTileKeys.push(tile1Key);
            }
            if (tile2 && tile2.type.canFortify && tile2.fortifiedByPlayer === null && !enemyBaseTileKeys.has(tile2Key)) {
                gameState.validFortifyTargetTileKeys.push(tile2Key);
            }

            if (gameState.validFortifyTargetTileKeys.length === 0) { showInstruction("No valid adjacent tile to fortify.", 2000); return; }
            
            if (gameState.validFortifyTargetTileKeys.length === 1) {
                // We now pass both the selected unit and the target tile key, as required.
                completeFortify(selectedUnit, gameState.validFortifyTargetTileKeys[0]);
            } else { 
                gameState.currentActionState = ACTION_STATES.SELECTING_FORTIFY_TILE;
                showInstruction("Select tile to fortify.", 3000); 
            }
            updateSelectedUnitInfoPanel();
        }

function completeUnfortify(unitToUnfortify, targetEdgeKey) {
    if (!unitToUnfortify || !unitToUnfortify.isFortified || unitToUnfortify.hasPerformedMajorAction) {
        showInstruction("Cannot unfortify now.", 2000); 
        return; 
    }
    const targetEdge = gameState.edges.get(targetEdgeKey); 
    if (!targetEdge) { 
        showInstruction("Invalid target edge.", 2000); 
        return; 
    }
    if (targetEdge.units.some(u => u.player !== unitToUnfortify.player) || targetEdge.units.filter(u => u.player === unitToUnfortify.player).length >= 2) {
         showInstruction("Target edge blocked.", 2000); 
         resetActionSelectionStates();
         updateSelectedUnitInfoPanel(); 
         return;
    }

    const startTileKey = unitToUnfortify.position;
    const oldFortifiedTile = gameState.tiles.get(startTileKey);
    
    if (oldFortifiedTile) {
        oldFortifiedTile.fortifiedByPlayer = null;
    }
    unitToUnfortify.supplyLine = null;

    const animation = {
        type: 'unfortify',
        unit: unitToUnfortify,
        startTileKey: startTileKey,
        targetEdgeKey: targetEdgeKey,
        startTime: Date.now(),
        duration: 600,

        onComplete: async () => {
            const unfortifyingPlayer = unitToUnfortify.player;
            
            unitToUnfortify.fortifyCooldown = unitToUnfortify.turnsFortified * 5; 

            unitToUnfortify.isFortified = false;
            unitToUnfortify.turnsFortifiedAtBase = 0;
            unitToUnfortify.turnsFortified = 0;      
            unitToUnfortify.supplyLine = null;
            unitToUnfortify.fortifiedTileKey = null;
            unitToUnfortify.positionType = 'edge'; 
            unitToUnfortify.position = targetEdgeKey;
            unitToUnfortify.currentMove -= FORTIFY_UNFORTIFY_COST; 
            unitToUnfortify.hasPerformedMajorAction = true;
            targetEdge.units.push(unitToUnfortify);
            logAction(`${unitToUnfortify.type.name} unfortified to ${targetEdgeKey.substring(0,7)}...`, unfortifyingPlayer, 2500);
            
            recalculatePlayerSupplyNetwork(unfortifyingPlayer);

            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
        }
    };

    if (gameSettings.animationsEnabled) {
        gameState.activeAnimations.push(animation);
    } else {
        animation.onComplete();
    }
    
    resetActionSelectionStates();
    updateSelectedUnitInfoPanel();
}

        function handleUnfortifyActionLogic() {
            const { selectedUnit } = gameState;
            if (!selectedUnit || !selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) { showInstruction("Cannot unfortify.", 2000); return; }
            gameState.validUnfortifyTargetEdgeKeys = getPotentialUnfortifyTargets(selectedUnit);
            if (gameState.validUnfortifyTargetEdgeKeys.length === 0) { showInstruction("No valid edge to unfortify to.", 2500); return; }
            
            gameState.currentActionState = ACTION_STATES.SELECTING_UNFORTIFY_EDGE;
            showInstruction("Select edge to move to.", 3000); 
            updateSelectedUnitInfoPanel();
        }

        function handleFortifyUnfortifyButtonClick() {
            if (gameState.gameMode === 'singleplayer' && gameState.selectedUnit && gameState.selectedUnit.player !== gameState.playerSide) return;
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState; 
            if (!selectedUnit) return;

            if (gameState.currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE || gameState.currentActionState === ACTION_STATES.SELECTING_UNFORTIFY_EDGE) {
                const message = gameState.currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE ? "Fortify cancelled." : "Unfortify cancelled.";
                resetActionSelectionStates();
                showInstruction(message, 1500);
            } else if (selectedUnit.isFortified) {
                handleUnfortifyActionLogic();
            } else {
                handleFortifyActionLogic();
            }
            updateSelectedUnitInfoPanel();
        }

        // --- Action: Build Bridge ---
        function getPotentialBridgeTargets(unit) {
            if (!unit || unit.positionType !== 'edge' || !unit.type.canBuildBridge || unit.isFortified) return [];

            const validTargets = new Set();
            
            // 1. Check if the unit's CURRENT edge is a valid target
            const currentEdge = gameState.edges.get(unit.position);
            if (currentEdge && !currentEdge.bridge) {
                const [h1, h2] = parseEdgeKey(unit.position);
                const tile1 = gameState.tiles.get(getTileKey(h1.q, h1.r));
                const tile2 = gameState.tiles.get(getTileKey(h2.q, h2.r));
                if (tile1 && tile2) {
                    const isBeachEdge = (tile1.type === TILE_TYPES.WATER && tile2.type !== TILE_TYPES.WATER) || 
                                      (tile2.type === TILE_TYPES.WATER && tile1.type !== TILE_TYPES.WATER);
                    if (isBeachEdge) {
                        validTargets.add(unit.position);
                    }
                }
            }

            // 2. Check all ADJACENT edges (original logic)
            const rotationallyAdjacentEdges = getRotationallyAdjacentEdges(unit.position);
            rotationallyAdjacentEdges.forEach(adjEdgeKey => {
                if (adjEdgeKey === unit.position) return;
                const edgeData = gameState.edges.get(adjEdgeKey);
                if (edgeData && !edgeData.bridge) {
                    const adjEdgeTileCoords = parseEdgeKey(adjEdgeKey);
                    if (adjEdgeTileCoords.some(coord => isNaN(coord.q))) return;

                    const t1 = gameState.tiles.get(getTileKey(adjEdgeTileCoords[0].q, adjEdgeTileCoords[0].r));
                    const t2 = gameState.tiles.get(getTileKey(adjEdgeTileCoords[1].q, adjEdgeTileCoords[1].r));

                    // An adjacent edge is a target if it's next to water (either beach or full water edge)
                    if ((t1 && t1.type === TILE_TYPES.WATER) || (t2 && t2.type === TILE_TYPES.WATER)) {
                        validTargets.add(adjEdgeKey);
                    }
                }
            });

            return Array.from(validTargets);
        }


        function handleBuildBridgeAction() {
            if (gameState.gameMode === 'singleplayer' && gameState.selectedUnit && gameState.selectedUnit.player !== gameState.playerSide) return;
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState;

            if (gameState.currentActionState === ACTION_STATES.SELECTING_BRIDGE_EDGE) {
                resetActionSelectionStates();
                showInstruction("Bridge selection cancelled.", 1500);
                updateSelectedUnitInfoPanel(); 
                return;
            }
            if (!selectedUnit || !selectedUnit.type.canBuildBridge || selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) {
                showInstruction(selectedUnit && selectedUnit.hasPerformedMajorAction ? "Unit acted." : "Cannot build bridge.", 2000); 
                return;
            }
            gameState.validBridgeTargetEdgeKeys = getPotentialBridgeTargets(selectedUnit);
            if (gameState.validBridgeTargetEdgeKeys.length === 0) {
                showInstruction("No valid water edge for bridge.", 2000);
            } else { 
                gameState.currentActionState = ACTION_STATES.SELECTING_BRIDGE_EDGE;
                showInstruction("Select water edge for bridge.", 3000); 
            }
            updateSelectedUnitInfoPanel();
        }

function completeBuildBridge(targetEdgeKey) {
    const { selectedUnit } = gameState;
    if (!selectedUnit || !selectedUnit.type.canBuildBridge || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified) {
         showInstruction("Cannot build bridge.", 2000); 
         resetActionSelectionStates();
         updateSelectedUnitInfoPanel(); 
         return;
    }
    const edgeToBridge = gameState.edges.get(targetEdgeKey);
    if (!edgeToBridge || edgeToBridge.bridge) {
        showInstruction("Cannot build bridge here.", 2000); 
        resetActionSelectionStates();
        updateSelectedUnitInfoPanel(); 
        return;
    }

    selectedUnit.currentMove -= BUILD_BRIDGE_COST; 
    selectedUnit.hasPerformedMajorAction = true;
    gameState.currentReachableMoves.clear(); // Immediately remove move highlights

    const animation = {
        type: 'build_bridge',
        unit: selectedUnit,
        targetEdgeKey: targetEdgeKey,
        startTime: Date.now(),
        duration: 500,

        onComplete: () => {
            // These actions happen AFTER the animation finishes
            edgeToBridge.bridge = true; 
            edgeToBridge.bridgeHp = BRIDGE_MAX_HP;
            logAction(`${selectedUnit.type.name} built bridge on ${targetEdgeKey.substring(0,7)}... HP: ${edgeToBridge.bridgeHp}`, gameState.currentPlayer, 3000);
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
        }
    };
    
    if (gameSettings.animationsEnabled) {
        gameState.activeAnimations.push(animation);
    } else {
        animation.onComplete();
    }
    
    resetActionSelectionStates();
    updateSelectedUnitInfoPanel();
}

        // --- Action: Movement & Fortification Damage ---
        function applyFortificationDamageOnMove(unitMoving, newEdgeKey) {
             if (!unitMoving || unitMoving.isFortified || unitMoving.positionType !== 'edge') return false;
            const tileCoords = parseEdgeKey(newEdgeKey); 
            if (tileCoords.some(coord => isNaN(coord.q))) return false;
            let unitDestroyed = false; const enemyPlayer = unitMoving.player === 1 ? 2 : 1;
            const checkAndApply = (tile) => {
                if (tile && tile.fortifiedByPlayer === enemyPlayer && !unitDestroyed) {
                    unitMoving.hp -= FORTIFICATION_DAMAGE;
                    logAction(`P${unitMoving.player} ${unitMoving.type.name} takes ZoC. HP: ${unitMoving.hp}`, gameState.currentPlayer, 3500);
                    if (unitMoving.hp <= 0) { handleUnitDeath(unitMoving, "zoc_move"); unitDestroyed = true; }
                    return true;
                } return false;
            };
            const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
            const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
            checkAndApply(tile1); checkAndApply(tile2);
            return unitDestroyed;
        }


        // --- Action: Attack (Melee & Archer) ---
        function getPotentialMeleeAttackEdges(attackingUnit) {
            const potentialEdges = new Set();
            if (!attackingUnit) return Array.from(potentialEdges);

            if (attackingUnit.isFortified && attackingUnit.positionType === 'center') {
                const fortifiedTile = gameState.tiles.get(attackingUnit.position);
                if (!fortifiedTile) return Array.from(potentialEdges);
                getNeighbors(fortifiedTile.q, fortifiedTile.r).forEach(neighborCoords => {
                    if (gameState.tiles.has(getTileKey(neighborCoords.q, neighborCoords.r))) {
                        const edgeKey = getEdgeKey(fortifiedTile.q, fortifiedTile.r, neighborCoords.q, neighborCoords.r);
                        potentialEdges.add(edgeKey);
                    }
                });
            } else if (attackingUnit.positionType === 'edge') {
                return getRotationallyAdjacentEdges(attackingUnit.position);
            }
            return Array.from(potentialEdges);
        }

        function getPotentialArcherAttackEdges(attackingUnit) {
            const potentialEdges = new Set();
            if (!attackingUnit || attackingUnit.type.name !== 'Archer') return Array.from(potentialEdges);

            if (attackingUnit.isFortified && attackingUnit.positionType === 'center') {
                const attackerTileKey = attackingUnit.position;
                const attackerTile = gameState.tiles.get(attackerTileKey);
                if (!attackerTile) return Array.from(potentialEdges);
                getNeighbors(attackerTile.q, attackerTile.r).forEach(neighborCoords => {
                    const neighborKey = getTileKey(neighborCoords.q, neighborCoords.r);
                    if (gameState.tiles.has(neighborKey)) {
                        potentialEdges.add(getEdgeKey(attackerTile.q, attackerTile.r, neighborCoords.q, neighborCoords.r));
                    }
                });
            } else if (attackingUnit.positionType === 'edge') {
                const currentUnitEdgeKey = attackingUnit.position;
                const [H1_coords, H2_coords] = parseEdgeKey(currentUnitEdgeKey);
                if (isNaN(H1_coords.q) || isNaN(H2_coords.q)) return Array.from(potentialEdges);

                const processHex = (hexCoords) => {
                    if (gameState.tiles.has(getTileKey(hexCoords.q, hexCoords.r))) {
                        getNeighbors(hexCoords.q, hexCoords.r).forEach(neighbor_coords => {
                            if (gameState.tiles.has(getTileKey(neighbor_coords.q, neighbor_coords.r))) {
                                const edgeToAdd = getEdgeKey(hexCoords.q, hexCoords.r, neighbor_coords.q, neighbor_coords.r);
                                potentialEdges.add(edgeToAdd); 
                            }
                        });
                    }
                };
                processHex(H1_coords);
                processHex(H2_coords);
            }
            return Array.from(potentialEdges);
        }

        function getValidMeleeAttackTargets(attackingUnit) {
            if (!attackingUnit || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction) return [];
            const targets = [];
            const addUnitTarget = (targetUnit, edgeKey = null, tileKeyForTarget = null) => {
                if (!targets.some(t => t.unit && t.unit.id === targetUnit.id)) targets.push({ unit: targetUnit, edgeKey, tileKeyForTarget, isBridgeTarget: false });
            };
            const addBridgeTarget = (edgeKey) => {
                 if (!targets.some(t => t.isBridgeTarget && t.edgeKey === edgeKey)) targets.push({ unit: null, edgeKey, tileKeyForTarget: null, isBridgeTarget: true });
            }
            
            const potentialAttackEdges = getPotentialMeleeAttackEdges(attackingUnit);

            potentialAttackEdges.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    edge.units.forEach(unitOnEdge => { 
                        if (unitOnEdge.player !== attackingUnit.player && unitOnEdge.positionType === 'edge') {
                            addUnitTarget(unitOnEdge, edgeKey); 
                        }
                    });
                     if (edge.bridge && edge.bridgeHp > 0) addBridgeTarget(edgeKey);
                }
            });
            
            if (attackingUnit.positionType === 'edge') { 
                const [H1_coords, H2_coords] = parseEdgeKey(attackingUnit.position);
                [H1_coords, H2_coords].forEach(hexCoords => { 
                     if (isNaN(hexCoords.q)) return;
                    const tileKey = getTileKey(hexCoords.q, hexCoords.r);
                    const tile = gameState.tiles.get(tileKey);
                    if (tile && tile.fortifiedByPlayer && tile.fortifiedByPlayer !== attackingUnit.player) {
                        const fortifiedUnit = gameState.units.find(u => u.isFortified && u.position === tileKey && u.player === tile.fortifiedByPlayer);
                        if (fortifiedUnit) {
                            addUnitTarget(fortifiedUnit, null, tileKey);
                        }
                    }
                });
            }
            return targets;
        }

        function canArcherOnEdgeSeeEdge(archerEdgeKey, targetEdgeKey, archerTile1, archerTile2) {
            let blockedByTile1 = false;
            if (archerTile1.type === TILE_TYPES.MOUNTAIN) {
                if (isEdgePartOfTile(archerTile1.q, archerTile1.r, targetEdgeKey) && targetEdgeKey !== archerEdgeKey) {
                    blockedByTile1 = true;
                }
            } else if (archerTile1.type === TILE_TYPES.FOREST) {
                if (isEdgePartOfTile(archerTile1.q, archerTile1.r, targetEdgeKey) &&
                    targetEdgeKey !== archerEdgeKey &&
                    !isEdgeRotationallyAdjacentToEdgeOnTile(archerTile1.q, archerTile1.r, archerEdgeKey, targetEdgeKey)) {
                    blockedByTile1 = true;
                }
            }

            let blockedByTile2 = false;
            if (archerTile2.type === TILE_TYPES.MOUNTAIN) {
                if (isEdgePartOfTile(archerTile2.q, archerTile2.r, targetEdgeKey) && targetEdgeKey !== archerEdgeKey) {
                    blockedByTile2 = true;
                }
            } else if (archerTile2.type === TILE_TYPES.FOREST) {
                if (isEdgePartOfTile(archerTile2.q, archerTile2.r, targetEdgeKey) &&
                    targetEdgeKey !== archerEdgeKey &&
                    !isEdgeRotationallyAdjacentToEdgeOnTile(archerTile2.q, archerTile2.r, archerEdgeKey, targetEdgeKey)) {
                    blockedByTile2 = true;
                }
            }
            return !blockedByTile1 && !blockedByTile2;
        }
        
        function canArcherOnEdgeSeeFortified(archerEdgeKey, targetFortifiedTileKey, archerTile1, archerTile2) {
            const targetFortifiedTile = gameState.tiles.get(targetFortifiedTileKey);
            if (!targetFortifiedTile) return false;

            let obstructed = false;
            if (archerTile1.type === TILE_TYPES.FOREST) {
                const connectingEdgeKey = getEdgeKey(archerTile1.q, archerTile1.r, targetFortifiedTile.q, targetFortifiedTile.r);
                if (gameState.edges.has(connectingEdgeKey)) { 
                    if (!isEdgeRotationallyAdjacentToEdgeOnTile(archerTile1.q, archerTile1.r, archerEdgeKey, connectingEdgeKey)) {
                        obstructed = true; 
                    }
                }
            }

            if (!obstructed && archerTile2.type === TILE_TYPES.FOREST) {
                const connectingEdgeKey = getEdgeKey(archerTile2.q, archerTile2.r, targetFortifiedTile.q, targetFortifiedTile.r);
                 if (gameState.edges.has(connectingEdgeKey)) { 
                    if (!isEdgeRotationallyAdjacentToEdgeOnTile(archerTile2.q, archerTile2.r, archerEdgeKey, connectingEdgeKey)) {
                        obstructed = true;
                    }
                }
            }
            if (obstructed) return false;

            const [archerH1_coords, archerH2_coords] = parseEdgeKey(archerEdgeKey);
            
            let isRotationallyValid = false;
            const connectingEdge1_key = getEdgeKey(archerH1_coords.q, archerH1_coords.r, targetFortifiedTile.q, targetFortifiedTile.r);
            if (gameState.edges.has(connectingEdge1_key)) { 
                if (isEdgeRotationallyAdjacentToEdgeOnTile(archerH1_coords.q, archerH1_coords.r, archerEdgeKey, connectingEdge1_key)) {
                    isRotationallyValid = true;
                }
            }
            
            if (!isRotationallyValid) { 
                const connectingEdge2_key = getEdgeKey(archerH2_coords.q, archerH2_coords.r, targetFortifiedTile.q, targetFortifiedTile.r);
                 if (gameState.edges.has(connectingEdge2_key)) { 
                    if (isEdgeRotationallyAdjacentToEdgeOnTile(archerH2_coords.q, archerH2_coords.r, archerEdgeKey, connectingEdge2_key)) {
                        isRotationallyValid = true;
                    }
                }
            }
            
            return isRotationallyValid;
        }

        function canFortifiedArcherSee(attackingUnit, targetInfo) {
            const archerFortTileKey = attackingUnit.position;
            const archerFortTile = gameState.tiles.get(archerFortTileKey);
            if (!archerFortTile) return false;

            if (archerFortTile.type === TILE_TYPES.FOREST) {
                if (targetInfo.isBridgeTarget || (targetInfo.unit && !targetInfo.unit.isFortified)) {
                    return isEdgePartOfTile(archerFortTile.q, archerFortTile.r, targetInfo.edgeKey);
                } else if (targetInfo.unit.isFortified) {
                    const targetTileKey = targetInfo.tileKeyForTarget;
                    const targetTile = gameState.tiles.get(targetTileKey);
                    if (!targetTile) return false;
                    const isAdjacent = axialDistance(archerFortTile.q, archerFortTile.r, targetTile.q, targetTile.r) === 1;
                    return isAdjacent && targetTile.type !== TILE_TYPES.FOREST;
                }
            }

            if (targetInfo.unit && targetInfo.unit.isFortified) {
                const targetTile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                if (targetTile && targetTile.type === TILE_TYPES.FOREST) {
                    return false;
                }
            }
            return true;
        }

        function canEdgeArcherSee(attackingUnit, targetInfo) {
            const archerEdgeKey = attackingUnit.position;
            const [archerH1, archerH2] = parseEdgeKey(archerEdgeKey);
            const archerTile1 = gameState.tiles.get(getTileKey(archerH1.q, archerH1.r));
            const archerTile2 = gameState.tiles.get(getTileKey(archerH2.q, archerH2.r));
            if (!archerTile1 || !archerTile2) return false;

            if (targetInfo.isBridgeTarget || (targetInfo.unit && !targetInfo.unit.isFortified)) {
                return canArcherOnEdgeSeeEdge(archerEdgeKey, targetInfo.edgeKey, archerTile1, archerTile2);
            }
            
            if (targetInfo.unit && targetInfo.unit.isFortified) {
                const targetTileKey = targetInfo.tileKeyForTarget;
                const targetTile = gameState.tiles.get(targetTileKey);
                if (!targetTile) return false;

                if (targetTile.type === TILE_TYPES.FOREST) {
                    if (!isEdgePartOfTile(targetTile.q, targetTile.r, archerEdgeKey)) {
                        return false; 
                    }
                }
                
                const isImmediatelyAdjacentFort = (targetTileKey === getTileKey(archerH1.q, archerH1.r) || targetTileKey === getTileKey(archerH2.q, archerH2.r));
                if (isImmediatelyAdjacentFort) {
                    const archerEdge = gameState.edges.get(archerEdgeKey);
                    const hasMeleeSpotter = archerEdge.units.some(u => u.player === attackingUnit.player && u.type.name === 'Melee');
                    return hasMeleeSpotter;
                } else {
                    return canArcherOnEdgeSeeFortified(archerEdgeKey, targetTileKey, archerTile1, archerTile2);
                }
            }
            
            return false;
        }

        function getValidArcherAttackTargets(attackingUnit) {
            if (!attackingUnit || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction || attackingUnit.type.name !== 'Archer') {
                return [];
            }

            const potentialAttackEdges = getPotentialArcherAttackEdges(attackingUnit);
            const potentialTargetableTiles = new Set();
            potentialAttackEdges.forEach(edgeKey => {
                const [c1, c2] = parseEdgeKey(edgeKey);
                if (!isNaN(c1.q)) potentialTargetableTiles.add(getTileKey(c1.q, c1.r));
                if (!isNaN(c2.q)) potentialTargetableTiles.add(getTileKey(c2.q, c2.r));
            });

            const potentialTargets = [];
            const addPotentialUnit = (unit, edgeKey = null, tileKey = null) => {
                if (!potentialTargets.some(t => t.unit && t.unit.id === unit.id)) {
                    potentialTargets.push({ unit: unit, edgeKey: edgeKey, tileKeyForTarget: tileKey, isBridgeTarget: false });
                }
            };
            const addPotentialBridge = (edgeKey) => {
                if (!potentialTargets.some(t => t.isBridgeTarget && t.edgeKey === edgeKey)) {
                    potentialTargets.push({ unit: null, edgeKey: edgeKey, tileKeyForTarget: null, isBridgeTarget: true });
                }
            };

            potentialAttackEdges.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    edge.units.forEach(unit => {
                        if (unit.player !== attackingUnit.player) {
                            addPotentialUnit(unit, edgeKey, null);
                        }
                    });
                    if (edge.bridge && edge.bridgeHp > 0) {
                        addPotentialBridge(edgeKey);
                    }
                }
            });
            potentialTargetableTiles.forEach(tileKey => {
                const tile = gameState.tiles.get(tileKey);
                if (tile && tile.fortifiedByPlayer && tile.fortifiedByPlayer !== attackingUnit.player) {
                    const fortifiedUnit = gameState.units.find(u => u.isFortified && u.position === tileKey);
                    if (fortifiedUnit) {
                        addPotentialUnit(fortifiedUnit, null, tileKey);
                    }
                }
            });
            
            return potentialTargets.filter(targetInfo => {
                if (attackingUnit.isFortified) {
                    return canFortifiedArcherSee(attackingUnit, targetInfo);
                } else { 
                    return canEdgeArcherSee(attackingUnit, targetInfo);
                }
            });
        }


        function handleAttackAction() {
            if (gameState.gameMode === 'singleplayer' && gameState.selectedUnit && gameState.selectedUnit.player !== gameState.playerSide) return;
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState;
            
            if (gameState.currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET) {
                 resetActionSelectionStates(); 
                 showInstruction("Attack cancelled.", 1500); 
                 updateSelectedUnitInfoPanel(); 
                 return;
            }

             if (!selectedUnit || selectedUnit.currentMove < ATTACK_COST || selectedUnit.hasPerformedMajorAction) {
                showInstruction(selectedUnit && selectedUnit.hasPerformedMajorAction ? "Unit acted." : "Cannot attack.", 2500); return;
            }

            gameState.debugAttackRangeHighlights = []; 

            if (selectedUnit.type.attackType === 'melee') {
                gameState.validMeleeAttackTargets = getValidMeleeAttackTargets(selectedUnit);
                gameState.debugAttackRangeHighlights = gameState.validMeleeAttackTargets
                    .filter(t => t.edgeKey && !t.isBridgeTarget)
                    .map(t => t.edgeKey);

                if (gameState.validMeleeAttackTargets.length === 0) {
                    showInstruction("No valid melee targets.", 2000);
                } else {
                    gameState.currentActionState = ACTION_STATES.SELECTING_ATTACK_TARGET;
                    showInstruction("Select target to attack.", 3000);
                }
            } else if (selectedUnit.type.attackType === 'ranged') {
                gameState.validArcherAttackTargets = getValidArcherAttackTargets(selectedUnit);
                gameState.debugAttackRangeHighlights = gameState.validArcherAttackTargets
                    .filter(t => t.edgeKey && !t.isBridgeTarget)
                    .map(t => t.edgeKey);

                if (gameState.validArcherAttackTargets.length === 0) {
                    showInstruction("No valid archer targets.", 2000);
                } else {
                    gameState.currentActionState = ACTION_STATES.SELECTING_ATTACK_TARGET;
                    showInstruction("Select target to attack.", 3000);
                }
            }
            updateSelectedUnitInfoPanel();
        }

        function getActionIcon(message) {
            let iconSvg = '';
            const iconColor = '#bdc3c7';

            if (message.includes('hits') || message.includes('takes') || message.includes('targets bridge') || message.includes('retaliates')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15.2 3.8-3.5 3.5 4.3 4.3 3.5-3.5-4.3-4.3z"/><path d="m4.1 19.9 4.4-4.4"/><path d="M16 16h3v3"/><path d="M10.1 5.5 3 12.6l-1.4 1.4 4.2 4.2 1.4-1.4 7.1-7.1"/><path d="M12.6 3 3 12.6l4.2 4.2 9.6-9.6L12.6 3z"/></svg>`;
            } else if (message.includes('fortified')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>`;
            } else if (message.includes('unfortified')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;
            } else if (message.includes('healed') || message.includes('gained a shield')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>`;
            } else if (message.includes('destroyed')) {
                 iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="12" r="1"></circle><circle cx="15" cy="12" r="1"></circle><path d="M8 20v2h8v-2"></path><path d="m12.5 17.5-1-1-1 1"></path><path d="M16 20a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2"></path><path d="M16 20a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2"></path><path d="M15 2h-1.5a1.5 1.5 0 0 0 0 3h1.5a1.5 1.5 0 0 0 0-3Z"></path><path d="M9 2H7.5a1.5 1.5 0 0 0 0 3H9a1.5 1.5 0 0 0 0-3Z"></path></svg>`;
            } else if (message.includes('built bridge')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 8v8m20-8v8M8 4v2m8-2v2M4 12h16"/><path d="M8 10v4m8-4v4"/></svg>`;
            } else {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="m9 12 2 2 4-4"/></svg>`;
            }
            return `<div class="log-icon">${iconSvg}</div>`;
        }

        function updateActionLogDisplay() {
            if (!ui.actionLogContent) return;

            ui.actionLogContent.innerHTML = '';
            
            for (let i = gameState.actionLog.length - 1; i >= 0; i--) {
                const logObject = gameState.actionLog[i];

                const originalMessage = logObject.message;
                const activePlayer = logObject.player;

                let formattedMessage = originalMessage.replace(/<br>/g, ' ');

                formattedMessage = formattedMessage.replace(/(P1)/g, '<strong class="p1-log">$1</strong>');
                formattedMessage = formattedMessage.replace(/(P2)/g, '<strong class="p2-log">$1</strong>');
                formattedMessage = formattedMessage.replace(/(\d+)\s(damage|HP)/g, '<strong class="damage-text">$1</strong> $2');
                formattedMessage = formattedMessage.replace(/(healed\s\d+\sHP)/g, '<span class="heal-text">$1</span>');
                formattedMessage = formattedMessage.replace(/(gained a shield)/g, '<span class="shield-text">$1</span>');
                formattedMessage = formattedMessage.replace(/(Advantage!)/g, '<strong class="advantage-text">$1</strong>');
                formattedMessage = formattedMessage.replace(/(Disadvantage!)/g, '<strong class="disadvantage-text">$1</strong>');
                formattedMessage = formattedMessage.replace(/(Spear Wall|Cavalry Screen|Combined arms|Damage split)/g, '<strong class="keyword-text">$1</strong>');

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-p${activePlayer}`; 
                logEntry.innerHTML = getActionIcon(originalMessage) + `<div class="log-message">${formattedMessage}</div>`;

                ui.actionLogContent.appendChild(logEntry);
            }
        }

function updateSupplyPointsDisplay() {
    const container = document.getElementById('supplyPointsContainer');
    if (!container) return;

    // Rebuild the inner HTML to switch between "Supply" and "Health" labels
    // while keeping the IDs (p1Supply, p2Supply) for the color system to target.
    if (gameState.gameMode === 'arcade') {
        // Calculate Total HP for Arcade Mode
        const p1HP = gameState.units.filter(u => u.player === 1).reduce((sum, u) => sum + u.hp, 0);
        const p2HP = gameState.units.filter(u => u.player === 2).reduce((sum, u) => sum + u.hp, 0);
        
        container.innerHTML = `
            <span>P1 Health: <span id="p1Supply">${p1HP}</span></span> | 
            <span>P2 Health: <span id="p2Supply">${p2HP}</span></span>
        `;
    } else {
        // Standard Mode uses Supply Points
        container.innerHTML = `
            <span>P1 Supply: <span id="p1Supply">${gameState.supplyPoints.player1}</span></span> | 
            <span>P2 Supply: <span id="p2Supply">${gameState.supplyPoints.player2}</span></span>
        `;
    }
}

function updateSupplyPointsBasedOnFlagStatus(playerNum) {
    const playerFlag = gameState.flags[`p${playerNum}_flag`];
    const playerSupplyKey = `player${playerNum}`;

    if (playerFlag && playerFlag.status === 'carried') {
        // Flag is stolen, set supply to 0.
        gameState.supplyPoints[playerSupplyKey] = 0;
    } else {
        // Flag is at base, restore to max.
        gameState.supplyPoints[playerSupplyKey] = 10;
    }
    updateSupplyPointsDisplay();
}

function completeAttack(attackingUnit, targetUnitInfo, attackType) {
    if (!attackingUnit || !targetUnitInfo || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction) {
        showInstruction("Cannot complete attack.", 2000);
        resetActionSelectionStates();
        updateSelectedUnitInfoPanel();
        return;
    }

    let damageModifier = 0;
    let advantageMessage = "";
    let baseDamage = attackingUnit.type.attack;

    if (targetUnitInfo.unit) {
        const attackerType = attackingUnit.type;
        const defenderType = targetUnitInfo.unit.type;
        if (attackerType.strengths && attackerType.strengths.includes(defenderType.name)) {
            damageModifier = 1;
            advantageMessage = "Advantage!";
        } else if (attackerType.weaknesses && attackerType.weaknesses.includes(defenderType.name)) {
            damageModifier = -1;
            advantageMessage = "Disadvantage!";
        }
    }
    baseDamage += damageModifier;

    let fortifiedArcherMsg = "";
    if (attackType === 'Archer' && attackingUnit.isFortified) {
        baseDamage += 1;
        fortifiedArcherMsg = `Fortified Archer +1 Attack.`;
    }

    let attackStatus = 'normal';
    if (advantageMessage === "Advantage!") {
        attackStatus = 'advantage';
    } else if (advantageMessage === "Disadvantage!") {
        attackStatus = 'disadvantage';
    }

    const animation = {
        attacker: attackingUnit,
        targetInfo: targetUnitInfo,
        startTime: Date.now(),

        onComplete: async () => {
            gameState.playerActionTaken[`player${gameState.currentPlayer}`] = true;
            attackingUnit.hasPerformedMajorAction = true;
            let hitAndRunMessage = "";
            if (attackingUnit.type.canMoveAfterAttack) {
                attackingUnit.currentMove -= ATTACK_COST;
                const spearWallOnAttacker = isEdgeAdjacentToSpearWall(attackingUnit, attackingUnit.position);
                const spearWallOnTarget = targetUnitInfo.edgeKey ? isEdgeAdjacentToSpearWall(attackingUnit, targetUnitInfo.edgeKey) : false;
                if (spearWallOnAttacker || spearWallOnTarget) {
                    hitAndRunMessage = "Spear Wall prevents further movement!";
                    gameState.currentReachableMoves.clear();
                } else if (attackingUnit.currentMove > 0) {
                    hitAndRunMessage = "Horseman can move again!";
                    if (gameState.gameMode !== 'singleplayer' || attackingUnit.player === gameState.playerSide) {
                        gameState.currentReachableMoves = getPossibleMoves(attackingUnit);
                    }
                } else {
                    gameState.currentReachableMoves.clear();
                }
            } else {
                attackingUnit.currentMove = 0;
                gameState.currentReachableMoves.clear();
            }

            let logParts = [];
            if (fortifiedArcherMsg) logParts.push(fortifiedArcherMsg);
            if (advantageMessage) logParts.push(advantageMessage);

            if (targetUnitInfo.isBridgeTarget && targetUnitInfo.edgeKey) {
                const bridgeEdge = gameState.edges.get(targetUnitInfo.edgeKey);
                if (bridgeEdge && bridgeEdge.bridge) {
                    bridgeEdge.bridgeHp -= baseDamage;
                    triggerDamageVisual({
                        position: targetUnitInfo.edgeKey,
                        isFortified: false
                    }, 'normal');
                    logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} targets bridge for ${baseDamage}.<br>Bridge HP: ${bridgeEdge.bridgeHp}/${BRIDGE_MAX_HP}.`);
                    if (bridgeEdge.bridgeHp <= 0) {
                        logParts.push(`Bridge destroyed!`);
                        bridgeEdge.bridge = false;
                        bridgeEdge.bridgeHp = null;

                        recalculatePlayerSupplyNetwork(1);
                        recalculatePlayerSupplyNetwork(2);

                        // If the attacker was a Horseman, recalculate its moves now that the bridge is gone.
                        if (attackingUnit.type.name === 'Horseman') {
                            gameState.currentReachableMoves = getPossibleMoves(attackingUnit);
                        }

                        const [h1, h2] = parseEdgeKey(targetUnitInfo.edgeKey);
                        const tile1 = gameState.tiles.get(getTileKey(h1.q, h1.r));
                        const tile2 = gameState.tiles.get(getTileKey(h2.q, h2.r));

                        const isBeach = (tile1 && tile1.type !== TILE_TYPES.WATER) || (tile2 && tile2.type !== TILE_TYPES.WATER);

                        [...bridgeEdge.units].forEach(unitOnCollapse => {
                            if (isBeach) {
                                // On a beach, take 3 damage instead of dying
                                const fallDamage = 3;
                                unitOnCollapse.hp -= fallDamage;
                                logParts.push(`P${unitOnCollapse.player} ${unitOnCollapse.type.name} fell as the bridge collapsed and takes ${fallDamage} damage! HP: ${unitOnCollapse.hp}`);
                                if (unitOnCollapse.hp <= 0) {
                                    handleUnitDeath(unitOnCollapse, "bridge_collapse");
                                }
                            } else {
                                // On a Water-Water edge, the unit is instantly destroyed
                                handleUnitDeath(unitOnCollapse, "bridge_collapse");
                            }
                        });
                    }
                } else logParts.push("Target bridge missing.");
            } else if (targetUnitInfo.unit) {
                const targetUnit = targetUnitInfo.unit;
                if (attackingUnit.player !== targetUnit.player) {
                    targetUnit.lastAttackedByHostileOnTurn = gameState.globalTurnNumber;
                }
                let actualDamage = baseDamage;
                let defenseMessage = "";
                let pierceMessage = "";

                if (targetUnit.isFortified) {
                    let hasCombinedArmsPartner = false;
                    const edge = gameState.edges.get(attackingUnit.position);
                    if (edge) {
                        if (attackingUnit.type.attackType === 'ranged') hasCombinedArmsPartner = edge.units.some(u => u.id !== attackingUnit.id && u.player === attackingUnit.player && u.type.attackType === 'melee');
                        else if (attackingUnit.type.attackType === 'melee') hasCombinedArmsPartner = edge.units.some(u => u.id !== attackingUnit.id && u.player === attackingUnit.player && u.type.attackType === 'ranged');
                    }
                    if (hasCombinedArmsPartner) {
                        defenseMessage = 'Combined arms negates fortification!';
                    } else {
                        const defenseBonus = targetUnit.type.fortificationBonus || 1;
                        const pierceValue = attackingUnit.type.defenseNegation || 0;
                        if (pierceValue > 0) pierceMessage = `${attackingUnit.type.name} pierces ${pierceValue} defense.`;
                        const effectiveDefense = Math.max(0, defenseBonus - pierceValue);
                        actualDamage = Math.max(0, baseDamage - effectiveDefense);
                        if (effectiveDefense > 0) defenseMessage = `Fortification reduced damage by ${effectiveDefense}.`;
                    }
                }
                if (pierceMessage) logParts.push(pierceMessage);
                if (defenseMessage) logParts.push(defenseMessage);

                triggerDamageVisual(targetUnit, attackStatus);

                if (attackType === 'Archer' && targetUnitInfo.edgeKey && actualDamage > 0 && !targetUnit.isFortified) {
                    const edgeOfTarget = gameState.edges.get(targetUnitInfo.edgeKey);
                    const allEnemyUnitsOnEdge = edgeOfTarget ? edgeOfTarget.units.filter(u => u.player === targetUnit.player) : [];
                    if (allEnemyUnitsOnEdge.length === 2) {
                        let splitDamage = Math.max(1, Math.round(actualDamage / 2));
                        logParts.push(`Damage split between 2 units!`);
                        allEnemyUnitsOnEdge.forEach(unitToHit => {
                            unitToHit.hp -= splitDamage;
                            triggerDamageVisual(unitToHit, attackStatus);
                            logParts.push(`P${unitToHit.player} ${unitToHit.type.name} takes ${splitDamage} damage. HP: ${unitToHit.hp}`);
                            if (attackingUnit.player !== unitToHit.player) unitToHit.lastAttackedByHostileOnTurn = gameState.globalTurnNumber;
                            if (unitToHit.hp <= 0) handleUnitDeath(unitToHit);
                        });
                    } else {
                        targetUnit.hp -= actualDamage;
                        logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} hits P${targetUnit.player} ${targetUnit.type.name} for ${actualDamage}.<br>HP: ${targetUnit.hp}/${targetUnit.maxHp}`);
                        if (targetUnit.hp <= 0) handleUnitDeath(targetUnit);
                    }
                } else {
                    targetUnit.hp -= actualDamage;
                    logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} hits P${targetUnit.player} ${targetUnit.type.name} for ${actualDamage}.<br>HP: ${targetUnit.hp}/${targetUnit.maxHp}`);
                    if (targetUnit.hp <= 0) handleUnitDeath(targetUnit);
                }

                if (targetUnit.type.name === 'Horseman' && attackingUnit.type.attackType === 'melee' && targetUnitInfo.edgeKey) {
                    const edgeOfHorseman = gameState.edges.get(targetUnitInfo.edgeKey);
                    const retaliatingArcher = edgeOfHorseman ? edgeOfHorseman.units.find(u => u.player === targetUnit.player && u.type.name === 'Archer') : null;
                    if (retaliatingArcher) {
                        const retaliationDamage = Math.ceil(retaliatingArcher.type.attack / 2);
                        attackingUnit.hp -= retaliationDamage;
                        triggerDamageVisual(attackingUnit, 'normal');
                        logParts.push(`Cavalry Screen! P${retaliatingArcher.player} ${retaliatingArcher.type.name} retaliates for ${retaliationDamage} damage.<br>Attacker HP: ${attackingUnit.hp}/${attackingUnit.maxHp}`);
                        if (attackingUnit.hp <= 0) handleUnitDeath(attackingUnit, "retaliation");
                    }
                }
            }
            if (hitAndRunMessage) logParts.push(hitAndRunMessage);

            logAction(logParts.join('<br>'), gameState.currentPlayer, 4500);

            // CRITICAL FIX: Update HP display after attack damage
            updateSupplyPointsDisplay();

            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
            if (!gameState.gameOver) checkVictoryCondition();
        }
    };

    if (gameSettings.animationsEnabled) {
        if (targetUnitInfo.isBridgeTarget) {
            // Simplified animation logic for bridge targets
            const bridgeEdge = gameState.edges.get(targetUnitInfo.edgeKey);
            if (bridgeEdge) {
                const targetPos = getEdgeMidpoint(bridgeEdge.q1, bridgeEdge.r1, bridgeEdge.q2, bridgeEdge.r2);

                // Create a temporary "dummy" target unit at the bridge's location for the animation system
                const dummyTarget = {
                    isFortified: false,
                    position: targetUnitInfo.edgeKey,
                    // A getUnitScreenPosition function that just returns the bridge center
                    getScreenPosition: () => targetPos
                };
                // Override the getUnitScreenPosition function temporarily for the dummy object
                const originalGetUnitScreenPosition = getUnitScreenPosition;
                getUnitScreenPosition = (unit) => {
                    if (unit === dummyTarget) return unit.getScreenPosition();
                    return originalGetUnitScreenPosition(unit);
                };

                if (attackingUnit.type.attackType === 'melee') {
                    animation.type = 'attack_lunge';
                    animation.duration = 250;
                    animation.target = dummyTarget;
                    gameState.activeAnimations.push(animation);
                } else if (attackingUnit.type.attackType === 'ranged') {
                    animation.targets = [dummyTarget];
                    const startPos = originalGetUnitScreenPosition(attackingUnit);
                    const maxDistance = pointDistance(startPos, targetPos);
                    const travelDuration = maxDistance / PROJECTILE_SPEED_PIXELS_PER_MS;

                    animation.type = 'attack_projectile';
                    animation.duration = 150 + 250 + travelDuration;
                    animation.preShotDuration = {
                        draw: 150,
                        hold: 250
                    };
                    animation.travelDuration = travelDuration;
                    gameState.activeAnimations.push(animation);
                }

                // Restore the original function after the animation is pushed
                setTimeout(() => {
                    getUnitScreenPosition = originalGetUnitScreenPosition;
                }, animation.duration + 50);

            } else {
                animation.onComplete();
            }

        } else if (attackingUnit.type.attackType === 'melee') {
            // --- Original Melee logic ---
            animation.type = 'attack_lunge';
            animation.duration = 250;
            animation.target = targetUnitInfo.unit;
            gameState.activeAnimations.push(animation);
        } else if (attackingUnit.type.attackType === 'ranged') {
            // --- Original Ranged logic ---
            let targets = [];
            let maxDistance = 0;

            const edgeOfTarget = targetUnitInfo.edgeKey ? gameState.edges.get(targetUnitInfo.edgeKey) : null;
            const enemyUnitsOnEdge = edgeOfTarget ? edgeOfTarget.units.filter(u => u.player !== attackingUnit.player) : [];

            if (edgeOfTarget && enemyUnitsOnEdge.length === 2 && !targetUnitInfo.unit.isFortified) {
                targets = enemyUnitsOnEdge;
            } else {
                targets.push(targetUnitInfo.unit);
            }

            animation.targets = targets;

            const startPos = getUnitScreenPosition(attackingUnit);
            if (startPos) {
                targets.forEach(t => {
                    const targetPos = getUnitScreenPosition(t);
                    if (targetPos) {
                        const distance = pointDistance(startPos, targetPos);
                        if (distance > maxDistance) maxDistance = distance;
                    }
                });
            }

            if (maxDistance > 0) {
                const preShotDrawDuration = 150;
                const preShotHoldDuration = 250;
                const travelDuration = maxDistance / PROJECTILE_SPEED_PIXELS_PER_MS;

                animation.type = 'attack_projectile';
                animation.duration = preShotDrawDuration + preShotHoldDuration + travelDuration;
                animation.preShotDuration = {
                    draw: preShotDrawDuration,
                    hold: preShotHoldDuration
                };
                animation.travelDuration = travelDuration;

                gameState.activeAnimations.push(animation);
            } else {
                animation.onComplete();
            }
        } else {
            animation.onComplete();
        }
    } else {
        // Animations are disabled, so execute the result immediately.
        animation.onComplete();
    }

    resetActionSelectionStates();
    updateSelectedUnitInfoPanel();
}

function showSwapClassModal(unit) {
    const overlay = document.getElementById('respawnModalOverlay');
    const content = document.getElementById('respawnModalContent');
    if (!overlay || !content) return;

    content.classList.add('swap-mode');
    content.querySelector('h3').textContent = "Morph Unit";
    content.querySelector('p').textContent = `Select new class for ${unit.type.name}`;

    const buttons = content.querySelectorAll('.respawn-button');
    buttons.forEach(btn => {
        const typeName = btn.dataset.unitType; // e.g., "MELEE"
        const type = UNIT_TYPES[typeName];
        
        // --- FIX: Inject the SVG icon ---
        btn.innerHTML = UNIT_SVGS[typeName];
        // -------------------------------

        let isValid = true;

        if (type.name === unit.type.name) isValid = false;
        if (unit.isFortified && type.name === 'Horseman') isValid = false;

        btn.disabled = !isValid;
        
        // Remove old listeners to be safe
        btn.onclick = null;

        btn.onclick = (e) => {
            e.stopPropagation(); // Prevent bubbling
            performSwap(unit, type);
            hideRespawnModal();
            btn.onclick = null; 
        };
    });

    overlay.style.display = 'flex';
    setTimeout(() => overlay.classList.add('modal-visible'), 10);
}

function performSwap(unit, newType) {
    const oldRatio = unit.hp / unit.maxHp;
    let newHp = Math.floor(newType.hp * oldRatio);
    if (newHp < 1) newHp = 1; 

    const oldType = unit.type.name;
    
    // Update counts
    gameState.unitCounts[`player${unit.player}`][oldType]--;
    gameState.unitCounts[`player${unit.player}`][newType.name]++;

    unit.type = newType;
    unit.maxHp = newType.hp;
    unit.hp = newHp;
    
    triggerDamageVisual(unit, 'normal');
    logAction(`P${unit.player} morphed ${oldType} into ${newType.name}.`, unit.player);

    gameState.swapState = 'complete';
    gameState.unitToSwap = null;
    
    updateSupplyPointsDisplay();
    showInstruction("Swap complete! Turn begins.", 2000);
}

function handleForcedSwap() {
    if (gameState.gameMode !== 'arcade') return;
    
    const myUnits = gameState.units.filter(u => u.player === gameState.currentPlayer);
    if (myUnits.length === 0) { proceedToEndTurn(); return; }
    
    const victim = myUnits[Math.floor(Math.random() * myUnits.length)];
    const allTypes = Object.values(UNIT_TYPES);
    const validTypes = allTypes.filter(t => {
        if (t.name === victim.type.name) return false;
        if (victim.isFortified && t.name === 'Horseman') return false;
        return true;
    });
    
    const newType = validTypes[Math.floor(Math.random() * validTypes.length)];
    
    hideRespawnModal(); 
    performSwap(victim, newType);
    proceedToEndTurn();
}

        function handleUnitSelectionClick(x, y) {
            let clickedOnUnit = null;
            for (const unit of gameState.units) {
                if (unit.isFortified && unit.positionType === 'center') {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const {x: tileCenterX, y: tileCenterY} = axialToPixel(tile.q, tile.r);
                        if (Math.sqrt((x - tileCenterX)**2 + (y - tileCenterY)**2) < (FORTIFIED_UNIT_DRAW_SIZE * gameState.renderScale) * 1.5) {
                             if (unit.player === gameState.currentPlayer) {
                                if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) {
                                    showInstruction(`That is an AI unit.`);
                                    return true;
                                }
                                clickedOnUnit = unit;
                                break;
                            } else { showInstruction(`Enemy ${unit.type.name} fortified.`); return true; }
                        }
                    }
                }
            }
            if (!clickedOnUnit) {
                 const unitEdgePairs = [];
                 gameState.edges.forEach((edge, edgeKey) => { edge.units.forEach(u => { if (u.positionType === 'edge') unitEdgePairs.push({ unit: u, edge: edge }); }); });
                for (let i = unitEdgePairs.length - 1; i >= 0; i--) {
                    const {unit, edge} = unitEdgePairs[i]; const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    let unitX = mid.x, unitY = mid.y;
                    const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                    const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                    if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                        const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                        const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                        let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                        let perpX = -dy_val / len, perpY = dx_val / len;
                        unitX += perpX * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5); unitY += perpY * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5);
                    }
                    if (Math.sqrt((x - unitX)**2 + (y - unitY)**2) < (UNIT_CLICK_RADIUS * gameState.renderScale)) {
                       if (unit.player === gameState.currentPlayer) {
                            if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) {
                                showInstruction(`That is an AI unit.`);
                                return true;
                            }
                            clickedOnUnit = unit;
                            break;
                        } else { showInstruction(`Enemy ${unit.type.name} on edge.`); return true; }
                    }
                }
            }

            if (clickedOnUnit) {
                if (gameState.selectedUnit && gameState.selectedUnit.id === clickedOnUnit.id) {
                    gameState.selectedUnit = null; 
                    gameState.currentReachableMoves.clear();
                    resetActionSelectionStates(); 
                } else {
                    gameState.selectedUnit = clickedOnUnit;
                    resetActionSelectionStates();
                    const unit = gameState.selectedUnit;
                    const canPhysicallyMove = !unit.isFortified && unit.positionType === 'edge' && unit.currentMove >= 1;
                    const isAllowedToMove = !unit.hasPerformedMajorAction || unit.type.canMoveAfterAttack;
                    if (canPhysicallyMove && isAllowedToMove) {
                        gameState.currentReachableMoves = getPossibleMoves(unit);
                    } else {
                        gameState.currentReachableMoves.clear();
                    }
                }
                updateSelectedUnitInfoPanel(); 
                return true;
            }
            return false;
        }

function handleInteractionStart(x, y, isTouchEvent = false) {
            if (gameState.fillToolActive) {
                if (gameState.mapMakerBrush.type !== 'tile') {
                    showInstruction("Please select a tile type to fill with.", 2000);
                    return;
                }
                const coords = pixelToAxial(x, y);
                performFloodFill(coords.q, coords.r);
                return;
            }

            if (gameState.mapMakerMode) {
                gameState.isDragging = true;
                gameState.mapMakerLastPaintedHexKey = null;
                applyMapMakerBrush(x, y);
                return;
            }
            if (gameState.gameOver) return;

            // --- ARCADE SWAP INTERCEPTION ---
            if (gameState.gameMode === 'arcade' && gameState.swapState === 'selecting_unit') {
                const baseClickRadius = isTouchEvent ? UNIT_CLICK_RADIUS * 1.5 : UNIT_CLICK_RADIUS;
                const clickRadius = baseClickRadius * gameState.renderScale;
                
                // Simple finding logic for Swap Click
                let clickedUnit = null;
                const edgeUnits = [];
                gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
                
                for (let i = edgeUnits.length - 1; i >= 0; i--) {
                     const {unit, edge} = edgeUnits[i];
                     if (unit.player !== gameState.currentPlayer) continue;
                     const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                     // (Simplified math from main handler for brevity, full implementation recommended in production)
                     if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < clickRadius) {
                         clickedUnit = unit;
                         break;
                     }
                }
                // Also check fortified units (though rare in arcade)
                if (!clickedUnit) {
                    for (const unit of gameState.units) {
                         if (unit.player === gameState.currentPlayer && unit.isFortified) {
                             const tile = gameState.tiles.get(unit.position);
                             if (tile) {
                                 const {x: tx, y: ty} = axialToPixel(tile.q, tile.r);
                                 if (Math.sqrt((x - tx)**2 + (y - ty)**2) < clickRadius) {
                                     clickedUnit = unit;
                                     break;
                                 }
                             }
                         }
                    }
                }

                if (clickedUnit) {
                    gameState.unitToSwap = clickedUnit;
                    gameState.swapState = 'selecting_class';
                    showSwapClassModal(clickedUnit);
                } else {
                    showInstruction("You must select a unit to SWAP!", 1500);
                }
                return; // Stop standard interaction
            }

            if (gameState.fillToolActive) {
                if (gameState.mapMakerBrush.type !== 'tile') {
                    showInstruction("Please select a tile type to fill with.", 2000);
                    return;
                }
                const coords = pixelToAxial(x, y);
                performFloodFill(coords.q, coords.r);
                return;
            }

            if (gameState.mapMakerMode) {
                gameState.isDragging = true;
                gameState.mapMakerLastPaintedHexKey = null;
                applyMapMakerBrush(x, y);
                return;
            }
            if (gameState.gameOver || gameState.currentActionState !== ACTION_STATES.IDLE && gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED) return;

            dragOperationJustConcluded = false; 
            clearDebugPath();
            gameState.dragStartX = x; 
            gameState.dragStartY = y; 
            gameState.draggedDistance = 0;

            let unitToDrag = null;
            
            // --- FIX: Apply renderScale to click radius ---
            const baseClickRadius = isTouchEvent ? UNIT_CLICK_RADIUS * 1.5 : UNIT_CLICK_RADIUS;
            const clickRadius = baseClickRadius * gameState.renderScale;
            // ----------------------------------------------

            const edgeUnits = [];
            gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
            
            for (let i = edgeUnits.length - 1; i >= 0; i--) {
                 const {unit, edge} = edgeUnits[i];
                 if (unit.player !== gameState.currentPlayer) continue;
                if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) continue; 
                if (unit.isFortified || unit.currentMove < 1) continue;
                 if (unit.hasPerformedMajorAction && !unit.type.canMoveAfterAttack) continue;
                 
                 const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                 let unitCenterX = mid.x, unitCenterY = mid.y;
                 const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                 const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                 if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                    const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                    const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                    let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                    let perpX = -dy_val / len, perpY = dx_val / len;
                    
                    // --- FIX: Apply renderScale to visual offset calculation ---
                    unitCenterX += perpX * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5); 
                    unitCenterY += perpY * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5);
                 }
                 
                 if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < clickRadius) { 
                     unitToDrag = unit; 
                     break; 
                 }
            }

            if (unitToDrag) {
                gameState.isDragging = true; 
                gameState.dragStartTime = Date.now();
                gameState.draggingUnit = unitToDrag;
                gameState.dragUnitOriginalPosition = unitToDrag.position; 
                gameState.dragUnitOriginalType = unitToDrag.positionType;
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                if (!gameState.selectedUnit || gameState.selectedUnit.id !== unitToDrag.id) {
                    gameState.selectedUnit = unitToDrag;
                    gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                    updateSelectedUnitInfoPanel();
                }
                gameState.currentReachableMoves = getPossibleMoves(unitToDrag);
                if (unitToDrag.positionType === 'edge') {
                    const edgeData = gameState.edges.get(unitToDrag.position);
                    if (edgeData) edgeData.units = edgeData.units.filter(u => u.id !== unitToDrag.id);
                }
                canvas.style.cursor = 'grabbing'; 
            }
        }

    
function handleMoveAction(unitToMove, targetEdgeKey, costToMove) {
    gameState.playerActionTaken[`player${gameState.currentPlayer}`] = true;

    // --- 1. MASTER REFERENCE CHECK ---
    // Ensure we are working with the canonical unit object from the master list
    const masterUnit = gameState.units.find(u => u.id === unitToMove.id);
    if (!masterUnit) {
        console.error("CRITICAL: Unit not found in master list during move.");
        return;
    }
    
    // Use the master reference for all operations
    const unit = masterUnit;

    // --- 2. GLOBAL WIPE (FAILSAFE) ---
    // Remove this unit ID from ALL edge arrays in the game.
    // This prevents any possibility of "ghosts" existing on old edges.
    gameState.edges.forEach((edge) => {
        // Use filter to create a clean array without the unit
        if (edge.units.some(u => u.id === unit.id)) {
            edge.units = edge.units.filter(u => u.id !== unit.id);
        }
    });

    // --- 3. UPDATE UNIT STATE ---
    unit.position = targetEdgeKey;
    unit.positionType = 'edge';
    unit.currentMove -= costToMove;

    // --- 4. ADD TO DESTINATION ---
    const finalTargetEdgeData = gameState.edges.get(targetEdgeKey);
    if (finalTargetEdgeData) {
        finalTargetEdgeData.units.push(unit);
    } else {
        console.error("Target edge for move not found:", targetEdgeKey);
    }

    clearDebugPath();

    // --- FLAG CAPTURE LOGIC ---
    if (gameState.gameMode !== 'arcade') {
        const enemyPlayer = unit.player === 1 ? 2 : 1;
        let enemyFlagHome = null;
        
        // Logic for Expansive Mode (Pickup on any internal edge)
        if (gameState.gridRadius === 4) {
            if (isInternalBaseEdge(targetEdgeKey)) {
                // Check if this internal edge belongs to the enemy
                const [h1, h2] = parseEdgeKey(targetEdgeKey);
                const t1 = getTileKey(h1.q, h1.r);
                const enemyBase = gameState.baseCampPositions[`player${enemyPlayer}`];
                if (Array.isArray(enemyBase) && enemyBase.includes(t1)) {
                    // Confirmed: Moved onto an internal edge of enemy base
                    enemyFlagHome = true; // Signal capture
                }
            }
        } 
        // Logic for Standard Mode (Pickup on specific edge)
        else {
            const flagObj = unit.player === 1 ? gameState.flags.p2_flag : gameState.flags.p1_flag;
            if (flagObj && flagObj.homePosition === targetEdgeKey) {
                enemyFlagHome = true;
            }
        }

        const enemyFlagObj = unit.player === 1 ? gameState.flags.p2_flag : gameState.flags.p1_flag;

        if (enemyFlagHome && enemyFlagObj.status === 'at_base') {
            enemyFlagObj.status = 'carried';
            enemyFlagObj.carrierId = unit.id;
            unit.isCarryingFlag = true;
            unit.currentMove = 0;
            // ... (rest of capture logic: logs, supply severing, etc.)
            logAction(`P${unit.player} ${unit.type.name} has picked up the flag!`, gameState.currentPlayer);
            updateAllHealingStatus();
            severSupplyLinesForPlayer(enemyPlayer);
            
            const victimPlayerQueue = gameState.respawnQueue[`player${enemyPlayer}`];
            victimPlayerQueue.forEach(item => {
                if (!item.timerHalved) {
                    item.turnsRemaining = Math.ceil(item.turnsRemaining / 2);
                    item.timerHalved = true;
                }
            });
            updateRespawnQueueDisplay();
            updateSupplyPointsBasedOnFlagStatus(enemyPlayer);

            const unitPos = getUnitScreenPosition(unit);
            if (unitPos) {
                gameState.visualEffects.push({
                    type: 'flag_capture_burst',
                    x: unitPos.x,
                    y: unitPos.y,
                    player: enemyPlayer,
                    startTime: Date.now(),
                    duration: 500
                });
            }
        }
    }

    if (checkVictoryCondition()) return;

    const unitDestroyedByZoC = applyFortificationDamageOnMove(unit, targetEdgeKey);

    if (!unitDestroyedByZoC && unit.hp > 0) {
        logAction(`${unit.type.name} moved. MP: ${Math.floor(unit.currentMove)}`, gameState.currentPlayer);
        if (unit.currentMove >= 1 && (!unit.hasPerformedMajorAction || unit.type.canMoveAfterAttack)) {
            if (gameState.gameMode !== 'singleplayer' || unit.player === gameState.playerSide) {
                gameState.currentReachableMoves = getPossibleMoves(unit);
            }
        } else {
            gameState.currentReachableMoves.clear();
        }
    } else {
        gameState.currentReachableMoves.clear();
    }

    updateSelectedUnitInfoPanel();
    updateSupplyPointsDisplay();
}

function handleMoveClick(x, y) {
    const { selectedUnit } = gameState;
    if (!selectedUnit || selectedUnit.isFortified || selectedUnit.currentMove < 1) {
        return false;
    }
    if (gameState.gameMode === 'singleplayer' && selectedUnit.player !== gameState.playerSide) {
        return false;
    }
    if (selectedUnit.hasPerformedMajorAction && !selectedUnit.type.canMoveAfterAttack) {
        return false;
    }
    
    // --- FIX: Scale the click radius ---
    const scaledClickRadius = HIGHLIGHT_CLICK_RADIUS * gameState.renderScale;

    for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
        const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
        const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
        
        if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < scaledClickRadius) {
            const costToMove = moveData.cost;
            if (finalTargetEdgeData.units.some(u => u.player !== selectedUnit.player)) { showInstruction("Cannot move to enemy edge."); return true; }
            if (finalTargetEdgeData.units.filter(u => u.player === selectedUnit.player).length >= 2) { showInstruction("Target edge full."); return true; }
            if (costToMove <= selectedUnit.currentMove && costToMove !== Infinity) handleMoveAction(selectedUnit, targetEdgeKey, costToMove);
            else showInstruction(`Cannot move. Cost: ${costToMove.toFixed(1)}, Have: ${selectedUnit.currentMove.toFixed(1)}`);
            return true;
        }
    }
     return false;
}

function handleActionTargetSelectionClick(x, y) {
    const { selectedUnit, currentActionState } = gameState;
    if (!selectedUnit) return false;

    let clickHandled = true;
    let clickedValidTarget = false;

    switch (currentActionState) {
        case ACTION_STATES.SELECTING_FORTIFY_TILE:
            const clickedAxial = pixelToAxial(x, y);
            const clickedTileKey = getTileKey(clickedAxial.q, clickedAxial.r);
            if (gameState.validFortifyTargetTileKeys.includes(clickedTileKey)) {
                completeFortify(selectedUnit, clickedTileKey);
                clickedValidTarget = true;
            }
            break;

            case ACTION_STATES.SELECTING_UNFORTIFY_EDGE:
            // --- FIX: Scale radius for unfortify selection ---
            const scaledUnfortifyRadius = HIGHLIGHT_CLICK_RADIUS * gameState.renderScale;
            
            for (const edgeKey of gameState.validUnfortifyTargetEdgeKeys) {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < scaledUnfortifyRadius) {
                        completeUnfortify(selectedUnit, edgeKey);
                        clickedValidTarget = true;
                        break;
                    }
                }
            }
            break;

        case ACTION_STATES.SELECTING_BRIDGE_EDGE:
            for (const edgeKey of gameState.validBridgeTargetEdgeKeys) {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    const p = { x, y };
                    const p1_center = axialToPixel(edge.q1, edge.r1);
                    const p2_center = axialToPixel(edge.q2, edge.r2);

                    // --- Define the line segment endpoints for the edge ---
                    const edgeMidX = (p1_center.x + p2_center.x) / 2;
                    const edgeMidY = (p1_center.y + p2_center.y) / 2;
                    let perp_dx = -(p2_center.y - p1_center.y);
                    let perp_dy = p2_center.x - p1_center.x;
                    const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                    if (len_perp_vec > 0) {
                        const scale = HEX_SIZE / 2;
                        perp_dx = (perp_dx / len_perp_vec) * scale;
                        perp_dy = (perp_dy / len_perp_vec) * scale;
                        const v = { x: edgeMidX + perp_dx, y: edgeMidY + perp_dy };
                        const w = { x: edgeMidX - perp_dx, y: edgeMidY - perp_dy };

                        // --- Check distance from click to the line segment ---
                        if (distToSegmentSquared(p, v, w) < (BRIDGE_CLICK_TOLERANCE * 2)**2) {
                            completeBuildBridge(edgeKey);
                            clickedValidTarget = true;
                            break;
                        }
                    }
                }
            }
            break;
        
        case ACTION_STATES.SELECTING_ATTACK_TARGET:
            const currentAttackTargets = selectedUnit.type.attackType === 'melee' 
                ? gameState.validMeleeAttackTargets 
                : gameState.validArcherAttackTargets;
            const attackType = selectedUnit.type.attackType === 'melee' ? 'Melee' : 'Archer';

            for (const targetInfo of currentAttackTargets) {
                if (targetInfo.isBridgeTarget && targetInfo.edgeKey) {
                    const edge = gameState.edges.get(targetInfo.edgeKey);
                    if (edge && edge.bridge) {
                        const p = { x, y };
                        const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
                        const edgeMidX = (p1_center.x + p2_center.x) / 2; const edgeMidY = (p1_center.y + p2_center.y) / 2;
                        let perp_dx = -(p2_center.y - p1_center.y); let perp_dy = p2_center.x - p1_center.x;
                        const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                        if (len_perp_vec > 0) {
                            const scale = HEX_SIZE / 2;
                            perp_dx = (perp_dx / len_perp_vec) * scale;
                            perp_dy = (perp_dy / len_perp_vec) * scale;
                            const v = { x: edgeMidX + perp_dx, y: edgeMidY + perp_dy };
                            const w = { x: edgeMidX - perp_dx, y: edgeMidY - perp_dy };

                            if (distToSegmentSquared(p, v, w) < (BRIDGE_CLICK_TOLERANCE * 2)**2) {
                                completeAttack(selectedUnit, targetInfo, attackType);
                                clickedValidTarget = true;
                                break;
                            }
                        }
                    }
                } else if (targetInfo.unit) {
                    const targetUnit = targetInfo.unit; let unitX_val, unitY_val, clickRadius = UNIT_CLICK_RADIUS;
                    if (targetUnit.isFortified && targetUnit.positionType === 'center' && targetInfo.tileKeyForTarget) {
                        const tile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                        if (tile) { const centerPixel = axialToPixel(tile.q, tile.r); unitX_val = centerPixel.x; unitY_val = centerPixel.y; clickRadius = FORTIFIED_UNIT_DRAW_SIZE * 1.5; }
                        else continue;
                    } else if (targetInfo.edgeKey) {
                        const edgeOfTarget = gameState.edges.get(targetInfo.edgeKey); if (!edgeOfTarget) continue;
                        const mid = getEdgeMidpoint(edgeOfTarget.q1, edgeOfTarget.r1, edgeOfTarget.q2, edgeOfTarget.r2); unitX_val = mid.x; unitY_val = mid.y;
                        const edgeUnitsOnly = edgeOfTarget.units.filter(u => u.positionType === 'edge');
                        const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === targetUnit.id);
                        if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                            const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edgeOfTarget.q1, edgeOfTarget.r1); const p2 = axialToPixel(edgeOfTarget.q2, edgeOfTarget.r2);
                            let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                            let perpX = -dy_val / len, perpY = dx_val / len;
                            unitX_val += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitY_val += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                        }
                    } else continue;
                    if (Math.sqrt((x - unitX_val)**2 + (y - unitY_val)**2) < clickRadius) { 
                        completeAttack(selectedUnit, targetInfo, attackType); 
                        clickedValidTarget = true; 
                        break; 
                    }
                }
            }
            if (clickedValidTarget) break; 
            break; 

        default:
            clickHandled = false;
            break;
    }

    if (clickHandled && !clickedValidTarget) {
        showInstruction("Invalid selection. Click a highlighted target or Cancel.", 2000);
    }
    return clickHandled;
}

        // --- REFACTORED GENERIC EVENT HANDLERS ---
function handleInteractionStart(x, y, isTouchEvent = false) {
            if (gameState.fillToolActive) {
                if (gameState.mapMakerBrush.type !== 'tile') {
                    showInstruction("Please select a tile type to fill with.", 2000);
                    return;
                }
                const coords = pixelToAxial(x, y);
                performFloodFill(coords.q, coords.r);
                return;
            }

            if (gameState.mapMakerMode) {
                gameState.isDragging = true;
                gameState.mapMakerLastPaintedHexKey = null;
                applyMapMakerBrush(x, y);
                return;
            }
            if (gameState.gameOver) return;

            // --- ARCADE SWAP INTERCEPTION ---
            // This blocks normal interaction if we are in the 'selecting_unit' phase (Turn 2+)
            if (gameState.gameMode === 'arcade' && gameState.swapState === 'selecting_unit') {
                const baseClickRadius = isTouchEvent ? UNIT_CLICK_RADIUS * 1.5 : UNIT_CLICK_RADIUS;
                const clickRadius = baseClickRadius * gameState.renderScale;
                
                let clickedUnit = null;
                const edgeUnits = [];
                gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
                
                for (let i = edgeUnits.length - 1; i >= 0; i--) {
                     const {unit, edge} = edgeUnits[i];
                     if (unit.player !== gameState.currentPlayer) continue;
                     const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                     if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < clickRadius) {
                         clickedUnit = unit;
                         break;
                     }
                }
                if (!clickedUnit) {
                    for (const unit of gameState.units) {
                         if (unit.player === gameState.currentPlayer && unit.isFortified) {
                             const tile = gameState.tiles.get(unit.position);
                             if (tile) {
                                 const {x: tx, y: ty} = axialToPixel(tile.q, tile.r);
                                 if (Math.sqrt((x - tx)**2 + (y - ty)**2) < clickRadius) {
                                     clickedUnit = unit;
                                     break;
                                 }
                             }
                         }
                    }
                }

                if (clickedUnit) {
                    gameState.unitToSwap = clickedUnit;
                    gameState.swapState = 'selecting_class';
                    showSwapClassModal(clickedUnit);
                } else {
                    showInstruction("You must select a unit to SWAP!", 1500);
                }
                return; // Stop standard interaction here
            }

            // Standard Interaction continues below...
            if (gameState.currentActionState !== ACTION_STATES.IDLE && gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED) return;

            dragOperationJustConcluded = false; 
            clearDebugPath();
            
            gameState.dragStartX = x; 
            gameState.dragStartY = y; 
            gameState.draggedDistance = 0;

            let unitToDrag = null;
            const clickRadius = (isTouchEvent ? UNIT_CLICK_RADIUS * 1.5 : UNIT_CLICK_RADIUS) * gameState.renderScale;
            const edgeUnits = [];
            gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
            
            for (let i = edgeUnits.length - 1; i >= 0; i--) {
                 const {unit, edge} = edgeUnits[i];
                 if (unit.player !== gameState.currentPlayer) continue;
                 if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) continue; 
                 if (unit.isFortified || unit.currentMove < 1) continue;
                 if (unit.hasPerformedMajorAction && !unit.type.canMoveAfterAttack) continue;
                 
                 const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                 let unitCenterX = mid.x, unitCenterY = mid.y;
                 const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                 const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                 if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                    const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                    const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                    let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                    let perpX = -dy_val / len, perpY = dx_val / len;
                    unitCenterX += perpX * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5); 
                    unitCenterY += perpY * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5);
                 }
                 if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < clickRadius) { 
                     unitToDrag = unit; 
                     break; 
                 }
            }

            if (unitToDrag) {
                gameState.isDragging = true; 
                gameState.dragStartTime = Date.now();
                gameState.draggingUnit = unitToDrag;
                gameState.dragUnitOriginalPosition = unitToDrag.position; 
                gameState.dragUnitOriginalType = unitToDrag.positionType;
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                
                if (!gameState.selectedUnit || gameState.selectedUnit.id !== unitToDrag.id) {
                    gameState.selectedUnit = unitToDrag;
                    gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                    updateSelectedUnitInfoPanel();
                }
                
                gameState.currentReachableMoves = getPossibleMoves(unitToDrag);
                
                if (unitToDrag.positionType === 'edge') {
                    const edgeData = gameState.edges.get(unitToDrag.position);
                    if (edgeData) edgeData.units = edgeData.units.filter(u => u.id !== unitToDrag.id);
                }
                canvas.style.cursor = 'grabbing'; 
            }
        }

        function handleInteractionMove(x, y) {
            if (gameState.mapMakerMode && gameState.isDragging) {
                applyMapMakerBrush(x, y);
                return;
            }
             if (gameState.isDragging && gameState.draggingUnit) {
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                gameState.draggedDistance = Math.sqrt((x - gameState.dragStartX)**2 + (y - gameState.dragStartY)**2);
                
                // --- FIX: Scale the hover detection radius ---
                const scaledHighlightRadius = HIGHLIGHT_CLICK_RADIUS * gameState.renderScale;
                
                let foundPathUnderCursor = null;
                for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                     const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                     const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                     if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < scaledHighlightRadius) { 
                        foundPathUnderCursor = moveData.path; 
                        break; 
                    }
                 }
                if (foundPathUnderCursor) {
                    const newPotentialPathKey = foundPathUnderCursor.join('-');
                    const currentPotentialPathKey = gameState.potentialDebugPathToDraw ? gameState.potentialDebugPathToDraw.join('-') : null;

                    if (newPotentialPathKey !== currentPotentialPathKey) {
                        gameState.potentialDebugPathToDraw = foundPathUnderCursor;
                        gameState.debugPathHoverStartTime = Date.now();
                        if (gameState.debugPathToDraw && gameState.debugPathToDraw.join('-') !== newPotentialPathKey) {
                            clearDebugPath(); 
                        }
                    }
                } else { 
                    if (gameState.potentialDebugPathToDraw) {
                       clearDebugPath(); 
                    }
                }
            }
        }

        function handleInteractionEnd(x, y, isTouchEvent = false) {
            if (gameState.mapMakerMode) {
                gameState.isDragging = false;
                gameState.mapMakerLastPaintedHexKey = null;
                return;
            }
            if (!gameState.isDragging || !gameState.draggingUnit) return;
            
            dragOperationJustConcluded = true;
            let droppedOnValidTarget = false;
            
            if (gameState.draggedDistance >= DRAGGED_DISTANCE_THRESHOLD) {
                // --- FIX: Scale the drop radius ---
                const dropRadius = (isTouchEvent ? HIGHLIGHT_CLICK_RADIUS * 1.2 : HIGHLIGHT_CLICK_RADIUS) * gameState.renderScale;
                
                for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                    const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                    const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                    if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < dropRadius) {
                        const costToMove = moveData.cost; 
                        if (finalTargetEdgeData.units.some(u => u.player !== gameState.draggingUnit.player)) { showInstruction("Cannot move to enemy edge."); break; }
                        if (finalTargetEdgeData.units.filter(u => u.player === gameState.draggingUnit.player).length >= 2) { showInstruction("Target edge full."); break; }
                        if (costToMove <= gameState.draggingUnit.currentMove && costToMove !== Infinity) { 
                            handleMoveAction(gameState.draggingUnit, targetEdgeKey, costToMove); 
                            droppedOnValidTarget = true; 
                        }
                        else { showInstruction(`Cannot move. Cost: ${costToMove.toFixed(1)}, Have: ${gameState.draggingUnit.currentMove.toFixed(1)}`); }
                        break;
                    }
                }
            }
            
            if (!droppedOnValidTarget) {
                 const unit = gameState.draggingUnit;
                if (unit) {
                    if (gameState.dragUnitOriginalType === 'edge' && gameState.dragUnitOriginalPosition) {
                         const originalEdge = gameState.edges.get(gameState.dragUnitOriginalPosition);
                         if (originalEdge && !originalEdge.units.find(u => u.id === unit.id)) originalEdge.units.push(unit);
                         unit.position = gameState.dragUnitOriginalPosition; unit.positionType = 'edge';
                     }
                     if (gameState.draggedDistance >= DRAGGED_DISTANCE_THRESHOLD) showInstruction("Invalid drop. Unit returned.", 2000);
                     gameState.selectedUnit = unit;
                     gameState.currentActionState = ACTION_STATES.UNIT_SELECTED; 
                      if(unit && !unit.isFortified && unit.hp > 0 && !unit.hasPerformedMajorAction && unit.currentMove >=1) gameState.currentReachableMoves = getPossibleMoves(unit);
                      else gameState.currentReachableMoves.clear();
                }
            }
            
            gameState.isDragging = false; 
            gameState.dragStartTime = null;
            gameState.draggingUnit = null; 
            gameState.dragUnitOriginalPosition = null; 
            gameState.dragUnitOriginalType = null;
            clearDebugPath(); 
            canvas.style.cursor = gameState.hoveredUnitId ? 'pointer' : 'default'; 
            updateSelectedUnitInfoPanel(); 
        }

        function handleInteractionCancel() {
            dragOperationJustConcluded = true;
            clearDebugPath();
            if (gameState.isDragging && gameState.draggingUnit) {
                 const unit = gameState.draggingUnit;
                 if (gameState.dragUnitOriginalType === 'edge' && gameState.dragUnitOriginalPosition) {
                     const originalEdge = gameState.edges.get(gameState.dragUnitOriginalPosition);
                     if (originalEdge && !originalEdge.units.find(u => u.id === unit.id)) originalEdge.units.push(unit);
                     unit.position = gameState.dragUnitOriginalPosition; unit.positionType = 'edge';
                 }
                gameState.isDragging = false; 
                gameState.dragStartTime = null;
                gameState.draggingUnit = null; 
                gameState.dragUnitOriginalPosition = null; 
                gameState.dragUnitOriginalType = null;
                showInstruction("Drag cancelled. Unit returned.", 2500);
                gameState.selectedUnit = unit; 
                gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                if(unit && !unit.isFortified && unit.hp > 0 && !unit.hasPerformedMajorAction && unit.currentMove >=1) gameState.currentReachableMoves = getPossibleMoves(unit);
                else gameState.currentReachableMoves.clear();
                updateSelectedUnitInfoPanel();
            }
        }    

        function handleTapLogic(x, y) {
            if (gameState.mapMakerMode) return; 

            if (handleActionTargetSelectionClick(x, y)) { /* Action target click handled */ } 
            else if (handleUnitSelectionClick(x,y)) { /* Unit selection/deselection handled */ }
            else if (handleMoveClick(x, y)) { /* Click-to-move handled */ } 
            else if (gameState.selectedUnit) {
                 gameState.selectedUnit = null; 
                 gameState.currentReachableMoves.clear();
                 resetActionSelectionStates(); 
                 updateSelectedUnitInfoPanel(); 
            }
        }

        // --- Original Event Handlers (Now as Wrappers) ---
        function handleCanvasMouseDown(event) {
            if (event.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleInteractionStart(x, y, false);
        }

        function handleCanvasMouseMove(event) {
            if (gameState.gameOver) return;
            const rect = canvas.getBoundingClientRect(); 
            const x = event.clientX - rect.left; 
            const y = event.clientY - rect.top;

            if (gameState.isDragging) {
                event.preventDefault();
                handleInteractionMove(x, y);
            } else {
                let foundHoverable = false; let newHoveredUnitId = null; const edgeUnits = [];
                gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
                for(let i = edgeUnits.length -1; i >= 0; i--) {
                    const {unit, edge} = edgeUnits[i]; if (unit.player !== gameState.currentPlayer) continue;
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    let unitCenterX = mid.x, unitCenterY = mid.y;
                    const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                    const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                    if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                        const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                        const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                        let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                        let perpX = -dy_val / len, perpY = dx_val / len;
                        unitCenterX += perpX * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5); unitCenterY += perpY * (UNIT_ON_EDGE_OFFSET * gameState.renderScale) * offsetSign * (0.5);
                    }
                    if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < (UNIT_CLICK_RADIUS * gameState.renderScale)) { newHoveredUnitId = unit.id; foundHoverable = true; break; }
                }
                 if (!foundHoverable) {
                     for (const unit of gameState.units) {
                         if (unit.isFortified && unit.positionType === 'center' && unit.player === gameState.currentPlayer) {
                             const tile = gameState.tiles.get(unit.position);
                             if (tile) {
                                 const {x: tileCenterX, y: tileCenterY} = axialToPixel(tile.q, tile.r);
                                 if (Math.sqrt((x - tileCenterX)**2 + (y - tileCenterY)**2) < (FORTIFIED_UNIT_DRAW_SIZE * gameState.renderScale) * 1.5) { newHoveredUnitId = unit.id; foundHoverable = true; break; }
                             }
                         }
                     }
                 }
                if (gameState.hoveredUnitId !== newHoveredUnitId) gameState.hoveredUnitId = newHoveredUnitId;
                canvas.style.cursor = foundHoverable ? 'pointer' : 'default';
            }
        }

        function handleCanvasMouseUp(event) {
            if (gameState.gameOver || !gameState.isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleInteractionEnd(x, y, false);
        }

        function handleCanvasMouseLeave(event) {
            handleInteractionCancel();
            if (gameState.hoveredUnitId !== null) gameState.hoveredUnitId = null;
            canvas.style.cursor = 'default';
        }

        function handleCanvasTouchStart(event) {
            if (gameState.gameOver || event.touches.length !== 1) return;
            event.preventDefault();
            const touch = event.touches[0]; 
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;

            if (gameState.mapMakerMode) {
                const currentTime = Date.now();
                const timeSinceLastTap = currentTime - lastTap;
                const distance = pointDistance({x, y}, lastTapPosition);

                if (timeSinceLastTap < DOUBLE_TAP_THRESHOLD_MS && distance < DOUBLE_TAP_MAX_DISTANCE) {
                    eraseAt(x, y);
                    lastTap = 0; 
                    return;
                } else {
                    lastTap = currentTime;
                    lastTapPosition = { x, y };
                }
            }
            handleInteractionStart(x, y, true);
        }

        function handleCanvasTouchMove(event) {
            if (gameState.isDragging && gameState.draggingUnit && event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0]; 
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                handleInteractionMove(x, y);
            }
        }

        function handleCanvasTouchEnd(event) {
            if (gameState.gameOver) return;
            const finalTouch = event.changedTouches[0]; 
            if (!finalTouch) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = finalTouch.clientX - rect.left;
            const y = finalTouch.clientY - rect.top;

            const wasDragging = gameState.isDragging;
            const wasShortDrag = gameState.draggedDistance < DRAGGED_DISTANCE_THRESHOLD;

            if (wasDragging) {
                handleInteractionEnd(x, y, true);
            }
            
            if (!wasDragging || wasShortDrag) {
                handleTapLogic(x, y);
            }
            
            gameState.draggedDistance = 0;
            updateSelectedUnitInfoPanel();
        }

        function handleCanvasTouchCancel(event) {
            handleInteractionCancel();
            gameState.draggedDistance = 0;
        }

        function handleCanvasClick(event) {
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            if (gameState.mapMakerMode) {
                return;
            }

            if (gameState.gameOver || event.button !== 0) return;
            if (dragOperationJustConcluded) { 
                dragOperationJustConcluded = false; 
                return; 
            }
            
            handleTapLogic(x, y);
        }

        // --- Zone of Control Damage & Healing ---
function applyStartOfTurnZoCDamage() {
    const activePlayer = gameState.currentPlayer;
    const enemyPlayer = activePlayer === 1 ? 2 : 1;
    let unitsToDestroy = [];

    // --- FIX: Safely handle Base Camp tiles (Array vs String) ---
    const activePlayerBaseData = gameState.baseCampPositions[`player${activePlayer}`];
    let activePlayerBaseTiles = [];
    
    if (Array.isArray(activePlayerBaseData)) {
        activePlayerBaseTiles = activePlayerBaseData;
    } else if (typeof activePlayerBaseData === 'string') {
        activePlayerBaseTiles = activePlayerBaseData.split('_');
    }
    // ------------------------------------------------------------

    gameState.units.forEach(unit => {
        if (unit.player !== enemyPlayer || unit.positionType !== 'edge' || unit.isFortified) return;
        
        const edgeKey = unit.position;
        const edgeTileCoords = parseEdgeKey(edgeKey);
        if (edgeTileCoords.some(coord => isNaN(coord.q))) return;

        const tile1Key = getTileKey(edgeTileCoords[0].q, edgeTileCoords[0].r);
        const tile2Key = getTileKey(edgeTileCoords[1].q, edgeTileCoords[1].r);
        const tile1 = gameState.tiles.get(tile1Key);
        const tile2 = gameState.tiles.get(tile2Key);
        
        if ((tile1 && tile1.fortifiedByPlayer === activePlayer) || 
            (tile2 && tile2.fortifiedByPlayer === activePlayer) ||
            activePlayerBaseTiles.includes(tile1Key) || 
            activePlayerBaseTiles.includes(tile2Key)) 
        {
            unit.hp -= FORTIFICATION_DAMAGE;
            logAction(`P${unit.player} ${unit.type.name} takes start-of-turn ZoC. HP: ${unit.hp}`, activePlayer, 3500);
            if (unit.hp <= 0 && !unitsToDestroy.find(u => u.id === unit.id)) {
                unitsToDestroy.push(unit);
            }
        }
    });

    if (unitsToDestroy.length > 0) unitsToDestroy.forEach(u => handleUnitDeath(u, "zoc_turn_start"));
}

        function updateAllHealingStatus() {
            if (gameState.gameMode === 'arcade') return;

            // Check flag status for both players
            const p1FlagStolen = gameState.flags.p1_flag.status === 'carried';
            const p2FlagStolen = gameState.flags.p2_flag.status === 'carried';

            gameState.units.forEach(unit => {
                if (unit.isFortified) {
                    if (unit.player === 1) {
                        unit.canHeal = !p1FlagStolen;
                    } else { // unit.player === 2
                        unit.canHeal = !p2FlagStolen;
                    }
                } else {
                    unit.canHeal = false; // Unfortified units can't heal anyway
                }
            });
            if (p1FlagStolen) { logAction(`P1's flag is stolen! Healing is disabled.`, 2, 3000); }
            if (p2FlagStolen) { logAction(`P2's flag is stolen! Healing is disabled.`, 1, 3000); }
        }

function applyStartOfTurnHealing() {
    // In Arcade mode, there are no base camps, so units cannot heal.
    if (gameState.gameMode === 'arcade') return;

    const playerFlag = gameState.flags[`p${gameState.currentPlayer}_flag`];
    if (playerFlag && playerFlag.status === 'carried') {
        return; // No healing for anyone if their flag is stolen.
    }

    gameState.units.forEach(unit => {
        if (unit.player !== gameState.currentPlayer || !unit.isFortified || unit.hp >= (unit.maxHp + 1)) {
            return;
        }

        const recentlyAttacked = gameState.globalTurnNumber < unit.lastAttackedByHostileOnTurn + 2;
        if (recentlyAttacked) {
            return;
        }
            
        let isSupplied = false;
        const playerBaseEdgeKey = DEFAULT_FLAG_HOME_POSITIONS[`player${unit.player}`];
        
        // Ensure base positions exist before checking
        if (playerBaseEdgeKey) {
            const playerBaseTiles = [playerBaseEdgeKey.split('_')[0], playerBaseEdgeKey.split('_')[1]];
            if (playerBaseTiles.includes(unit.fortifiedTileKey)) {
                isSupplied = true;
            }
        }

        if (!isSupplied && unit.supplyLine && unit.supplyLine.path) {
            const isIntercepted = unit.supplyLine.path.some(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                return edge && edge.units.some(u => u.player !== unit.player);
            });
            if (!isIntercepted) {
                isSupplied = true;
            }
        }

        if (isSupplied) {
            const oldHp = unit.hp;
            unit.hp++;
            const activePlayer = gameState.currentPlayer;
            if (oldHp < unit.maxHp && unit.hp === unit.maxHp) {
                logAction(`P${unit.player} ${unit.type.name} healed to full HP.`, activePlayer, 2500);
            } else if (unit.hp === unit.maxHp + 1) {
                logAction(`P${unit.player} ${unit.type.name} gained a shield!`, activePlayer, 2500);
                
                let targetX, targetY, targetRadius;
                const tile = gameState.tiles.get(unit.position);
                if (tile) { 
                    const center = axialToPixel(tile.q, tile.r);
                    targetX = center.x;
                    targetY = center.y;
                    targetRadius = FORTIFIED_UNIT_DRAW_SIZE;

                    gameState.visualEffects.push({
                        type: 'shield_ring',
                        x: targetX, y: targetY,
                        unitRadius: targetRadius,
                        startTime: Date.now(),
                        duration: 600 
                    });
                }
            } else {
                 logAction(`P${unit.player} ${unit.type.name} healed 1 HP.`, activePlayer, 2500);
            }
        }
    });
}

        function logSiegeStatus() {
            if (gameState.gameMode === 'arcade' || !gameState.flags) return;

            const activePlayer = gameState.currentPlayer;
            const playerFlag = gameState.flags[`p${activePlayer}_flag`];

            if (playerFlag && playerFlag.status === 'carried') {
                const existingLog = gameState.actionLog[gameState.actionLog.length - 1];
                if (!existingLog || !existingLog.message.includes('Healing is disabled')) {
                    logAction(`P${activePlayer}'s flag is stolen! All healing is disabled.`, activePlayer);
                }
            }

            gameState.units.forEach(unit => {
                if (unit.player === activePlayer && unit.isFortified && unit.supplyLine && unit.supplyLine.path) {
                    const isIntercepted = unit.supplyLine.path.some(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        return edge && edge.units.some(u => u.player !== unit.player);
                    });

                    if (isIntercepted) {
                         logAction(`P${unit.player} ${unit.type.name} is under siege and cannot heal!`, activePlayer);
                    }
                }
            });
        }

        function handleRespawnQueue() {
            const player = gameState.currentPlayer;
            const queueKey = `player${player}`;
            const queue = gameState.respawnQueue[queueKey];
    
            if (queue.length === 0) {
                return;
            }

            // Iterate over the entire queue for the current player to decrement all timers.
            queue.forEach(item => {
            if (item.turnsRemaining > 0) { // Only decrement if it's not already ready
                item.turnsRemaining--;
                }
            });

            // After updating all timers, check if the unit at the front of the queue is ready.
            // This preserves the one-at-a-time respawn flow.
            const firstItem = queue[0];
            if (firstItem && firstItem.turnsRemaining <= 0) {
            showRespawnModal(player);
            }
    
            // Always update the display to show the new timer values.
        updateRespawnQueueDisplay();
        }

function triggerConfetti() {
    const container = document.getElementById('confettiContainer');
    if (!container) return;

    const confettiCount = 150;
    const colors = ['#FFC020', '#E04030', '#3090D0', '#2ecc71', '#F0F0F0'];

    for (let i = 0; i < confettiCount; i++) {
        const confettiPiece = document.createElement('div');
        confettiPiece.className = 'confetti-piece';
        
        // Randomize properties
        const x_start = Math.random() * 100; // % of screen width
        const y_start = -10 - Math.random() * 20; // Start off-screen
        const color = colors[Math.floor(Math.random() * colors.length)];
        const fall_duration = 3 + Math.random() * 4; // 3 to 7 seconds
        const rotation_start = Math.random() * 360;
        const rotation_end = rotation_start + 720 + Math.random() * 720;
        const sway = Math.random() * 150 - 75; // a horizontal sway of -75 to +75px

        confettiPiece.style.left = `${x_start}vw`;
        confettiPiece.style.top = `${y_start}px`;
        confettiPiece.style.backgroundColor = color;
        confettiPiece.style.transform = `rotate(${rotation_start}deg)`;
        
        container.appendChild(confettiPiece);

        // Animate using Web Animations API (clean and performant)
        confettiPiece.animate([
            { transform: `translate3d(0, 0, 0) rotate(${rotation_start}deg)` },
            { transform: `translate3d(${sway}px, 105vh, 0) rotate(${rotation_end}deg)` }
        ], {
            duration: fall_duration * 1000,
            easing: 'ease-in',
            iterations: 1
        });

        // Remove the element after it falls
        setTimeout(() => {
            confettiPiece.remove();
        }, fall_duration * 1000);
    }
}


// ========================================================================
// --- COMPLETE AI SYSTEM (VERSION 2.0) ---
// ========================================================================

// AI Brain: Gathers and scores all possible actions for a single unit.
function getUnitAIAction(unit, strategy, allEnemies, allAllies) {
    if (unit.hasPerformedMajorAction) return null;

    let possibleActions = [];

    // --- SUB-FUNCTION to score a potential attack ---
    const scoreAttack = (targetInfo) => {
        let score = 50.0;
        if(targetInfo.unit){
            if(targetInfo.unit.isCarryingFlag) score += 200;
            const predictedDmg = unit.type.attack + (unit.isFortified && unit.type.name === 'Archer' ? 1 : 0);
            if(targetInfo.unit.hp <= predictedDmg) score += 100;
            if(unit.type.strengths.includes(targetInfo.unit.type.name)) score += 25;
            if(unit.type.weaknesses.includes(targetInfo.unit.type.name)) score -= 25;
        } else { score = 5; } // Low score for bridge
        return score;
    };

    // --- SUB-FUNCTION to score a potential move ---
    const scoreMove = (edgeKey) => {
        let moveScore = 5.0; // Base incentive to not just stand still
        const unitPos = getUnitScreenPosition(unit);
        if (!unitPos) return 0;
        
        const moveMidPoint = getEdgeMidpoint(...parseEdgeKey(edgeKey).flatMap(c=>[c.q,c.r]));
        
        // Role-based scoring for the move itself
        if (unit.type.name === 'Pikeman' && strategy === 'IRON_WALL') {
            const centerDist = axialDistance(...edgeKey.split('_')[0].split(',').map(Number), 0, 0);
            moveScore += (4 - centerDist) * 5; // Move to the center to form the wall
        } else if (unit.type.name === 'Horseman' && strategy === 'BLITZ') {
            const flankTarget = allEnemies.find(e => e.type.name === 'Archer' || e.type.name === 'Melee');
            if(flankTarget) {
                const targetPos = getUnitScreenPosition(flankTarget);
                const currentDist = pointDistance(unitPos, targetPos);
                const afterDist = pointDistance(moveMidPoint, targetPos);
                if(afterDist < currentDist) moveScore += (1 - (afterDist / currentDist)) * 40;
            }
        } else { // Generic advance for others
             const closestEnemy = allEnemies[0];
             if(closestEnemy){
                const targetPos = getUnitScreenPosition(closestEnemy);
                const currentDist = pointDistance(unitPos, targetPos);
                const afterDist = pointDistance(moveMidPoint, targetPos);
                if(afterDist < currentDist) moveScore += (1 - (afterDist / currentDist)) * 20;
             }
        }
        return moveScore;
    };


    // === ACTION GENERATION ===

    // 1. Actions from CURRENT POSITION (no move)
    if (!unit.isFortified) {
        // ATTACK_ONLY
        const attackTargets = getValidMeleeAttackTargets(unit).concat(getValidArcherAttackTargets(unit));
        attackTargets.forEach(targetInfo => {
            possibleActions.push({ type: 'ATTACK_ONLY', unit, targetInfo, score: scoreAttack(targetInfo) });
        });
        // FORTIFY_ONLY
        if (unit.type.canFortify) {
             const edgeCoords = parseEdgeKey(unit.position);
             if (edgeCoords.length === 2 && !isNaN(edgeCoords[0].q)) {
                [getTileKey(edgeCoords[0].q, edgeCoords[0].r), getTileKey(edgeCoords[1].q, edgeCoords[1].r)].forEach(tileKey => {
                    const tile = gameState.tiles.get(tileKey);
                    if(tile && tile.type.canFortify && tile.fortifiedByPlayer === null) {
                         let score = 5 - unit.fortifyCooldown;
                         if(strategy === 'IRON_WALL' && unit.type.name === 'Pikeman') score += 25;
                         if(unit.hp < unit.maxHp) score+=20;
                         if(axialDistance(...tileKey.split(',').map(Number),0,0) > 1) score-= 15;
                         if(score > 0) possibleActions.push({ type: 'FORTIFY_ONLY', unit, targetTileKey: tileKey, score });
                    }
                });
             }
        }
    } else { // Unit is fortified
        // UNFORTIFY_ONLY
        const unfortifyTargets = getPotentialUnfortifyTargets(unit);
        if (unfortifyTargets.length > 0) {
            let score = (unit.hp >= unit.maxHp && unit.turnsFortified > 2) ? (unit.turnsFortified * 5) : 0;
            if(score > 0) possibleActions.push({ type: 'UNFORTIFY_ONLY', unit, targetEdgeKey: unfortifyTargets[0], score });
        }
    }

    // 2. Actions AFTER MOVING
    const possibleMoves = getPossibleMoves(unit);
    possibleMoves.forEach((moveData, edgeKey) => {
        const moveScore = scoreMove(edgeKey);
        const ghostUnit = { ...unit, position: edgeKey, currentMove: unit.currentMove - moveData.cost };

        // MOVE_AND_ATTACK (for Horseman)
        if (ghostUnit.type.name === 'Horseman' && ghostUnit.currentMove >= ATTACK_COST) {
            const attackTargets = getValidMeleeAttackTargets(ghostUnit);
            if (attackTargets.length > 0) {
                const bestTarget = attackTargets.sort((a,b) => scoreAttack(b) - scoreAttack(a))[0];
                const combinedScore = moveScore + scoreAttack(bestTarget);
                possibleActions.push({ type: 'MOVE_AND_ATTACK', unit, moveData, targetInfo: bestTarget, score: combinedScore });
            }
        }
        
        // MOVE_ONLY is always an option
        possibleActions.push({ type: 'MOVE_ONLY', unit, moveData, score: moveScore });
    });
    
    if (possibleActions.length === 0) return null;
    
    // Return the single best action for this unit
    possibleActions.sort((a, b) => b.score - a.score);
    return possibleActions[0];
}


// AI Executor: Takes a chosen action and performs it with animations.
async function executeAIAction(action) {
    if (!action) return;
    console.log(`AI Executing: ${action.type} for ${action.unit.type.name}`, `Score: ${action.score.toFixed(2)}`);
    gameState.selectedUnit = action.unit;
    updateSelectedUnitInfoPanel();
    await delay(400);

    const animateAndMove = async (unit, moveData) => {
        gameState.potentialDebugPathToDraw = moveData.path;
        gameState.debugPathHoverStartTime = Date.now() - PATH_DRAW_HOVER_DELAY_MS;
        await delay(PATH_DRAW_ANIMATION_DURATION_MS + 200);
        handleMoveAction(unit, moveData.path[moveData.path.length - 1], moveData.cost);
    };

    switch (action.type) {
        case 'MOVE_ONLY':
            await animateAndMove(action.unit, action.moveData);
            break;
        case 'ATTACK_ONLY':
            completeAttack(action.unit, action.targetInfo, action.unit.type.attackType === 'melee' ? 'Melee' : 'Archer');
            await delay(800);
            break;
        case 'FORTIFY_ONLY':
            completeFortify(action.unit, action.targetTileKey);
            await delay(600);
            break;
        case 'UNFORTIFY_ONLY':
            completeUnfortify(action.unit, action.targetEdgeKey);
            await delay(700);
            break;
        case 'MOVE_AND_ATTACK':
            await animateAndMove(action.unit, action.moveData);
            await delay(400);
            completeAttack(action.unit, action.targetInfo, action.unit.type.attackType === 'melee' ? 'Melee' : 'Archer');
            await delay(800);
            break;
    }

    gameState.selectedUnit = null;
    updateSelectedUnitInfoPanel();
    await delay(400);
}


// AI Turn Manager: The main loop that commands the AI turn.
async function executeAITurn() {
    if (gameState.gameOver) return;
    console.log(`--- AI Turn ${gameState.globalTurnNumber} (Player ${gameState.currentPlayer}) ---`);

    const aiStrategy = 'IRON_WALL'; // Will be dynamic later
    const allEnemies = gameState.units.filter(u => u.player !== gameState.currentPlayer);
    const allAllies = gameState.units.filter(u => u.player === gameState.currentPlayer);
    
    let unitsToProcess = allAllies.filter(u => !u.hasPerformedMajorAction);

    while (unitsToProcess.length > 0) {
        let bestActionOverall = null;

        for (const unit of unitsToProcess) {
            const bestActionForThisUnit = getUnitAIAction(unit, aiStrategy, allEnemies, allAllies);
            if (bestActionForThisUnit) {
                if (!bestActionOverall || bestActionForThisUnit.score > bestActionOverall.score) {
                    bestActionOverall = bestActionForThisUnit;
                }
            }
        }
        
        if (!bestActionOverall) {
            console.log("AI has no more possible actions.");
            break;
        }

        const actingUnit = bestActionOverall.unit;
        await executeAIAction(bestActionOverall);
        
        // This is the correct way to handle the action attempt.
        actingUnit.hasPerformedMajorAction = true;
        unitsToProcess = unitsToProcess.filter(u => u.id !== actingUnit.id);
    }

    console.log("AI turn finished.");
    if (!gameState.gameOver) {
        ui.endTurnButton.disabled = false;
        ui.endTurnButton.click();
    }
}

function checkArcadeVictoryCondition() {
    const p1HP = gameState.units.filter(u => u.player === 1).reduce((sum, u) => sum + u.hp, 0);
    const p2HP = gameState.units.filter(u => u.player === 2).reduce((sum, u) => sum + u.hp, 0);
    
    let victoryText = "";
    if (p1HP > p2HP) victoryText = "Time Limit! Player 1 Wins by Health!";
    else if (p2HP > p1HP) victoryText = "Time Limit! Player 2 Wins by Health!";
    else victoryText = "Time Limit! It's a Draw!";
    
    ui.victoryMessage.textContent = victoryText;
    ui.victoryMessage.style.display = 'block';
    gameState.gameOver = true;
    ui.endTurnButton.disabled = true;
    triggerConfetti();
    
    // Block interaction immediately
    const interactionBlocker = document.getElementById('victoryInteractionBlocker');
    interactionBlocker.style.display = 'block';
    
    const CONFETTI_DURATION = 7000;
    new Promise(resolve => setTimeout(resolve, CONFETTI_DURATION)).then(() => {
        const restartGameOnClick = () => {
            window.removeEventListener('click', restartGameOnClick);
            window.removeEventListener('touchend', restartGameOnClick);
            interactionBlocker.style.display = 'none';
            location.reload();
        };
        window.addEventListener('click', restartGameOnClick);
        window.addEventListener('touchend', restartGameOnClick);
        showInstruction("Click anywhere to play again.", CONFETTI_DURATION);
    });

    return true;
}

function checkVictoryCondition() {
    if (gameState.gameOver) return true;
    let victoryText = null;

    if (gameState.gameMode === 'arcade') {
        const player1Units = gameState.units.filter(u => u.player === 1);
        const player2Units = gameState.units.filter(u => u.player === 2);
        
        if (gameState.tiles.size > 0) { 
            if (player1Units.length === 0 && player2Units.length > 0) {
                victoryText = "Player 2 Wins by Annihilation!";
            } else if (player2Units.length === 0 && player1Units.length > 0) {
                victoryText = "Player 1 Wins by Annihilation!";
            } else if (player1Units.length === 0 && player2Units.length === 0) {
                victoryText = "It's a Draw!";
            }
        }
    } else {
        // Standard Flag Check
        for (const unit of gameState.units) {
            if (unit.isCarryingFlag) {
                const carrierPlayer = unit.player;
                const carrierHomeBaseEdge = gameState.baseCampPositions[`player${carrierPlayer}`];
                if (unit.position === carrierHomeBaseEdge) {
                    victoryText = `Player ${carrierPlayer} captured the flag and wins!`;
                    break;
                }
            }
        }
        
        // Standard Annihilation Check
        if (!victoryText) {
            const player1Units = gameState.units.filter(u => u.player === 1);
            const player2Units = gameState.units.filter(u => u.player === 2);
            
            if (gameState.tiles.size > 0) { 
                if (player1Units.length === 0 && player2Units.length > 0) {
                    victoryText = "Player 2 Wins by Annihilation!";
                } else if (player2Units.length === 0 && player1Units.length > 0) {
                    victoryText = "Player 1 Wins by Annihilation!";
                } else if (player1Units.length === 0 && player2Units.length === 0) {
                    victoryText = "It's a Draw!";
                }
            }
        }
    }

    if (victoryText) {
        ui.victoryMessage.textContent = victoryText;
        ui.victoryMessage.style.display = 'block';
        triggerConfetti();
        gameState.gameOver = true;
        gameState.currentActionState = ACTION_STATES.IDLE;
        ui.endTurnButton.disabled = true;
        document.getElementById('newMapButton').disabled = false; 
        if (gameState.selectedUnit) {
            ui.actionsPanel.style.display = 'none';
        }
        canvas.style.cursor = 'default'; 
        gameState.selectedUnit = null;
        gameState.currentReachableMoves.clear(); 
        updateSelectedUnitInfoPanel();

        // VICTORY SCREEN LOGIC
        const interactionBlocker = document.getElementById('victoryInteractionBlocker');
        interactionBlocker.style.display = 'block'; // Block interactions immediately

        const CONFETTI_DURATION = 7000;
        new Promise(resolve => setTimeout(resolve, CONFETTI_DURATION)).then(() => {
            
            const restartGameOnClick = () => {
                window.removeEventListener('click', restartGameOnClick);
                window.removeEventListener('touchend', restartGameOnClick);
                interactionBlocker.style.display = 'none'; 
                location.reload();
            };

            window.addEventListener('click', restartGameOnClick);
            window.addEventListener('touchend', restartGameOnClick);

            showInstruction("Click anywhere to play again.", CONFETTI_DURATION);
        });

        return true; // VICTORY!
    }

    // No victory condition met
    document.getElementById('newMapButton').disabled = false;
    return false;
}

        ui.fortifyUnfortifyButton.addEventListener('click', handleFortifyUnfortifyButtonClick);
        ui.buildBridgeButton.addEventListener('click', handleBuildBridgeAction);
        ui.attackButton.addEventListener('click', handleAttackAction);

function proceedToEndTurn() {
    if (gameState.isDragging || gameState.gameOver) return;
    
    // --- ARCADE PHASE CHECK (Block if swap is needed) ---
    if (gameState.gameMode === 'arcade') {
        // Only enforce swap requirement if we are past Turn 1
        if (gameState.globalTurnNumber >= 2) {
            if (gameState.swapState === 'selecting_unit' || gameState.swapState === 'selecting_class') {
                showInstruction("You must swap a unit first!", 2000);
                return; // STOP: Player tried to skip swap
            }
        }
        
        // Check Arcade Turn Limit Victory
        if (gameState.currentPlayer === 2) { // End of round
            gameState.arcadeTotalTurns++;
            if (gameState.arcadeTotalTurns >= ARCADE_MAX_TURNS) {
                checkArcadeVictoryCondition();
                return;
            }
        }
    }

    // --- SWITCH PLAYER ---
    const previousPlayer = gameState.currentPlayer;
    gameState.playerActionTaken[`player${previousPlayer}`] = false;

    gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
    gameState.playerActionTaken[`player${gameState.currentPlayer}`] = false;

    if (previousPlayer === 2 && gameState.currentPlayer === 1) { 
        gameState.globalTurnNumber++;
        updateGlobalTurnDisplay();
    }
    
    // --- RESET SELECTIONS & MOUSE ---
    gameState.selectedUnit = null; 
    gameState.currentReachableMoves.clear();
    gameState.hoveredUnitId = null; 
    canvas.style.cursor = 'default';
    resetActionSelectionStates();
    
    // --- RESET UNITS FOR NEW TURN ---
    gameState.units.forEach(unit => {
        if (unit.player === gameState.currentPlayer) {
            unit.hasPerformedMajorAction = false; 
            let baseMoveForTurn = unit.type.baseMove;
            if (unit.isCarryingFlag) { baseMoveForTurn -= 1; }
            unit.currentMove = Math.max(0, baseMoveForTurn); 
            
            if (unit.isFortified) {
                unit.turnsFortified++;
            } else {
                unit.turnsFortified = 0;
                if (unit.fortifyCooldown > 0) unit.fortifyCooldown = Math.max(0, unit.fortifyCooldown - 5);
            }

            // Check Cowardice (Fortified at base too long)
            const playerBaseTiles = [DEFAULT_FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], DEFAULT_FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
            if (unit.isFortified && playerBaseTiles.includes(unit.fortifiedTileKey)) {
                unit.turnsFortifiedAtBase++;
                if (unit.turnsFortifiedAtBase > MAX_BASE_CAMP_TURNS) {
                    logAction(`P${unit.player} ${unit.type.name} was destroyed for cowardice!`, gameState.currentPlayer);
                    handleUnitDeath(unit, "cowardice");
                }
            }
        }
    });
    
    handleRespawnQueue();
    applyStartOfTurnZoCDamage(); 
    logSiegeStatus();
    applyStartOfTurnHealing(); 
    updateTurnDisplay();
    updateSelectedUnitInfoPanel(); 
    
    // CRITICAL FIX: Update HP display after turn start effects
    updateSupplyPointsDisplay();
    
    // --- ARCADE TIMER RESET & STATE SETUP ---
    if (gameState.gameMode === 'arcade') {
        // 1. RESET THE TIMER
        gameState.arcadeTurnTimer = ARCADE_TURN_TIME_SEC;
        gameState.hasSwappedThisTurn = false; // Reset swap flag

        // 2. SET SWAP PHASE (Only for Turn 2+)
        if (gameState.globalTurnNumber >= 2) {
            gameState.swapState = 'selecting_unit';
            showInstruction(`Player ${gameState.currentPlayer}'s Turn. SELECT UNIT TO SWAP.`, 4000);
        } else {
            gameState.swapState = 'none'; // Turn 1: No swap needed
            showInstruction(`Player ${gameState.currentPlayer}'s turn.`);
        }
    } else {
        showInstruction(`Player ${gameState.currentPlayer}'s turn.`);
    }
    
    logAction(`Player ${gameState.currentPlayer}'s Turn Begins`, gameState.currentPlayer);
    autoSaveGame(true);
    checkVictoryCondition();

    // AI Handling (Singleplayer)
    if (!gameState.gameOver && gameState.gameMode === 'singleplayer' && gameState.currentPlayer !== gameState.playerSide) {
        ui.endTurnButton.disabled = true;
        setTimeout(() => { executeAITurn(); }, 1500);
    } else {
        ui.endTurnButton.disabled = false;
    }
}

ui.endTurnButton.addEventListener('click', () => {
    if (gameState.mapMakerMode) {
        // --- Clear Map Functionality ---
        document.getElementById('customConfirmMessage').textContent = 'Are you sure you want to clear the entire map? This cannot be undone.';
        currentConfirmAction = clearMapForMaker;
        
        if (ui.customConfirmModal) {
            ui.customConfirmModal.style.display = 'flex';
            setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
        }
    } else {
        // --- Original End Turn Functionality ---
        const playerHasActed = gameState.playerActionTaken[`player${gameState.currentPlayer}`];

        if (playerHasActed || !gameSettings.passTurnConfirmationEnabled || gameState.gameOver) {
            proceedToEndTurn();
        } else {
            document.getElementById('customConfirmMessage').textContent = 'You have not performed any actions. Are you sure you want to end your turn?';
            currentConfirmAction = proceedToEndTurn;
            
            if (ui.customConfirmModal) {
                ui.customConfirmModal.style.display = 'flex';
                setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
            }
        }
    }
});

document.getElementById('customMapButton').addEventListener('click', () => {
    hideNewMapModal();

    if (gameState.mapMakerMode) {
        // This is the "Return to Game" functionality
        setTimeout(() => {
            exitMapMakerMode();
            initializeGrid(); 
            showInstruction("New Local Multiplayer game started.", 3000);
        }, 350); // Timeout to allow modal to close
    } else {
        // This is the original "Custom Map" functionality
        setTimeout(() => {
            enterMapMakerMode();
        }, 350);
    }
});

document.getElementById('selectMapButton').addEventListener('click', showSelectMapView);

// Replaces the old "Generate Map" button listener
document.getElementById('newMapButton').addEventListener('click', () => {
    const generateButton = document.getElementById('generateMapFromModalButton');
    const customMapButton = document.getElementById('customMapButton');

    if (gameState.mapMakerMode || gameState.gameMode === 'singleplayer') {
        generateButton.disabled = true;
    } else {
        generateButton.disabled = false;
    }

    if (gameState.mapMakerMode) {
        customMapButton.textContent = 'Return to Game';
        customMapButton.classList.add('return-to-game-button');
    } else {
        customMapButton.textContent = 'Custom Map';
        customMapButton.classList.remove('return-to-game-button');
    }
    showNewMapModal();
});
// --- New Map Modal Listeners ---
const newMapModalOverlay = document.getElementById('newMapModal');

// Click outside to close
newMapModalOverlay.addEventListener('click', (event) => {
    if (event.target === newMapModalOverlay) {
        hideNewMapModal();
    }
});

// 'x' button to close
document.getElementById('newMapModalCloseButton').addEventListener('click', hideNewMapModal);

// "Generate Map" button inside the modal
document.getElementById('generateMapFromModalButton').addEventListener('click', () => {
    // Hide the New Map modal before showing the confirmation.
    hideNewMapModal();

    // Show a confirmation modal.
    const confirmModal = document.getElementById('customConfirmModal');
    const confirmMessage = document.getElementById('customConfirmMessage');
    const okButton = document.getElementById('customConfirmOkButton');
    const cancelButton = document.getElementById('customConfirmCancelButton');

    confirmMessage.textContent = 'Are you sure you want to generate a new map? This will reset the current game.';

    // Create temporary, single-use event listeners
    const onConfirm = () => {
        // If confirmed, generate the map and close the confirm modal.
        handleGenerateNewMap();
        confirmModal.classList.remove('modal-visible');
        setTimeout(() => confirmModal.style.display = 'none', 300);
        
        // Clean up listeners
        okButton.removeEventListener('click', onConfirm);
        cancelButton.removeEventListener('click', onCancel);
    };

    const onCancel = () => {
        // If cancelled, close the confirm modal AND re-open the New Map modal.
        confirmModal.classList.remove('modal-visible');
        setTimeout(() => confirmModal.style.display = 'none', 300);
        
        // Re-show the New Map modal after a short delay to allow the confirm modal to close.
        setTimeout(() => {
            showNewMapModal();
        }, 350);
        
        // Clean up listeners
        okButton.removeEventListener('click', onConfirm);
        cancelButton.removeEventListener('click', onCancel);
    };

    okButton.addEventListener('click', onConfirm, { once: true });
    cancelButton.addEventListener('click', onCancel, { once: true });

    if (confirmModal) {
        confirmModal.style.display = 'flex';
        setTimeout(() => confirmModal.classList.add('modal-visible'), 10);
    }
});

ui.customConfirmOkButton.addEventListener('click', () => {
            if (ui.customConfirmModal) {
                ui.customConfirmModal.classList.remove('modal-visible');
                setTimeout(() => ui.customConfirmModal.style.display = 'none', 300); 
            }
            // Execute the action that was stored when the modal was opened
            if (typeof currentConfirmAction === 'function') {
                currentConfirmAction();
                currentConfirmAction = null; // Clear the action after using it
            }
            currentCancelAction = null; // NEW: Clear any pending cancel action since we confirmed
        });

        ui.customConfirmCancelButton.addEventListener('click', () => {
             if (ui.customConfirmModal) {
                ui.customConfirmModal.classList.remove('modal-visible');
                setTimeout(() => ui.customConfirmModal.style.display = 'none', 300); 
            }
            // NEW: Execute cancel action (revert slider)
            if (typeof currentCancelAction === 'function') {
                currentCancelAction();
                currentCancelAction = null;
            }
        });

        const customConfirmModalOverlay = document.getElementById('customConfirmModal');
        customConfirmModalOverlay.addEventListener('click', (event) => {
            if (event.target === customConfirmModalOverlay) {
                if (ui.customConfirmModal) {
                    ui.customConfirmModal.classList.remove('modal-visible');
                    setTimeout(() => ui.customConfirmModal.style.display = 'none', 300);
                    currentConfirmAction = null; 
                    
                    // NEW: Execute cancel action (revert slider) on outside click
                    if (typeof currentCancelAction === 'function') {
                        currentCancelAction();
                        currentCancelAction = null;
                    }
                }
            }
        });

document.getElementById('saveGameButton').addEventListener('click', () => {
    if (gameState.mapMakerMode) {
        // Save Map logic
        const mapData = createMapDataObject();
        const mapString = JSON.stringify(mapData, null, 2);
        const blob = new Blob([mapString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `FortHex-Map-${Date.now()}.fhmap`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showInstruction("Map file saved!", 2500);
    } else {
        // Original Save Game logic
        saveGameToFile();
    }
});
document.getElementById('loadGameButton').addEventListener('click', () => {
    // Set the context based on the current mode before showing the modal.
    fileLoadContext = gameState.mapMakerMode ? 'edit_map' : 'game_save';
    showLoadGameModal();
});

function handleGenerateNewMap() {
             gameState.isDragging = false; 
             gameState.draggingUnit = null;
            
            // 1. Generate the map tiles
            const newLayout = generateImprovedMap(gameState.gridRadius);
            
            // 2. Initialize the grid with these tiles
            initializeGrid(newLayout); 
            
            // 3. Explicitly update base camp positions based on the current slider and radius
            // This ensures the game logic matches the visual map size.
            const sliderVal = document.getElementById('baseCampSlider').value;
            updateBaseCampLocations(sliderVal);
            
            showInstruction("New map generated. Player 1's Turn.", 3000);
        }

function startSingleplayerGame(playerSide) {
    exitMapMakerMode(); 
    hideAllModals(); 
    
    // Set the game mode state
    gameState.gameMode = 'singleplayer';
    gameState.playerSide = playerSide;

    // --- FIX: Reset Map Dimensions for Standard Play ---
    gameState.gridRadius = 3;
    gameState.renderScale = 1.0;
    gameState.renderOffset = { x: 0, y: 0 };
    // ---------------------------------------------------

    // Force the default map for singleplayer
    initializeGrid(DEFAULT_MAP_LAYOUT_RADIUS_3);
    showInstruction(`Singleplayer game started. You are Player ${playerSide}.`, 3000);
    // If the human chose to be P2, the AI (P1) must take the first turn.
    if (gameState.playerSide === 2) {
        console.log("Player is P2, triggering AI's first turn.");
        ui.endTurnButton.disabled = true; // Disable button during AI turn
        setTimeout(() => {
            executeAITurn();
        }, 1500); // Wait a moment before AI starts
    }
}

function autoSaveGame(isSilent = false) {
    if (gameState.isDragging) {
        showInstruction("Cannot save while dragging a unit.", 2000);
        return;
    }

    if (gameState.isDragging) {
        showInstruction("Cannot save while dragging a unit.", 2000);
        return;
    }

    try {
        // Create a temporary, serializable version of the game state
        const serializableState = { ...gameState };
        
        // Manually convert Map objects to arrays for JSON compatibility
        serializableState.tiles = Array.from(gameState.tiles.entries());
        serializableState.edges = Array.from(gameState.edges.entries());
        serializableState.currentReachableMoves = Array.from(gameState.currentReachableMoves.entries());

        serializableState.saveVersion = BUILD_VERSION; 

        const gameStateString = JSON.stringify(serializableState);
        const saveKey = gameState.gameMode === 'singleplayer' ? 'forthexSaveGame_sp' : 'forthexSaveGame';
        localStorage.setItem(saveKey, gameStateString);
        if (!isSilent) { showInstruction("Game Saved!", 2000); }
        console.log("Game state saved to localStorage.");
    } catch (error) {
        console.error("Error saving game state:", error);
        showInstruction("Could not save game. See console for details.", 3000);
    }
}

function saveGameToFile() {
    // --- Create the custom filename ---
    const now = new Date();
    const day = padZero(now.getDate());
    const month = padZero(now.getMonth() + 1); // JS months are 0-indexed
    const year = now.getFullYear();
    const hours = padZero(now.getHours());
    const minutes = padZero(now.getMinutes());
    const seconds = padZero(now.getSeconds());
    const modePrefix = gameState.gameMode === 'singleplayer' ? 'SP-' : '';
    const fileName = `FortHex-${BUILD_VERSION}-${modePrefix}SaveGame-${day}.${month}.${year}-${hours}:${minutes}:${seconds}.fhsave`;

    try {
        // --- Serialize the game state (same as autosave) ---
        const serializableState = { ...gameState };
        serializableState.tiles = Array.from(gameState.tiles.entries());
        serializableState.edges = Array.from(gameState.edges.entries());
        serializableState.currentReachableMoves = Array.from(gameState.currentReachableMoves.entries());
        serializableState.saveVersion = BUILD_VERSION;
        const gameStateString = JSON.stringify(serializableState, null, 2); // Using indentation for readability

        // --- Trigger the file download ---
        const blob = new Blob([gameStateString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showInstruction("Save file downloaded!", 2500);

    } catch (error) {
        console.error("Error saving game to file:", error);
        showInstruction("Could not create save file. See console.", 3000);
    }
}

function showLoadGameModal() {
    const modal = document.getElementById('loadGameModal');
    if (!modal) return;

    // Dynamically set the text content of the buttons based on the current mode.
    const autosaveBtn = document.getElementById('loadFromAutosaveButton');
    const fileBtn = document.getElementById('loadFromFileButton');
    const fileInput = document.getElementById('fileLoaderInput');
    
    if (gameState.mapMakerMode) {
        autosaveBtn.textContent = "Load Autosave Map";
        fileBtn.textContent = "Load Map File";
        // Accept only .fhmap files
        fileInput.accept = ".fhmap";
    } else {
        autosaveBtn.textContent = "Load Autosave";
        fileBtn.textContent = "Load Save File";
        // Accept game saves (and json as a fallback)
        fileInput.accept = ".fhsave, .json";
    }

    modal.style.display = 'flex';
    setTimeout(() => modal.classList.add('modal-visible'), 10);
}

function hideLoadGameModal() {
const modal = document.getElementById('loadGameModal');
if (modal) {
modal.classList.remove('modal-visible');
setTimeout(() => modal.style.display = 'none', 300);
}
}



function hideAllModals() {
    document.querySelectorAll('.modal-overlay').forEach(modal => {
        modal.classList.remove('modal-visible');
        setTimeout(() => modal.style.display = 'none', 300);
    });
}

function showNewMapModal() {
const modal = document.getElementById('newMapModal');
if (modal) {
modal.style.display = 'flex';
setTimeout(() => modal.classList.add('modal-visible'), 10);
}
}

function hideNewMapModal() {
    const modal = document.getElementById('newMapModal');
    if (modal) {
        modal.classList.remove('modal-visible');
        setTimeout(() => {
            modal.style.display = 'none';
            // After the modal is hidden, reset it to the default view
            // so it opens correctly the next time.
            showDefaultNewMapView();
        }, 300); // The timeout matches the modal's hide transition.
    }
}

function showSelectMapView() {
    const modalContent = document.querySelector('#newMapModal .modal-content');
    if (!modalContent) return;

    modalContent.querySelector('h3').style.display = 'none';
    document.getElementById('newMapOptionsContainer').style.display = 'none';

    let selectMapView = document.getElementById('selectMapView');
    if (!selectMapView) {
        selectMapView = document.createElement('div');
        selectMapView.id = 'selectMapView';

        const title = document.createElement('h3');
        title.textContent = 'Select Map';
        title.style.cssText = "font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;";
        
        const presetContainer = document.createElement('div');
        presetContainer.style.cssText = "display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-bottom: 25px;";

        const createPresetCard = (mapData) => {
            const wrapper = document.createElement('div');
            wrapper.style.cssText = "cursor: pointer; border: 2px solid #4a6075; border-radius: 8px; padding: 10px; transition: border-color 0.2s; display: flex; flex-direction: column; align-items: center; gap: 5px; background-color: var(--bg-color);";
            wrapper.onclick = () => {
                hideAllModals();
                loadPresetMap(mapData);
            };
            wrapper.onmouseover = () => { wrapper.style.borderColor = '#FFC020'; };
            wrapper.onmouseout = () => { wrapper.style.borderColor = '#4a6075'; };

            const canvas = document.createElement('canvas');
            canvas.width = 140;
            canvas.height = 120;
            
            const label = document.createElement('span');
            label.textContent = mapData.name;
            label.style.fontWeight = 'bold';
            label.style.color = '#F0F0F0';
            
            wrapper.appendChild(canvas);
            wrapper.appendChild(label);
            
            renderMapPreview(canvas, mapData);
            
            return wrapper;
        };

        presetContainer.appendChild(createPresetCard(PRESET_MAP_1));
        presetContainer.appendChild(createPresetCard(PRESET_MAP_2));

        const buttonsContainer = document.createElement('div');
        buttonsContainer.className = 'modal-buttons';

        const backButton = document.createElement('button');
        backButton.className = 'action-button action-button-cancel';
        backButton.textContent = 'Back';
        backButton.addEventListener('click', showDefaultNewMapView);

        const loadMapButton = document.createElement('button');
        loadMapButton.className = 'action-button';
        loadMapButton.textContent = 'Load Map File';
        loadMapButton.addEventListener('click', () => {
            fileLoadContext = 'play_map';
            document.getElementById('fileLoaderInput').accept = ".fhmap";
            document.getElementById('fileLoaderInput').click();
        });

        buttonsContainer.appendChild(backButton);
        buttonsContainer.appendChild(loadMapButton);
        
        selectMapView.appendChild(title);
        selectMapView.appendChild(presetContainer);
        selectMapView.appendChild(buttonsContainer);
        modalContent.appendChild(selectMapView);
    }
    selectMapView.style.display = 'block';
}

function showDefaultNewMapView() {
    const modalContent = document.querySelector('#newMapModal .modal-content');
    if (!modalContent) return;
    
    const selectMapView = document.getElementById('selectMapView');
    if (selectMapView) {
        selectMapView.style.display = 'none';
    }

    modalContent.querySelector('h3').style.display = 'block';
    document.getElementById('newMapOptionsContainer').style.display = 'flex';
}

function renderMapPreview(canvas, mapData) {
    const ctx = canvas.getContext('2d');
    const radius = 3;
    const size = 8; // Small hex size for preview
    const width = canvas.width;
    const height = canvas.height;
    ctx.clearRect(0, 0, width, height);

    const baseCamps = [
        ...parseEdgeKey(mapData.baseCampPositions.player1),
        ...parseEdgeKey(mapData.baseCampPositions.player2)
    ].map(c => getTileKey(c.q, c.r));

    mapData.tiles.forEach((tileType, key) => {
        const [q, r] = key.split(',').map(Number);
        const x = size * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + width / 2;
        const y = size * (3 / 2 * r) + height / 2;
        
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = Math.PI / 180 * (60 * i - 30);
            const vx = x + size * Math.cos(angle);
            const vy = y + size * Math.sin(angle);
            if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
        }
        ctx.closePath();
        
        let fillColor;
        if (baseCamps.includes(key)) {
            const isP1Base = parseEdgeKey(mapData.baseCampPositions.player1).some(c => getTileKey(c.q, c.r) === key);
            fillColor = isP1Base ? TEAM_COLORS.player1.primary : TEAM_COLORS.player2.primary;
        } else {
             switch (tileType) {
                case TILE_TYPES.MOUNTAIN: fillColor = '#808080'; break;
                case TILE_TYPES.FOREST: fillColor = '#208020'; break;
                case TILE_TYPES.WATER: fillColor = '#80C0E0'; break;
                default: fillColor = '#90E090'; break;
            }
        }
        ctx.fillStyle = fillColor;
        ctx.fill();
    });
}

function loadPresetMap(mapData) {
    console.group("--- LOADING PRESET MAP: " + mapData.name + " ---");
    console.log("[DEBUG] Map Data received:", mapData);

    try {
        exitMapMakerMode();
        hideAllModals();

        // Resize grid logic
        if (mapData.radius) {
            console.log(`[DEBUG] Resizing grid to Radius ${mapData.radius} for preset.`);
            resizeMapGrid(mapData.radius);
        } else {
            console.log(`[DEBUG] No radius in preset, defaulting to 3.`);
            resizeMapGrid(3);
        }

        console.log("[DEBUG] Calling initializeGrid...");
        initializeGrid(mapData.tiles, mapData.units);
        
        gameState.baseCampPositions = mapData.baseCampPositions;
        
        if (gameState.flags && mapData.baseCampPositions.player1) {
            gameState.flags.p1_flag.homePosition = mapData.baseCampPositions.player1;
            gameState.flags.p2_flag.homePosition = mapData.baseCampPositions.player2;
        }

        showInstruction(`Preset map '${mapData.name}' loaded. Player 1's turn.`, 4000);
        console.log("[DEBUG] Preset load complete.");
    } catch (error) {
        console.error("[CRITICAL FAILURE] loadPresetMap crashed:", error);
        alert("Error loading preset map. Check console.");
    }
    console.groupEnd();
}

function loadAutoSave() {
    if (gameState.mapMakerMode) {
        // Load Map Autosave
        const savedMapString = localStorage.getItem(MAP_MAKER_AUTOSAVE_KEY);
        if (!savedMapString) {
            showInstruction("No autosaved map found.", 2000);
            return;
        }
        try {
            const mapData = JSON.parse(savedMapString);
            loadMapFromDataObject(mapData);
        } catch (error) {
            console.error("Error loading map autosave:", error);
            showInstruction("Could not load autosaved map.", 3000);
        }
    } else {
        // Original Load Game Autosave
        const saveKey = gameState.gameMode === 'singleplayer' ? 'forthexSaveGame_sp' : 'forthexSaveGame';
        const savedStateString = localStorage.getItem(saveKey);
        if (!savedStateString) {
            showInstruction("No saved game found.", 2000);
            return;
        }
        try {
            const loadedState = JSON.parse(savedStateString);
            if (loadedState.saveVersion !== BUILD_VERSION) {
                showInstruction("Save file is from an incompatible version.", 3000);
                return;
            }
            gameState = loadedState;
            rehydrateGameState();
            fullGameRedraw();
            showInstruction("Game Loaded.", 2000);
        } catch (error) {
            console.error("Error loading game state:", error);
            showInstruction("Could not load save data. It may be corrupted.", 3000);
        }
    }
}

        function rehydrateGameState() {
            // Converts loaded data from simple arrays back into live objects/maps
            gameState.tiles = new Map(gameState.tiles);
            gameState.edges = new Map(gameState.edges);
            gameState.currentReachableMoves = gameState.currentReachableMoves ? new Map(gameState.currentReachableMoves) : new Map();

            for (const tile of gameState.tiles.values()) {
                if (tile.type && tile.type.name) {
                    tile.type = TILE_TYPES[tile.type.name.toUpperCase()];
                }
            }
            for (const unit of gameState.units) {
                if (unit.type && unit.type.name) {
                    unit.type = UNIT_TYPES[unit.type.name.toUpperCase()];
                }
            }
            for (const edge of gameState.edges.values()) {
                edge.units = [];
            }
            for (const unit of gameState.units) {
                if (unit.positionType === 'edge') {
                    const edge = gameState.edges.get(unit.position);
                    if (edge) edge.units.push(unit);
                }
            }
        }

function createMapDataObject() {
    const mapData = {
        saveVersion: BUILD_VERSION,
        radius: gameState.gridRadius, // ADDED THIS LINE
        tiles: Array.from(gameState.tiles.entries()),
        units: gameState.units.map(u => ({
            player: u.player,
            typeName: u.type.name,
            position: u.position
        })),
        baseCampPositions: gameState.baseCampPositions
    };
    return mapData;
}

function loadMapFromDataObject(mapData) {
    if (!mapData || mapData.saveVersion !== BUILD_VERSION) {
        showInstruction("Map data is invalid or from an incompatible version.", 3000);
        return false;
    }

    // Enter map maker mode if not already in it
    if (!gameState.mapMakerMode) {
        enterMapMakerMode();
    }

    // 1. Determine Radius
    // If the file has a radius, use it. If not (legacy file), infer it from the furthest tile.
    let loadedRadius = mapData.radius;
    if (!loadedRadius) {
        let maxCoord = 0;
        mapData.tiles.forEach(([key]) => {
            const [q, r] = key.split(',').map(Number);
            const dist = Math.max(Math.abs(q), Math.abs(r), Math.abs(-q - r));
            if (dist > maxCoord) maxCoord = dist;
        });
        loadedRadius = maxCoord || 3;
    }

    // 2. Resize to match loaded map size
    // This sets the correct render scale, mode (Arcade vs Local), and grid boundaries.
    resizeMapGrid(loadedRadius);

    // 3. Clear and Repopulate
    // resizeMapGrid clears the board, but we explicitly ensure units are empty before pushing loaded ones.
    gameState.units = [];
    gameState.tiles.clear();
    gameState.edges.forEach(edge => edge.units = []);

    // Load tiles
    mapData.tiles.forEach(([key, tile]) => {
        const rehydratedTile = { ...tile,
            type: TILE_TYPES[tile.type.name.toUpperCase()]
        };
        gameState.tiles.set(key, rehydratedTile);
    });

    // Load units
    mapData.units.forEach(unitInfo => {
        const newUnit = createUnit(unitInfo.player, UNIT_TYPES[unitInfo.typeName.toUpperCase()], unitInfo.position);
        gameState.units.push(newUnit);
        const edge = gameState.edges.get(unitInfo.position);
        if (edge) {
            edge.units.push(newUnit);
        } else {
            console.error("Failed to place loaded unit on edge:", unitInfo.position);
        }
    });

    // 4. Restore Base Camp Logic & UI
    gameState.baseCampPositions = mapData.baseCampPositions;
    gameState.flags.p1_flag.homePosition = mapData.baseCampPositions.player1;
    gameState.flags.p2_flag.homePosition = mapData.baseCampPositions.player2;

    // Determine the correct slider value that corresponds to the loaded base camp data.
    const sliderToRotations = [3, 2, 1, 0, -1, -2];
    let matchingSliderValue = '3'; // Default to 0-degree rotation

    // Only attempt to match rotation if a base camp actually exists (not null like in Arcade maps)
    if (mapData.baseCampPositions.player1) {
        for (let i = 0; i < sliderToRotations.length; i++) {
            const rotations = sliderToRotations[i];
            const p1_default = parseEdgeKey(DEFAULT_FLAG_HOME_POSITIONS.player1);
            const p1_h1_rotated = rotateAxial(p1_default[0].q, p1_default[0].r, rotations);
            const p1_h2_rotated = rotateAxial(p1_default[1].q, p1_default[1].r, rotations);
            const testEdgeKey = getEdgeKey(p1_h1_rotated.q, p1_h1_rotated.r, p1_h2_rotated.q, p1_h2_rotated.r);

            if (testEdgeKey === mapData.baseCampPositions.player1) {
                matchingSliderValue = i.toString();
                break; // Found the matching rotation, exit the loop.
            }
        }
    }

    // Set the slider's visual position to match the loaded data.
    const bcSlider = document.getElementById('baseCampSlider');
    if (bcSlider) bcSlider.value = matchingSliderValue;

    showInstruction("Map loaded successfully!", 2000);
    return true;
}

function autoSaveMap() {
    if (!gameState.mapMakerMode) return;
    try {
        const mapData = createMapDataObject();
        localStorage.setItem(MAP_MAKER_AUTOSAVE_KEY, JSON.stringify(mapData));
        console.log("Map autosaved to localStorage.");
    } catch (error) {
        console.error("Error autosaving map:", error);
    }
}

function fullGameRedraw() {
            // This function re-initializes the game's UI and re-renders the canvas from the current gameState.
            
            // --- FIX: Use FIXED canvas dimensions ---
            canvas.width = CANVAS_WIDTH_NORMAL;
            canvas.height = CANVAS_HEIGHT_NORMAL;
            document.querySelectorAll('.ui-panel').forEach(panel => { panel.style.minHeight = canvas.height + 'px'; });
            // ----------------------------------------

            // Reset any non-persistent state properties that might affect drawing
            gameState.isDragging = false;
            gameState.draggingUnit = null;
            gameState.hoveredUnitId = null;

            // Update all UI panels with current data
            updateTurnDisplay();
            updateGlobalTurnDisplay();
            updateSupplyPointsDisplay();
            updateRespawnQueueDisplay();
            updateActionLogDisplay();
            updateSelectedUnitInfoPanel();

            if (gameState.gameOver) {
                ui.endTurnButton.disabled = true;
                ui.actionsPanel.style.display = 'none';
                ui.victoryMessage.textContent = "Game Over (Loaded)";
                ui.victoryMessage.style.display = 'block';
            } else {
                ui.victoryMessage.style.display = 'none';
                ui.endTurnButton.disabled = false;
            }
            // A single call to gameLoop will trigger a full redraw of the canvas
            requestAnimationFrame(gameLoop);
        }

// ========================================================================
// --- NEW IMPROVED MAP GENERATOR (V3 - Corrected) ---
// ========================================================================

function generateImprovedMap(radius) {
    const tempTiles = new Map();
    const allHexCoords = [];
    for (let q = -radius; q <= radius; q++) {
        for (let r = -radius; r <= radius; r++) {
            if (Math.abs(q + r) <= radius) {
                allHexCoords.push({ q, r });
            }
        }
    }

    // Helper for radius checking within this scope
    const checkRadius = (key) => {
        const [q, r] = key.split(',').map(Number);
        return Math.abs(q) <= radius && Math.abs(r) <= radius && Math.abs(q + r) <= radius;
    };

    // --- 1. Define Base Area Keys ---
    const p1BaseQ = -radius;
    const p1BaseR = 1; 
    const p2BaseQ = radius;
    const p2BaseR = -1;

    const p1StartNode = getTileKey(p1BaseQ, p1BaseR);
    const p2EndNode = getTileKey(p2BaseQ, p2BaseR);

    const p1BaseAreaKeys = new Set([p1StartNode]);
    const p2BaseAreaKeys = new Set([p2EndNode]);

    const addNeighborsToSet = (centerQ, centerR, set) => {
        getNeighbors(centerQ, centerR).forEach(n => {
            const key = getTileKey(n.q, n.r);
            if (checkRadius(key)) set.add(key);
        });
    };

    addNeighborsToSet(p1BaseQ, p1BaseR, p1BaseAreaKeys);
    addNeighborsToSet(p2BaseQ, p2BaseR, p2BaseAreaKeys);

    // --- 2. Generate Water Archetype ---
    const archetypes = ['coastline', 'river'];
    const chosenArchetype = archetypes[Math.floor(Math.random() * archetypes.length)];
    console.log(`Generating map (R=${radius}) with archetype: ${chosenArchetype}`);

    if (chosenArchetype === 'coastline') {
        const side = Math.floor(Math.random() * 6);
        const direction = AXIAL_DIRECTIONS[side];
        allHexCoords.forEach(coord => {
            const projection = coord.q * direction.q + coord.r * direction.r;
            if (projection >= radius - 1) {
                tempTiles.set(getTileKey(coord.q, coord.r), TILE_TYPES.WATER);
            }
        });
    } else if (chosenArchetype === 'river') {
        // River logic adapted for dynamic radius
        const edgeCoords = allHexCoords.filter(c => axialDistance(c.q, c.r, 0, 0) === radius);
        let current = edgeCoords[Math.floor(Math.random() * edgeCoords.length)];
        let riverPath = new Set();
        
        for(let i = 0; i < radius * 2.5; i++) {
             const key = getTileKey(current.q, current.r);
             if(riverPath.has(key)) break;
             riverPath.add(key);
             tempTiles.set(key, TILE_TYPES.WATER);

             const neighbors = getNeighbors(current.q, current.r).filter(n => checkRadius(getTileKey(n.q, n.r)));
             if(neighbors.length > 0 && Math.random() > 0.4) {
                 const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
                 const neighborKey = getTileKey(randomNeighbor.q, randomNeighbor.r);
                 if(!riverPath.has(neighborKey)) {
                     riverPath.add(neighborKey);
                     tempTiles.set(neighborKey, TILE_TYPES.WATER);
                 }
             }
             
             let bestNeighbor = null;
             let maxDist = -Infinity;
             for(const n of neighbors) {
                 const dist = -1 * (n.q * current.q + n.r * current.r);
                 if (dist > maxDist) { maxDist = dist; bestNeighbor = n; }
             }
             if (bestNeighbor) current = bestNeighbor; else break;
        }
    }

    // --- 3. Generate Mountains ---
    allHexCoords.forEach(coord => {
        const key = getTileKey(coord.q, coord.r);
        if (!tempTiles.has(key) && Math.random() < 0.18) {
            tempTiles.set(key, TILE_TYPES.MOUNTAIN);
        }
    });

    // --- 4. Guarantee Two Paths ---
    // Pass 'radius' to findAndCarvePath so it knows bounds
    findAndCarvePath(p1StartNode, p2EndNode, tempTiles, [], radius);
    // Try for a second path
    const firstPath = findAndCarvePath(p1StartNode, p2EndNode, tempTiles, [], radius); 
    if (firstPath) {
        findAndCarvePath(p1StartNode, p2EndNode, tempTiles, firstPath, radius);
    }

    // --- 5. Fill Remaining ---
    allHexCoords.forEach(coord => {
        const key = getTileKey(coord.q, coord.r);
        if (!tempTiles.has(key)) {
            tempTiles.set(key, Math.random() < 0.45 ? TILE_TYPES.FOREST : TILE_TYPES.PLAINS);
        }
    });

    // --- 6. Force Base Areas ---
    p1BaseAreaKeys.forEach(key => tempTiles.set(key, TILE_TYPES.PLAINS));
    p2BaseAreaKeys.forEach(key => tempTiles.set(key, TILE_TYPES.PLAINS));

    return tempTiles;
}

// Updated helper to accept radius
function findAndCarvePath(startKey, endKey, tiles, excludedKeys = [], radius) {
    let openSet = [startKey];
    const cameFrom = new Map();
    const gScore = new Map(); gScore.set(startKey, 0);
    const fScore = new Map();
    const [sq, sr] = startKey.split(',').map(Number);
    const [eq, er] = endKey.split(',').map(Number);
    fScore.set(startKey, axialDistance(sq, sr, eq, er));
    const excludedSet = new Set(excludedKeys);

    const checkRadius = (key) => {
        const [q, r] = key.split(',').map(Number);
        return Math.abs(q) <= radius && Math.abs(r) <= radius && Math.abs(q + r) <= radius;
    };

    while (openSet.length > 0) {
        let currentKey = openSet.sort((a, b) => (fScore.get(a) || Infinity) - (fScore.get(b) || Infinity))[0];
        if (currentKey === endKey) return reconstructPath(cameFrom, currentKey);

        openSet = openSet.filter(key => key !== currentKey);
        const [cq, cr] = currentKey.split(',').map(Number);
        const neighbors = getNeighbors(cq, cr).map(n => getTileKey(n.q, n.r));

        for (const neighborKey of neighbors) {
            if (!checkRadius(neighborKey)) continue; // Check bounds
            const tile = tiles.get(neighborKey);
            // Treat undefined tiles as passable (will be filled later)
            const isPassable = tile !== TILE_TYPES.WATER && tile !== TILE_TYPES.MOUNTAIN;
            if (excludedSet.has(neighborKey)) continue;

            if (isPassable || !tile) {
                const tentative_gScore = (gScore.get(currentKey) || Infinity) + 1;
                if (tentative_gScore < (gScore.get(neighborKey) || Infinity)) {
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentative_gScore);
                    const [nq, nr] = neighborKey.split(',').map(Number);
                    fScore.set(neighborKey, tentative_gScore + axialDistance(nq, nr, eq, er));
                    if (!openSet.includes(neighborKey)) openSet.push(neighborKey);
                }
            }
        }
    }

    // Carve logic
    console.log("Carving path...");
    let carvePath = [startKey];
    let currentCarveKey = startKey;
    for (let i = 0; i < 100; i++) {
        if (currentCarveKey === endKey) break;
        const [ccq, ccr] = currentCarveKey.split(',').map(Number);
        const neighbors = getNeighbors(ccq, ccr)
                            .map(n => ({ key: getTileKey(n.q, n.r), q: n.q, r: n.r }))
                            .filter(n => checkRadius(n.key));
        
        let nextStep = neighbors.sort((a,b) => axialDistance(a.q, a.r, eq, er) - axialDistance(b.q, b.r, eq, er))[0];
        if (!nextStep) return null;
        
        if (tiles.get(nextStep.key) === TILE_TYPES.WATER || tiles.get(nextStep.key) === TILE_TYPES.MOUNTAIN) {
            tiles.set(nextStep.key, TILE_TYPES.PLAINS);
        }
        currentCarveKey = nextStep.key;
        carvePath.push(currentCarveKey);
    }
    return carvePath;
}

/** Reconstructs a path from the 'cameFrom' map of an A* search. */
function reconstructPath(cameFrom, currentKey) {
    const totalPath = [currentKey];
    while (cameFrom.has(currentKey)) {
        currentKey = cameFrom.get(currentKey);
        totalPath.unshift(currentKey);
    }
    return totalPath;
}

/** Checks if a given hex coordinate key is within the map radius */
function isCoordInRadius(key, radius) {
    const [q, r] = key.split(',').map(Number);
    if (isNaN(q) || isNaN(r)) return false;
    return Math.abs(q) <= radius && Math.abs(r) <= radius && Math.abs(q + r) <= radius;
}

function placeUnitsOnNewGeneratedMap(unitLimit = getMaxUnitsForCurrentMap()) {
            const landEdges = [];
            gameState.edges.forEach((edgeData, edgeKey) => {
                // Use the new, more accurate isRoad() definition
                if (isRoad(edgeKey)) {
                    landEdges.push(edgeKey);
                }
            });

            if (landEdges.length < unitLimit * 2) {
                console.error(`CRITICAL: Not enough land edges (${landEdges.length}). Placing randomly.`);
                landEdges.sort(() => 0.5 - Math.random());
                const usedEdgesFallback = new Set();
                const allUnitTypes = [UNIT_TYPES.MELEE, UNIT_TYPES.ARCHER, UNIT_TYPES.PIKEMAN, UNIT_TYPES.HORSEMAN];

                const placeFallbackTeam = (player) => {
                    // Place up to unitLimit
                    for (let i = 0; i < unitLimit; i++) {
                        let placed = false;
                        // Cycle through unit types if limit > 4, or just pick first few
                        const typeToPlace = allUnitTypes[i % allUnitTypes.length];
                        
                        for (const edgeKey of landEdges) {
                            if (!usedEdgesFallback.has(edgeKey)) {
                                gameState.units.push(createUnit(player, typeToPlace, edgeKey));
                                usedEdgesFallback.add(edgeKey);
                                placed = true;
                                break;
                            }
                        }
                        if (!placed) console.error(`Could not place P${player} ${typeToPlace.name}`);
                    }
                };
                placeFallbackTeam(1);
                placeFallbackTeam(2);
            } else {
                const p1CandidateEdges = [];
                const p2CandidateEdges = [];
                const hemisphereThresholdQ = 0;
                landEdges.forEach(edgeKey => {
                    const coords = parseEdgeKey(edgeKey);
                    const avgQ = (coords[0].q + coords[1].q) / 2;
                    if (avgQ < hemisphereThresholdQ) {
                        p1CandidateEdges.push({ key: edgeKey, q: avgQ });
                    } else {
                        p2CandidateEdges.push({ key: edgeKey, q: avgQ });
                    }
                });

                p1CandidateEdges.sort((a, b) => a.q - b.q);
                p2CandidateEdges.sort((a, b) => b.q - a.q);

                const usedEdges = new Set();
                const allUnitTypes = [UNIT_TYPES.MELEE, UNIT_TYPES.ARCHER, UNIT_TYPES.PIKEMAN, UNIT_TYPES.HORSEMAN];

                const placeTeam = (playerNum, candidates) => {
                    let placedCount = 0;
                    for (const cand of candidates) {
                        if (placedCount >= unitLimit) break;
                        if (!usedEdges.has(cand.key)) {
                            // Cycle types based on placement index
                            const typeToPlace = allUnitTypes[placedCount % allUnitTypes.length];
                            gameState.units.push(createUnit(playerNum, typeToPlace, cand.key));
                            usedEdges.add(cand.key);
                            placedCount++;
                        }
                    }
                    while (placedCount < unitLimit) {
                        const fallbackEdge = landEdges.find(e => !usedEdges.has(e));
                        if(fallbackEdge) {
                             const typeToPlace = allUnitTypes[placedCount % allUnitTypes.length];
                             gameState.units.push(createUnit(playerNum, typeToPlace, fallbackEdge));
                             usedEdges.add(fallbackEdge);
                             placedCount++;
                        } else {
                            console.error(`Ran out of all possible land edges placing for P${playerNum}`);
                            break;
                        }
                    }
                };

                placeTeam(1, p1CandidateEdges);
                placeTeam(2, p2CandidateEdges);
            }
        }

function startMapTest() {
    const p1Units = gameState.units.filter(u => u.player === 1).length;
    const p2Units = gameState.units.filter(u => u.player === 2).length;

    if (p1Units === 0 || p2Units === 0) {
        showInstruction("Map must contain at least one unit for each player to start a test.", 3000);
        return; 
    }

    console.log("Starting map test...");
    // 1. Save the current editor state
    mapMakerStateBackup = createMapDataObject();
    gameState.isTestingMap = true;

    // 2. Transition the UI from editor to game
    exitMapMakerMode(); // Cleans up editor UI

    // 3. Initialize a new game with the backed-up map data
    const tileMap = new Map(mapMakerStateBackup.tiles);
    const units = mapMakerStateBackup.units.map(u => ({ ...u, typeName: u.typeName.toUpperCase() }));
    initializeGrid(tileMap, units);
    gameState.baseCampPositions = mapMakerStateBackup.baseCampPositions;
    gameState.flags.p1_flag.homePosition = mapMakerStateBackup.baseCampPositions.player1;
    gameState.flags.p2_flag.homePosition = mapMakerStateBackup.baseCampPositions.player2;


    // 4. Configure the UI for test mode
    const testButtonContainer = document.getElementById('testButtonContainer');
    const testStopButton = document.getElementById('testStopButton');
    if (testButtonContainer && testStopButton) {
        testButtonContainer.style.display = 'block'; // Keep this from our previous layout fix
        testStopButton.textContent = 'Stop Test';
        testStopButton.className = 'action-button'; // Set the base class

        testStopButton.style.backgroundColor = '#3090D0'; 
        testStopButton.style.boxShadow = '0 3px #2080B0';

        // Re-assign the click listener to the stop function
        testStopButton.onclick = stopMapTest; 
    }
    updateMainButtonsForTestMode(true); // Disable Save/Load
    showInstruction("Test mode started. Play the map.", 3000);
}

function stopMapTest() {
    console.log("Stopping map test...");
    gameState.isTestingMap = false;

    ui.victoryMessage.style.display = 'none';

    // 1. Re-enter map maker mode to restore the editor UI
    enterMapMakerMode();
    
    // 2. Restore the backed-up map state
    if (mapMakerStateBackup) {
        loadMapFromDataObject(mapMakerStateBackup);
        mapMakerStateBackup = null; // Clear the backup
    }

    // 3. Re-enable main buttons and show instruction
    updateMainButtonsForTestMode(false); // Re-enable Save/Load
    showInstruction("Returned to Map Maker.", 2000);
}

function getMapMakerBaseCampTileKeys() {
    const baseCampTileKeys = new Set();
    const p1Coords = parseEdgeKey(gameState.baseCampPositions.player1);
    const p2Coords = parseEdgeKey(gameState.baseCampPositions.player2);

    if (p1Coords[0] && !isNaN(p1Coords[0].q)) baseCampTileKeys.add(getTileKey(p1Coords[0].q, p1Coords[0].r));
    if (p1Coords[1] && !isNaN(p1Coords[1].q)) baseCampTileKeys.add(getTileKey(p1Coords[1].q, p1Coords[1].r));
    if (p2Coords[0] && !isNaN(p2Coords[0].q)) baseCampTileKeys.add(getTileKey(p2Coords[0].q, p2Coords[0].r));
    if (p2Coords[1] && !isNaN(p2Coords[1].q)) baseCampTileKeys.add(getTileKey(p2Coords[1].q, p2Coords[1].r));
    
    return baseCampTileKeys;
}

function performFloodFill(startQ, startR) {
    const baseCampTileKeys = getMapMakerBaseCampTileKeys();
    const startKey = getTileKey(startQ, startR);
    const startTile = gameState.tiles.get(startKey);
    if (!startTile) return;

    // Prevent starting a fill ON a base camp tile 
    if (baseCampTileKeys.has(startKey)) {
        showInstruction("Cannot change the terrain of a base camp tile.", 2000);
        return;
    }

    const targetType = startTile.type;
    const replacementType = gameState.mapMakerBrush.value;

    if (targetType === replacementType) {
        return; // No work to do
    }
    
    const queue = [startKey];
    const visited = new Set([startKey]);

    while (queue.length > 0) {
        const currentKey = queue.shift();
        const currentTile = gameState.tiles.get(currentKey);

        // Prevent the fill from SPREADING to a base camp tile
        if (baseCampTileKeys.has(currentKey)) {
            continue; // Skip this tile and move to the next in the queue
        }

        // Change the tile type
        currentTile.type = replacementType;

        const { q, r } = currentTile;
        const neighbors = getNeighbors(q, r);

        for (const neighborCoord of neighbors) {
            const neighborKey = getTileKey(neighborCoord.q, neighborCoord.r);
            const neighborTile = gameState.tiles.get(neighborKey);

            if (neighborTile && !visited.has(neighborKey) && neighborTile.type === targetType) {
                visited.add(neighborKey);
                queue.push(neighborKey);
            }
        }
    }
    autoSaveMap(); // Save the result of the fill
}


function updateMainButtonsForTestMode(isTesting) {
    const saveBtn = document.getElementById('saveGameButton');
    const loadBtn = document.getElementById('loadGameButton');
    const newMapBtn = document.getElementById('newMapButton');
    
    saveBtn.disabled = isTesting;
    loadBtn.disabled = isTesting;
    newMapBtn.disabled = isTesting;
}

// --- MAP MAKER FUNCTIONS ---

function enterMapMakerMode() {
    console.log("Entering Map Maker mode.");
    gameState.mapMakerMode = true;
    gameState.selectedUnit = null;
    gameState.playerActionTaken.player1 = false;
    gameState.playerActionTaken.player2 = false;

    // --- NEW ORDER: Build UI First, Then Initialize Grid ---
    // 1. Build the UI controls. This creates the 'mapSizeSlider' in the DOM.
    hideGameplayUI();
    buildMapMakerPalette();
    buildMapMakerControls();
    
    // 2. NOW call resizeMapGrid. It will successfully find the slider we just created.
    // This sets the internal grid state and updates the slider visual value.
    resizeMapGrid(gameState.gridRadius); 
    // --- END OF NEW ORDER ---

    // Configure the Test Map button for the editor
    const testButtonContainer = document.getElementById('testButtonContainer');
    const testStopButton = document.getElementById('testStopButton');
    if (testButtonContainer && testStopButton) {
        testButtonContainer.style.display = 'flex';
        testStopButton.textContent = 'Test Map';
        testStopButton.className = 'action-button'; // Make it default blue
        testStopButton.style.backgroundColor = '#20B060'; // Green color
        testStopButton.style.boxShadow = '0 3px #208040';
        testStopButton.onclick = startMapTest; // Set the click action
    }

    // Ensure the end turn button's container is visible and styled correctly for Map Maker
    const endTurnButtonContainer = document.querySelector('#rightPanel .buttons-container');
    if (endTurnButtonContainer) {
        endTurnButtonContainer.style.display = 'flex'; // Ensure it's visible
        endTurnButtonContainer.style.marginTop = 'auto'; // Maintain bottom alignment
    }

    document.getElementById('endTurnButton').textContent = 'Clear Map';
    showInstruction("Map Maker Mode. Left-click to paint, Right-click to erase.", 5000);
    
    // Repurpose Save/Load buttons for Map Maker
    document.getElementById('saveGameButton').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save Map`;
    document.getElementById('loadGameButton').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg> Load Map`;
    updateTurnDisplay(); // This will now hide the border
}

function exitMapMakerMode() {
    if (!gameState.mapMakerMode) return; // Do nothing if not in map maker mode

    console.log("Exiting Map Maker mode.");
    gameState.mapMakerMode = false;
    gameState.fillToolActive = false;
    
    // --- Hide the Test Map button container on general exit ---
    const testButtonContainer = document.getElementById('testButtonContainer');
    if (testButtonContainer) testButtonContainer.style.display = 'none';

    // --- Restore UI Elements ---
    // Restore the right panel
    document.getElementById('turnDisplay').style.display = 'block';
    const gameplayDivider = document.getElementById('gameplayDivider');
    if (gameplayDivider) gameplayDivider.style.display = 'block';
    document.getElementById('actionsPanel').style.display = 'flex';
    const endTurnButtonContainer = document.querySelector('#rightPanel .buttons-container');
    if (endTurnButtonContainer) {
        endTurnButtonContainer.style.display = 'flex';
    }
    document.getElementById('rightPanel').style.justifyContent = ''; // Reset justification
    
    // Remove the map maker controls from the right panel
    const controlsContainer = document.getElementById('mapMakerControlsContainer');
    if (controlsContainer) {
        controlsContainer.remove();
    }
    
    // Restore the left panel
    const leftPanel = document.getElementById('leftPanel');
    leftPanel.querySelectorAll(':scope > div:not(#mapMakerPaletteContainer)').forEach(el => {
        el.style.display = 'block';
    });
    const paletteContainer = document.getElementById('mapMakerPaletteContainer');
    if (paletteContainer) {
        paletteContainer.remove();
    }
    
    // Restore original button labels for the main Save/Load buttons
    document.getElementById('endTurnButton').textContent = 'End Turn';
    document.getElementById('saveGameButton').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save Game`;
    document.getElementById('loadGameButton').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg> Load Game`;
    
    // No need to reset modal buttons here, that's handled by showLoadGameModal
    updateTurnDisplay();
}

function hideGameplayUI() {
    // Hide the right panel's turn display and action buttons
    document.getElementById('turnDisplay').style.display = 'none';
    const gameplayDivider = document.getElementById('gameplayDivider');
    if (gameplayDivider) gameplayDivider.style.display = 'none';
    document.getElementById('actionsPanel').style.display = 'none';

    // The buttons-container should remain visible in map maker mode, so we remove the 'display: none' here.
    const leftPanel = document.getElementById('leftPanel');
    leftPanel.querySelectorAll(':scope > div:not(#mapMakerPaletteContainer)').forEach(el => {
        el.style.display = 'none';
    });
}

function buildMapMakerPalette() {
    const leftPanel = document.getElementById('leftPanel');
    let paletteContainer = document.getElementById('mapMakerPaletteContainer');
    if (!paletteContainer) {
        paletteContainer = document.createElement('div');
        paletteContainer.id = 'mapMakerPaletteContainer';
        paletteContainer.style.width = '100%';
        leftPanel.appendChild(paletteContainer);
    }
    paletteContainer.innerHTML = '';

    const title = document.createElement('h3');
    title.textContent = 'Palette';
    title.className = 'text-center';
    title.style.cssText = "font-size: 1.5em; color: #FFC020; margin-bottom: 15px;";
    paletteContainer.appendChild(title);

    const divider = document.createElement('hr');
    divider.style.cssText = "width: 100%; border-color: #4a6075; margin-bottom: 20px; margin-top: 0;";
    paletteContainer.appendChild(divider);

    // --- Tiles Section ---
    const tilesTitle = document.createElement('h4');
    tilesTitle.textContent = 'Tiles';
    tilesTitle.style.cssText = "text-align: center; color: #F0F0F0; margin-bottom: 10px;";
    paletteContainer.appendChild(tilesTitle);
    const tilePalette = document.createElement('div');
    tilePalette.style.cssText = "display: flex; flex-direction: column; align-items: center; gap: 12px;";
    paletteContainer.appendChild(tilePalette);
    
    const PALETTE_HEX_SIZE = 30;
    function drawPaletteHex(canvas, tileType, size) {
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
            const angle = Math.PI / 180 * (60 * i - 30);
            const x = centerX + size * Math.cos(angle);
            const y = centerY + size * Math.sin(angle);
            if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        }
        ctx.closePath();
        let fillColor;
        switch (tileType) {
            case TILE_TYPES.MOUNTAIN: fillColor = '#808080'; break;
            case TILE_TYPES.FOREST: fillColor = '#208020'; break;
            case TILE_TYPES.WATER: fillColor = '#80C0E0'; break;
            case TILE_TYPES.PLAINS: fillColor = '#90E090'; break;
            default: fillColor = tileType.color;
        }
        ctx.fillStyle = fillColor;
        ctx.fill();
    }
    Object.entries(TILE_TYPES).forEach(([key, tileType]) => {
        const tileOptionContainer = document.createElement('div');
        tileOptionContainer.className = 'tile-option'; 
        tileOptionContainer.style.cssText = `display: flex; align-items: center; gap: 15px; cursor: pointer; width: 90%; padding: 5px; border: 2px solid #4a6075; border-radius: 8px; transition: all 0.2s;`;
        const hexCanvas = document.createElement('canvas');
        hexCanvas.width = PALETTE_HEX_SIZE * 2;
        hexCanvas.height = PALETTE_HEX_SIZE * 2;
        drawPaletteHex(hexCanvas, tileType, PALETTE_HEX_SIZE);
        const nameLabel = document.createElement('span');
        nameLabel.textContent = tileType.name;
        nameLabel.style.fontWeight = 'bold';
        tileOptionContainer.appendChild(hexCanvas);
        tileOptionContainer.appendChild(nameLabel);
        if (key === 'PLAINS') { tileOptionContainer.style.borderColor = '#FFC020'; }
        
        tileOptionContainer.addEventListener('click', () => {
            // Validate Base Camp Completion
            if (gameState.mapMakerBrush.type === 'base_camp') {
                const p = gameState.mapMakerBrush.player;
                const base = gameState.baseCampPositions[`player${p}`];
                if (Array.isArray(base) && base.length > 0 && base.length < 3) {
                    showInstruction(`P${p} Base incomplete! Must place 3 tiles.`, 2000);
                    return;
                }
            }

            gameState.mapMakerBrush = { type: 'tile', value: TILE_TYPES[key], player: null };
            
            // Clear selections
            tilePalette.querySelectorAll('.tile-option').forEach(el => { el.style.borderColor = '#4a6075'; });
            document.getElementById('unitPalette')?.querySelectorAll('.unit-option').forEach(el => { el.classList.remove('selected'); });
            
            // Deselect Base Camp Buttons (Revert Colors)
            const controls = document.getElementById('mapMakerControlsContainer');
            if (controls) {
                const p1Btn = controls.querySelector('#p1BaseBtn');
                const p2Btn = controls.querySelector('#p2BaseBtn');
                if (p1Btn) {
                    const c = TEAM_COLORS.player1.primary;
                    p1Btn.style.backgroundColor = c;
                    p1Btn.style.boxShadow = `0 3px ${adjustBrightness(c, -20)}`;
                }
                if (p2Btn) {
                    const c = TEAM_COLORS.player2.primary;
                    p2Btn.style.backgroundColor = c;
                    p2Btn.style.boxShadow = `0 3px ${adjustBrightness(c, -20)}`;
                }
            }

            tileOptionContainer.style.borderColor = '#FFC020';
        });
        tilePalette.appendChild(tileOptionContainer);
    });

    // --- Units Section ---
    const unitsTitle = document.createElement('h4');
    unitsTitle.textContent = 'Units';
    unitsTitle.style.cssText = "text-align: center; color: #F0F0F0; margin-top: 30px; margin-bottom: 15px;";
    paletteContainer.appendChild(unitsTitle);

    const unitPaletteTabs = document.createElement('div');
    unitPaletteTabs.id = 'mapMakerUnitTabs';
    unitPaletteTabs.style.cssText = `display: flex; border-bottom: 2px solid #4a6075; margin-bottom: 15px; width: 100%;`;
    const p1Tab = document.createElement('button');
    p1Tab.dataset.player = '1';
    p1Tab.textContent = 'P1';
    const p2Tab = document.createElement('button');
    p2Tab.dataset.player = '2';
    p2Tab.textContent = 'P2';
    [p1Tab, p2Tab].forEach(tab => {
        tab.style.cssText = `flex-grow: 1; padding: 10px; background-color: transparent; border: none; color: #bdc3c7; font-size: 1.1em; font-family: 'Exo 2', sans-serif; font-weight: bold; cursor: pointer; border-bottom: 3px solid transparent; transition: color 0.4s ease-in-out, border-color 0.4s ease-in-out;`;
    });
    unitPaletteTabs.appendChild(p1Tab);
    unitPaletteTabs.appendChild(p2Tab);
    paletteContainer.appendChild(unitPaletteTabs);

    const unitPalette = document.createElement('div');
    unitPalette.id = 'unitPalette';
    unitPalette.style.cssText = "display: grid; grid-template-columns: 1fr 1fr; gap: 15px; justify-items: center;";
    paletteContainer.appendChild(unitPalette);

    let selectedPlayer = 1;
    let paletteAnimation = { active: false, startTime: 0, fromColor: '', toColor: '' };

    const buildUnitOptions = () => {
        unitPalette.innerHTML = '';
        const PALETTE_UNIT_RADIUS = UNIT_DRAW_SIZE_ON_EDGE * 1.8;   
        Object.entries(UNIT_TYPES).forEach(([key, unitType]) => {
            const unitOptionContainer = document.createElement('div');
            unitOptionContainer.className = 'unit-option';
            unitOptionContainer.dataset.unitType = key;
            unitOptionContainer.style.cssText = `border-radius: 50%; padding: 3px; border: 3px solid transparent; cursor: pointer; transition: all 0.2s;`;
            const unitCanvas = document.createElement('canvas');
            unitCanvas.width = (PALETTE_UNIT_RADIUS + 5) * 2;
            unitCanvas.height = (PALETTE_UNIT_RADIUS + 5) * 2;
            unitOptionContainer.appendChild(unitCanvas);
            
            unitOptionContainer.addEventListener('click', () => {
                // Validate Base Camp Completion
                if (gameState.mapMakerBrush.type === 'base_camp') {
                    const p = gameState.mapMakerBrush.player;
                    const base = gameState.baseCampPositions[`player${p}`];
                    if (Array.isArray(base) && base.length > 0 && base.length < 3) {
                        showInstruction(`P${p} Base incomplete! Must place 3 tiles.`, 2000);
                        return;
                    }
                }

                gameState.mapMakerBrush = { type: 'unit', value: UNIT_TYPES[key], player: selectedPlayer };
                
                unitPalette.querySelectorAll('.unit-option').forEach(el => { el.classList.remove('selected'); });
                tilePalette.querySelectorAll('.tile-option').forEach(el => { el.style.borderColor = '#4a6075'; });
                
                // Deselect Base Camp Buttons
                const controls = document.getElementById('mapMakerControlsContainer');
                if (controls) {
                    const p1Btn = controls.querySelector('#p1BaseBtn');
                    const p2Btn = controls.querySelector('#p2BaseBtn');
                    if (p1Btn) {
                        const c = TEAM_COLORS.player1.primary;
                        p1Btn.style.backgroundColor = c;
                        p1Btn.style.boxShadow = `0 3px ${adjustBrightness(c, -20)}`;
                    }
                    if (p2Btn) {
                        const c = TEAM_COLORS.player2.primary;
                        p2Btn.style.backgroundColor = c;
                        p2Btn.style.boxShadow = `0 3px ${adjustBrightness(c, -20)}`;
                    }
                }

                unitOptionContainer.classList.add('selected');
            });
            unitPalette.appendChild(unitOptionContainer);
        });
    };

    const runPaletteLoop = () => {
        if (!gameState.mapMakerMode) return;
        p1Tab.style.color = selectedPlayer === 1 ? TEAM_COLORS.player1.secondary : '#bdc3c7';
        p1Tab.style.borderBottomColor = selectedPlayer === 1 ? TEAM_COLORS.player1.secondary : 'transparent';
        p2Tab.style.color = selectedPlayer === 2 ? TEAM_COLORS.player2.secondary : '#bdc3c7';
        p2Tab.style.borderBottomColor = selectedPlayer === 2 ? TEAM_COLORS.player2.secondary : 'transparent';

        let frameDrawColor = null;
        if (paletteAnimation.active) {
            const elapsedTime = Date.now() - paletteAnimation.startTime;
            const progress = Math.min(elapsedTime / COLOR_TRANSITION_DURATION_MS, 1);
            frameDrawColor = lerpColor(paletteAnimation.fromColor, paletteAnimation.toColor, progress);
            if (progress >= 1) paletteAnimation.active = false;
        }

        const PALETTE_UNIT_RADIUS = UNIT_DRAW_SIZE_ON_EDGE * 1.8;
        const playerKey = `player${selectedPlayer}`;
        const baseColor = currentDrawingColors[playerKey].primary;
        const finalDrawColor = frameDrawColor || baseColor;

        unitPalette.querySelectorAll('.unit-option').forEach(container => {
            const canvas = container.querySelector('canvas');
            const unitTypeKey = container.dataset.unitType;
            if (canvas && unitTypeKey) {
                const unitCtx = canvas.getContext('2d');
                unitCtx.clearRect(0, 0, canvas.width, canvas.height);
                const dummyUnit = { player: selectedPlayer, type: UNIT_TYPES[unitTypeKey] };
                const originalColor = currentDrawingColors[playerKey].primary;
                currentDrawingColors[playerKey].primary = finalDrawColor;
                drawSingleUnit(unitCtx, dummyUnit, canvas.width / 2, canvas.height / 2, PALETTE_UNIT_RADIUS, null, true);
                currentDrawingColors[playerKey].primary = originalColor; 

                if (container.classList.contains('selected')) {
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 2;
                    const ringRadius = PALETTE_UNIT_RADIUS + 2; 
                    unitCtx.beginPath();
                    unitCtx.arc(centerX, centerY, ringRadius, 0, 2 * Math.PI);
                    unitCtx.strokeStyle = '#FFD700'; 
                    unitCtx.lineWidth = 3; 
                    unitCtx.stroke();
                }
            }
        });
        requestAnimationFrame(runPaletteLoop);
    };

    const handleTabClick = (newPlayer) => {
        if (selectedPlayer === newPlayer) return;
        unitPalette.querySelectorAll('.unit-option.selected').forEach(el => { el.classList.remove('selected'); });
        if (gameState.mapMakerBrush.type === 'unit') {
            gameState.mapMakerBrush = { type: 'tile', value: TILE_TYPES.PLAINS, player: null };
        }
        const fromPlayerKey = `player${selectedPlayer}`;
        const toPlayerKey = `player${newPlayer}`;
        paletteAnimation.fromColor = TEAM_COLORS[fromPlayerKey].primary;
        paletteAnimation.toColor = TEAM_COLORS[toPlayerKey].primary;
        paletteAnimation.active = true;
        paletteAnimation.startTime = Date.now();
        selectedPlayer = newPlayer;
        p1Tab.classList.toggle('active', selectedPlayer === 1);
        p2Tab.classList.toggle('active', selectedPlayer === 2);
    };
    
    p1Tab.addEventListener('click', () => handleTabClick(1));
    p2Tab.addEventListener('click', () => handleTabClick(2));

    buildUnitOptions();
    p1Tab.classList.add('active');
    runPaletteLoop();
}

function buildMapMakerControls() {
    const rightPanel = document.getElementById('rightPanel');

    let controlsContainer = document.getElementById('mapMakerControlsContainer');
    if (!controlsContainer) {
        controlsContainer = document.createElement('div');
        controlsContainer.id = 'mapMakerControlsContainer';
        controlsContainer.style.width = '100%';
        rightPanel.prepend(controlsContainer);
    }
    controlsContainer.innerHTML = ''; 

    const title = document.createElement('h3');
    title.textContent = 'Options';
    title.className = 'text-center';
    title.style.cssText = "font-size: 1.5em; color: #FFC020; margin-bottom: 15px;";
    controlsContainer.appendChild(title);

    const divider = document.createElement('hr');
    divider.style.cssText = "width: 100%; border-color: #4a6075; margin-bottom: 20px; margin-top: 0;";
    controlsContainer.appendChild(divider);

    // --- Base Camp Slider (Standard R=3) ---
    const sliderContainer = document.createElement('div');
    sliderContainer.id = 'baseCampSliderContainer'; 
    sliderContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 10px;
        background-color: var(--bg-color);
        border: 1px solid #4a6075;
        border-radius: 5px;
    `;
    sliderContainer.style.display = (gameState.gridRadius === 3) ? 'flex' : 'none';
    
    const sliderLabel = document.createElement('label');
    sliderLabel.htmlFor = 'baseCampSlider';
    sliderLabel.textContent = 'Base Camp Location';
    sliderLabel.style.fontWeight = 'bold';

    const slider = document.createElement('input');
    slider.id = 'baseCampSlider';
    slider.type = 'range';
    slider.min = '0';
    slider.max = '5'; 
    slider.step = '1'; 
    slider.value = '3'; 
    slider.style.width = '100%';

    slider.addEventListener('input', (event) => {
        const position = event.target.value;
        updateBaseCampLocations(position);
    });
    
    sliderContainer.appendChild(sliderLabel);
    sliderContainer.appendChild(slider);
    controlsContainer.appendChild(sliderContainer);

    // --- Expansive Map Base Camp Buttons (R=4) ---
    if (gameState.gridRadius === 4) {
        const baseToolsContainer = document.createElement('div');
        baseToolsContainer.style.cssText = "display: flex; gap: 10px; justify-content: center; margin-top: 10px; margin-bottom: 10px;";

        // Helper: Check if we can switch away from the current tool
        const canSwitchFromBaseCamp = () => {
            if (gameState.mapMakerBrush.type === 'base_camp') {
                const p = gameState.mapMakerBrush.player;
                const base = gameState.baseCampPositions[`player${p}`];
                if (Array.isArray(base) && base.length > 0 && base.length < 3) {
                    showInstruction(`P${p} Base incomplete! Must place 3 tiles.`, 2000);
                    return false;
                }
            }
            return true;
        };

        // Colors
        const p1Color = TEAM_COLORS.player1.primary;
        const p1Shadow = adjustBrightness(p1Color, -20);
        const p2Color = TEAM_COLORS.player2.primary;
        const p2Shadow = adjustBrightness(p2Color, -20);
        const activeColor = '#FFC020';
        const activeShadow = adjustBrightness(activeColor, -20);

        // Helper: Common logic for clicking a base button
        const handleBaseButtonClick = (player, btn, otherBtn, originalColor, originalShadow, otherOriginalColor, otherOriginalShadow) => {
            // 1. If clicking the already active button -> Toggle Off
            if (gameState.mapMakerBrush.type === 'base_camp' && gameState.mapMakerBrush.player === player) {
                if (!canSwitchFromBaseCamp()) return;
                // Deselect: Reset brush to default tile
                gameState.mapMakerBrush = { type: 'tile', value: TILE_TYPES.PLAINS, player: null };
                // Revert visual state
                btn.style.backgroundColor = originalColor;
                btn.style.boxShadow = `0 3px ${originalShadow}`;
                return;
            }

            // 2. If switching from another tool (or the other player) -> Check constraints
            if (!canSwitchFromBaseCamp()) return;

            // 3. Activate this button
            gameState.mapMakerBrush = { type: 'base_camp', player: player };
            
            // Highlight this button (Yellow)
            btn.style.backgroundColor = activeColor;
            btn.style.boxShadow = `0 3px ${activeShadow}`;
            
            // Reset the other button
            otherBtn.style.backgroundColor = otherOriginalColor;
            otherBtn.style.boxShadow = `0 3px ${otherOriginalShadow}`;
            
            // Deactivate Fill Tool if active
            if (gameState.fillToolActive) {
                gameState.fillToolActive = false;
                const fillBtn = document.getElementById('fillToolButton');
                if (fillBtn) {
                    fillBtn.textContent = 'Fill';
                    fillBtn.classList.remove('selecting');
                }
            }

            // Clear Palette selections
            const palette = document.getElementById('mapMakerPaletteContainer');
            if (palette) {
                palette.querySelectorAll('.unit-option').forEach(el => el.classList.remove('selected'));
                palette.querySelectorAll('.tile-option').forEach(el => el.style.borderColor = '#4a6075');
            }
        };

        const p1BaseBtn = document.createElement('button');
        p1BaseBtn.id = 'p1BaseBtn';
        p1BaseBtn.textContent = "P1 Base";
        p1BaseBtn.className = 'action-button';
        p1BaseBtn.style.backgroundColor = p1Color;
        p1BaseBtn.style.boxShadow = `0 3px ${p1Shadow}`;
        p1BaseBtn.style.width = 'auto';
        p1BaseBtn.style.margin = '0';
        p1BaseBtn.onclick = () => handleBaseButtonClick(1, p1BaseBtn, p2BaseBtn, p1Color, p1Shadow, p2Color, p2Shadow);

        const p2BaseBtn = document.createElement('button');
        p2BaseBtn.id = 'p2BaseBtn';
        p2BaseBtn.textContent = "P2 Base";
        p2BaseBtn.className = 'action-button';
        p2BaseBtn.style.backgroundColor = p2Color;
        p2BaseBtn.style.boxShadow = `0 3px ${p2Shadow}`;
        p2BaseBtn.style.width = 'auto';
        p2BaseBtn.style.margin = '0';
        p2BaseBtn.onclick = () => handleBaseButtonClick(2, p2BaseBtn, p1BaseBtn, p2Color, p2Shadow, p1Color, p1Shadow);

        baseToolsContainer.appendChild(p1BaseBtn);
        baseToolsContainer.appendChild(p2BaseBtn);
        controlsContainer.appendChild(baseToolsContainer);
    }

    // --- Map Size Slider ---
    const sizeSliderContainer = document.createElement('div');
    sizeSliderContainer.style.cssText = `
        display: flex;
        flex-direction: column;
        gap: 10px;
        padding: 10px;
        margin-top: 20px;
        background-color: var(--bg-color);
        border: 1px solid #4a6075;
        border-radius: 5px;
    `;
    const sizeSliderLabel = document.createElement('label');
    sizeSliderLabel.htmlFor = 'mapSizeSlider';
    sizeSliderLabel.style.fontWeight = 'bold';

    const sizeSlider = document.createElement('input');
    sizeSlider.id = 'mapSizeSlider';
    sizeSlider.type = 'range';
    sizeSlider.min = '2'; 
    sizeSlider.max = '4'; 
    sizeSlider.step = '1';
    sizeSlider.value = gameState.gridRadius.toString();
    sizeSlider.style.width = '100%';

    const sizeValueLabel = document.createElement('span');
    sizeValueLabel.style.textAlign = 'center';
    const updateSizeLabel = (value) => {
        const sizeNames = { '2': 'Compact (R=2)', '3': 'Normal (R=3)', '4': 'Expansive (R=4)' };
        sizeSliderLabel.textContent = `Map Size: ${sizeNames[value]}`;
    };
    updateSizeLabel(sizeSlider.value);

    sizeSlider.addEventListener('change', (event) => { 
        const newRadius = parseInt(event.target.value, 10);
        if (newRadius !== gameState.gridRadius) {
            document.getElementById('customConfirmMessage').textContent = 'Resizing the map will clear all units and terrain. Are you sure?';
            currentConfirmAction = () => { resizeMapGrid(newRadius); currentCancelAction = null; };
            currentCancelAction = () => { sizeSlider.value = gameState.gridRadius; updateSizeLabel(gameState.gridRadius); };
            const confirmModal = document.getElementById('customConfirmModal');
            if (confirmModal) {
                confirmModal.style.display = 'flex';
                setTimeout(() => confirmModal.classList.add('modal-visible'), 10);
            }
        }
    });
     sizeSlider.addEventListener('input', (event) => { updateSizeLabel(event.target.value); });

    sizeSliderContainer.appendChild(sizeSliderLabel);
    sizeSliderContainer.appendChild(sizeSlider);
    controlsContainer.appendChild(sizeSliderContainer);

    // --- Fill Tool Button ---
    const fillButtonContainer = document.createElement('div');
    fillButtonContainer.style.cssText = "display: flex; justify-content: center; width: 100%; margin-top: 20px;";

    const fillButton = document.createElement('button');
    fillButton.id = 'fillToolButton';
    fillButton.className = 'action-button';
    fillButton.style.width = '160px';
    fillButton.style.margin = '0'; 
    fillButton.textContent = 'Fill';

    fillButton.addEventListener('click', () => {
        // Check if we can switch tool (Base Camp validation)
        if (gameState.mapMakerBrush.type === 'base_camp') {
            const p = gameState.mapMakerBrush.player;
            const base = gameState.baseCampPositions[`player${p}`];
            if (Array.isArray(base) && base.length > 0 && base.length < 3) {
                showInstruction(`P${p} Base incomplete! Must place 3 tiles.`, 2000);
                return;
            }
            // If valid switch, reset brush to default tile
            gameState.mapMakerBrush = { type: 'tile', value: TILE_TYPES.PLAINS, player: null };
            
            // Visually deselect base buttons (revert colors)
            const p1Btn = document.getElementById('p1BaseBtn');
            const p2Btn = document.getElementById('p2BaseBtn');
            if (p1Btn) {
                const c = TEAM_COLORS.player1.primary;
                p1Btn.style.backgroundColor = c;
                p1Btn.style.boxShadow = `0 3px ${adjustBrightness(c, -20)}`;
            }
            if (p2Btn) {
                const c = TEAM_COLORS.player2.primary;
                p2Btn.style.backgroundColor = c;
                p2Btn.style.boxShadow = `0 3px ${adjustBrightness(c, -20)}`;
            }
        }

        gameState.fillToolActive = !gameState.fillToolActive; 
        if (gameState.fillToolActive) {
            fillButton.textContent = 'Cancel Fill';
            fillButton.classList.add('selecting'); 
        } else {
            fillButton.textContent = 'Fill';
            fillButton.classList.remove('selecting');
        }
    });

    fillButtonContainer.appendChild(fillButton);
    controlsContainer.appendChild(fillButtonContainer);
}

function resizeMapGrid(newRadius) {
    console.log(`Resizing grid to radius ${newRadius}`);
    gameState.gridRadius = newRadius;
    
    const slider = document.getElementById('mapSizeSlider');
    if (slider) slider.value = newRadius;

    // We update mode BEFORE rebuilding controls, so buildMapMakerControls sees the new radius
    if (newRadius === 2) { 
        gameState.gameMode = 'arcade';
        gameState.renderScale = 1.3; 
        gameState.renderOffset = { x: 0, y: 0 }; 
        gameState.baseCampPositions = { player1: null, player2: null };
    } else { 
        gameState.gameMode = 'local'; 
        if (newRadius === 4) {
            const expansiveMapWidth = (2 * 4 + 1.5) * (HEX_SIZE * Math.sqrt(3));
            gameState.renderScale = CANVAS_WIDTH_NORMAL / expansiveMapWidth;
        } else {
            gameState.renderScale = 1.0;
        }
        gameState.renderOffset = { x: 0, y: 0 };
    }

    // Rebuild Controls (Adds/Removes Base Camp Buttons based on radius)
    if (gameState.mapMakerMode) {
        buildMapMakerControls();
        buildMapMakerPalette();
    }

    canvas.width = CANVAS_WIDTH_NORMAL;
    canvas.height = CANVAS_HEIGHT_NORMAL;
    document.querySelectorAll('.ui-panel').forEach(panel => {
        panel.style.minHeight = canvas.height + 'px';
    });
    
    gameState.units = [];
    gameState.tiles.clear();
    gameState.edges.clear();

    for (let q = -newRadius; q <= newRadius; q++) {
        for (let r = -newRadius; r <= newRadius; r++) {
            if (Math.abs(q + r) <= newRadius) {
                const key = getTileKey(q, r);
                gameState.tiles.set(key, { q, r, type: TILE_TYPES.PLAINS, fortifiedByPlayer: null });
            }
        }
    }
    gameState.tiles.forEach(tile => {
        getNeighbors(tile.q, tile.r).forEach(n_coord => {
            if (gameState.tiles.has(getTileKey(n_coord.q, n_coord.r))) {
                const edgeKey = getEdgeKey(tile.q, tile.r, n_coord.q, n_coord.r);
                if (!gameState.edges.has(edgeKey)) {
                    gameState.edges.set(edgeKey, {
                        q1: tile.q, r1: tile.r, q2: n_coord.q, r2: n_coord.r,
                        units: [], bridge: false, bridgeHp: null, isPathway: true
                    });
                }
            }
        });
    });

    // --- BASE CAMP LOGIC UPDATE ---
    if (newRadius === 3) {
        const sliderEl = document.getElementById('baseCampSlider');
        const currentRotation = sliderEl ? sliderEl.value : '3';
        updateBaseCampLocations(currentRotation);
    } else {
        gameState.baseCampPositions = { player1: null, player2: null };
        if (gameState.flags) {
             gameState.flags.p1_flag.homePosition = null;
             gameState.flags.p2_flag.homePosition = null;
        }
    }

    if (gameState.mapMakerMode) {
        autoSaveMap();
    }
    
    showInstruction(`Map resized to ${newRadius === 2 ? 'Compact (Arcade)' : newRadius === 3 ? 'Normal' : 'Expansive'}.`, 2500);
}

function getBaseCampTiles(baseCampEdgeKey) {
    if (!baseCampEdgeKey) return [];
    const coords = parseEdgeKey(baseCampEdgeKey);
    return coords.map(c => getTileKey(c.q, c.r));
}

function eraseAt(x, y) {
    const hexCoords = pixelToAxial(x, y);
    const hexKey = getTileKey(hexCoords.q, hexCoords.r);
    
    const { key: closestEdgeKey, distance } = findClosestEdgeToPoint(x, y);
    const edge = gameState.edges.get(closestEdgeKey);
    
    // Prioritize erasing units if clicking near an edge with units on it
    if (edge && edge.units.length > 0 && distance < (HEX_SIZE * 0.4)) {
        const unitToRemove = edge.units.pop(); // Remove the last unit added
        gameState.units = gameState.units.filter(u => u.id !== unitToRemove.id);
    } else {
        // Otherwise, erase the tile by setting it to plains
        const tile = gameState.tiles.get(hexKey);
        if (tile) {
            tile.type = TILE_TYPES.PLAINS;
        }
    }
    autoSaveMap();
}

function clearMapForMaker() {
    // Clear tiles back to plains
    gameState.tiles.forEach(tile => {
        tile.type = TILE_TYPES.PLAINS;
    });

    // Clear all units
    gameState.units = [];
    gameState.edges.forEach(edge => {
        edge.units = [];
    });

    showInstruction('Map Cleared!', 2000);
    autoSaveMap(); // Autosave the cleared state
}

/**
 * Rotates an axial coordinate around the origin (0,0).
 * @param {number} q - The q coordinate.
 * @param {number} r - The r coordinate.
 * @param {number} rotations - Number of 60-degree rotations. Positive is clockwise, negative is counter-clockwise.
 * @returns {{q: number, r: number}} The new rotated coordinates.
 */
function rotateAxial(q, r, rotations) {
    let currentQ = q;
    let currentR = r;
    const count = Math.abs(rotations);

    for (let i = 0; i < count; i++) {
        if (rotations > 0) { // Clockwise
            const nextQ = -currentR;
            const nextR = currentQ + currentR;
            currentQ = nextQ;
            currentR = nextR;
        } else { // Counter-clockwise
            const nextQ = currentQ + currentR;
            const nextR = -currentQ;
            currentQ = nextQ;
            currentR = nextR;
        }
    }
    return { q: currentQ, r: currentR };
}

function updateBaseCampLocations(sliderValue) {
    const sliderToRotations = [3, 2, 1, 0, -1, -2];
    const rotations = sliderToRotations[parseInt(sliderValue, 10)];
    const currentRadius = gameState.gridRadius;
    
    // Safety check
    if (!BASE_CAMP_DEFAULTS[currentRadius]) return;

    const defaults = BASE_CAMP_DEFAULTS[currentRadius];
    
    // 1. Clear old base camp tiles (Reset to Plains)
    const oldP1Tiles = getBaseCampTiles(gameState.baseCampPositions.player1);
    const oldP2Tiles = getBaseCampTiles(gameState.baseCampPositions.player2);
    [...oldP1Tiles, ...oldP2Tiles].forEach(key => {
        const tile = gameState.tiles.get(key);
        if (tile) tile.type = TILE_TYPES.PLAINS;
    });

    // 2. Calculate new Rotated Tile Keys
    const p1_rotated_tiles = defaults.player1.tiles.map(key => {
        const [q, r] = key.split(',').map(Number);
        const rotated = rotateAxial(q, r, rotations);
        return getTileKey(rotated.q, rotated.r);
    });
    
    const p2_rotated_tiles = defaults.player2.tiles.map(key => {
        const [q, r] = key.split(',').map(Number);
        const rotated = rotateAxial(q, r, rotations);
        return getTileKey(rotated.q, rotated.r);
    });

    // 3. Determine the Flag Edge (Only for Standard Size R=3)
    let newP1EdgeKey = null;
    let newP2EdgeKey = null;
    
    if (currentRadius === 3) {
        // FIX: Correctly parse simple tile keys "q,r" instead of treating them as edge keys
        const p1_coords = p1_rotated_tiles.map(k => {
            const [q, r] = k.split(',').map(Number);
            return { q, r };
        });
        const p2_coords = p2_rotated_tiles.map(k => {
            const [q, r] = k.split(',').map(Number);
            return { q, r };
        });

        // Assuming standard base has 2 tiles, creating an edge between them
        if (p1_coords.length >= 2) {
            newP1EdgeKey = getEdgeKey(p1_coords[0].q, p1_coords[0].r, p1_coords[1].q, p1_coords[1].r);
        }
        if (p2_coords.length >= 2) {
            newP2EdgeKey = getEdgeKey(p2_coords[0].q, p2_coords[0].r, p2_coords[1].q, p2_coords[1].r);
        }
    }

    // 4. Update Game State
    gameState.baseCampPositions.player1 = newP1EdgeKey;
    gameState.baseCampPositions.player2 = newP2EdgeKey;
    
    if (gameState.flags) {
        if (gameState.flags.p1_flag) gameState.flags.p1_flag.homePosition = newP1EdgeKey;
        if (gameState.flags.p2_flag) gameState.flags.p2_flag.homePosition = newP2EdgeKey;
    }

    // 5. Set new base camp tiles to Plains (ensuring they are valid for movement/fortification)
    [...p1_rotated_tiles, ...p2_rotated_tiles].forEach(key => {
        const tile = gameState.tiles.get(key);
        if (tile) tile.type = TILE_TYPES.PLAINS;
    });
}

function findClosestEdgeToPoint(x, y) {
    let closestEdgeKey = null;
    let minDistanceSq = Infinity;

    for (const [edgeKey, edge] of gameState.edges.entries()) {
        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
        const dSq = distSq({x, y}, mid);
        if (dSq < minDistanceSq) {
            minDistanceSq = dSq;
            closestEdgeKey = edgeKey;
        }
    }
    return { key: closestEdgeKey, distance: Math.sqrt(minDistanceSq) };
}

function getUnitCountsForPlayer(player) {
    const counts = { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 };
    gameState.units.forEach(unit => {
        if (unit.player === player) {
            counts[unit.type.name]++;
        }
    });
    return counts;
}

function applyMapMakerBrush(x, y) {
    const hexCoords = pixelToAxial(x, y);
    const hexKey = getTileKey(hexCoords.q, hexCoords.r);

    if (hexKey === gameState.mapMakerLastPaintedHexKey && gameState.isDragging) return;
    gameState.mapMakerLastPaintedHexKey = hexKey;
    
    const brush = gameState.mapMakerBrush;

    // --- BASE CAMP BRUSH LOGIC ---
    if (brush.type === 'base_camp') {
        if (gameState.gridRadius !== 4) return; 

        if (!gameState.tiles.has(hexKey)) return;

        const player = brush.player;
        const playerKey = `player${player}`;
        const enemyPlayerKey = `player${player === 1 ? 2 : 1}`;
        
        const currentBase = Array.isArray(gameState.baseCampPositions[playerKey]) 
                            ? gameState.baseCampPositions[playerKey] 
                            : [];
        
        const enemyBase = Array.isArray(gameState.baseCampPositions[enemyPlayerKey])
                          ? new Set(gameState.baseCampPositions[enemyPlayerKey])
                          : new Set();

        // Validation
        const neighbors = getNeighbors(hexCoords.q, hexCoords.r);
        for (let n of neighbors) {
            if (enemyBase.has(getTileKey(n.q, n.r))) {
                showInstruction("Cannot be adjacent to enemy base.", 1500);
                return;
            }
        }

        // Logic: Toggle or Add
        let newBase = [...currentBase];
        if (newBase.includes(hexKey)) {
            newBase = newBase.filter(k => k !== hexKey);
        } else {
            if (newBase.length >= 3) {
                showInstruction("Base camp max size is 3 tiles.", 1500);
                return;
            }
            newBase.push(hexKey);
            
            if (!isSetContiguous(newBase)) {
                showInstruction("Base tiles must be contiguous.", 1500);
                return;
            }
        }

        // Apply
        gameState.baseCampPositions[playerKey] = newBase;
        const tile = gameState.tiles.get(hexKey);
        if (tile) tile.type = TILE_TYPES.PLAINS;

    // --- TILE BRUSH LOGIC ---
    } else if (brush.type === 'tile') {
        
        // --- FIX: PROTECT BASE CAMP TILES ---
        const baseCampTileKeys = getMapMakerBaseCampTileKeys();
        
        if (baseCampTileKeys.has(hexKey)) {
            console.warn(`[PROTECTION] Blocked painting on base camp tile: ${hexKey}`);
            showInstruction("Cannot change the terrain of a base camp tile.", 2000);
            return; // Block painting
        }
        // ------------------------------------

        const tile = gameState.tiles.get(hexKey);
        if (tile) {
            tile.type = brush.value;
            // Remove invalid units on water
            if (brush.value === TILE_TYPES.WATER) {
                getEdgesOfTile(tile.q, tile.r).forEach(edgeKey => {
                    const edge = gameState.edges.get(edgeKey);
                    if (edge && edge.units.length > 0) {
                        const otherTileQ = (edge.q1 === tile.q && edge.r1 === tile.r) ? edge.q2 : edge.q1;
                        const otherTileR = (edge.r1 === tile.r && edge.q1 === tile.q) ? edge.r2 : edge.r1;
                        const otherTile = gameState.tiles.get(getTileKey(otherTileQ, otherTileR));
                        
                        if (otherTile && otherTile.type === TILE_TYPES.WATER) {
                            edge.units.forEach(unitToRemove => {
                                gameState.units = gameState.units.filter(u => u.id !== unitToRemove.id);
                            });
                            edge.units = [];
                        }
                    }
                });
            }
        }

    // --- UNIT BRUSH LOGIC ---
    } else if (brush.type === 'unit') {
        const { key: closestEdgeKey } = findClosestEdgeToPoint(x, y);
        if (!closestEdgeKey) return;

        if (isInternalBaseEdge(closestEdgeKey)) {
            showInstruction("Cannot place units inside base camp.", 2000);
            return;
        }

        if (!isEdgePlaceable(closestEdgeKey)) {
            showInstruction("Cannot place a unit on this edge.", 1500);
            return;
        }

        const edge = gameState.edges.get(closestEdgeKey);
        if (edge.units.length > 0 && edge.units[0].player !== brush.player) {
            showInstruction("Cannot place on an edge occupied by the enemy.", 2000);
            return;
        }
        if (edge.units.length >= 2) {
            showInstruction("This edge is full.", 1500);
            return;
        }
        
        const totalPlayerUnits = gameState.units.filter(u => u.player === brush.player).length;
        const maxUnits = getMaxUnitsForCurrentMap(); 
        if (totalPlayerUnits >= maxUnits) {
            showInstruction(`P${brush.player} has reached the maximum of ${maxUnits} units.`, 2000);
            return;
        }
        const playerUnitCounts = getUnitCountsForPlayer(brush.player);
        const unitCap = UNIT_CAPS[brush.value.name];
        if (playerUnitCounts[brush.value.name] >= unitCap) {
            showInstruction(`P${brush.player} cannot have more than ${unitCap} ${brush.value.name}s.`, 2000);
            return;
        }

        const newUnit = createUnit(brush.player, brush.value, closestEdgeKey);
        gameState.units.push(newUnit);
        edge.units.push(newUnit);
    }
    autoSaveMap();
}

        ui.downloadButton.addEventListener('click', () => {
            try {
                const pageHTML = document.documentElement.outerHTML; const blob = new Blob([pageHTML], { type: 'text/html' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'FortHex.html';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                showInstruction('Game HTML downloaded!', 2000);
            } catch (error) { console.error("Error downloading game:", error); showInstruction('Error downloading. See console.', 3000); }
        });

        if (ui.tutorialButton) {
            ui.tutorialButton.addEventListener('click', () => {
                if (ui.tutorialModalOverlay) {
                    ui.tutorialModalOverlay.style.display = 'flex'; 
                    setTimeout(() => {
                        ui.tutorialModalOverlay.classList.add('modal-visible');
                    }, 10); 
                }
            });
        }

        function closeTutorialModal() {
            if (ui.tutorialModalOverlay) {
                ui.tutorialModalOverlay.classList.remove('modal-visible');
                setTimeout(() => {
                    ui.tutorialModalOverlay.style.display = 'none';
                }, 300); 
            }
        }

        if (ui.tutorialCloseButton) {
            ui.tutorialCloseButton.addEventListener('click', closeTutorialModal);
        }
        if (ui.tutorialModalOverlay) {
            ui.tutorialModalOverlay.addEventListener('click', (event) => {
                if (event.target === ui.tutorialModalOverlay) { 
                    closeTutorialModal();
                }
            });
        }

        if (ui.tutorialSectionHeaders) {
            ui.tutorialSectionHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const arrow = header.querySelector('.tutorial-arrow');
                    const isActive = header.classList.contains('active');

                    ui.tutorialSectionHeaders.forEach(otherHeader => {
                        if (otherHeader !== header) {
                            otherHeader.classList.remove('active');
                            otherHeader.nextElementSibling.classList.remove('open');
                            const otherArrow = otherHeader.querySelector('.tutorial-arrow');
                            if (otherArrow) otherArrow.innerHTML = '&#9658;'; 
                        }
                    });

                    if (isActive) {
                        header.classList.remove('active');
                        content.classList.remove('open');
                        if (arrow) arrow.innerHTML = '&#9658;'; 
                    } else {
                        header.classList.add('active');
                        content.classList.add('open');
                        if (arrow) arrow.innerHTML = '&#9660;'; 
                    }
                });
            });
        }

        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        window.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
        canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleCanvasTouchEnd);
        canvas.addEventListener('touchcancel', handleCanvasTouchCancel);
        canvas.addEventListener('contextmenu', (event) => {
            // In map maker mode, this event handles erasing.
            if (gameState.mapMakerMode) {
                // ALWAYS prevent the default browser menu from appearing.
                event.preventDefault();

                // Get the coordinates of the right-click.
                const rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                // Call the erase function.
                eraseAt(x, y);
            }
        });

        window.onload = function () {
            document.getElementById('saveGameButton').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg> Save Game`;
            document.getElementById('loadGameButton').innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg> Load Game`;
            document.getElementById('buildVersionDisplay').textContent = `FortHex Build ${BUILD_VERSION}`;
            
            loadSettings(); // Load settings from localStorage into the gameSettings object
            loadColorPreferences(); // Load color preferences


            // Sync UI checkboxes to match the loaded settings
            document.getElementById('settingAnimations').checked = gameSettings.animationsEnabled;
            document.getElementById('settingFancyVisuals').checked = gameSettings.fancyVisualsEnabled;
            document.getElementById('settingPassTurnConfirmation').checked = gameSettings.passTurnConfirmationEnabled;
            document.getElementById('settingTooltips').checked = gameSettings.tooltipsEnabled;

            // --- Connection Status Indicator ---
            const connectionIcon = document.getElementById('connectionStatusIcon');

            function updateConnectionStatus() {
                if (navigator.onLine) {
                    connectionIcon.classList.remove('status-offline');
                    connectionIcon.classList.add('status-online');
                } else {
                    connectionIcon.classList.remove('status-online');
                    connectionIcon.classList.add('status-offline');
                }
            }

            window.addEventListener('online', updateConnectionStatus);
            window.addEventListener('offline', updateConnectionStatus);

            // Set initial state on load
            updateConnectionStatus();

            // --- Main Menu System Listeners ---
            document.getElementById('gameIconLink').addEventListener('click', (event) => {
                event.preventDefault(); 
                document.getElementById('customConfirmMessage').textContent = 'Are you sure you want to restart? Any unsaved progress will be lost.';
                currentConfirmAction = () => {
                    location.reload();
                };
                if (ui.customConfirmModal) {
                    ui.customConfirmModal.style.display = 'flex';
                    setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
                }
            });

            document.getElementById('gameMenuTrigger').addEventListener('click', () => {
                const modal = document.getElementById('gameMenuModal');
                document.getElementById('mainMenuContent').style.display = 'block';
                document.getElementById('singleplayerMenuContent').style.display = 'none';
                document.getElementById('multiplayerMenuContent').style.display = 'none';
                modal.style.display = 'flex';
                setTimeout(() => modal.classList.add('modal-visible'), 10);
            });

            const mainMenuContent = document.getElementById('mainMenuContent');
            const spMenuContent = document.getElementById('singleplayerMenuContent');
            const mpMenuContent = document.getElementById('multiplayerMenuContent');

            document.getElementById('singleplayerButton').addEventListener('click', () => {
                mainMenuContent.style.display = 'none';
                spMenuContent.style.display = 'block';
            });

            document.getElementById('multiplayerButton').addEventListener('click', () => {
                mainMenuContent.style.display = 'none';
                mpMenuContent.style.display = 'block';
            });

            document.getElementById('playAsBlueButton').addEventListener('click', () => startSingleplayerGame(1));
            document.getElementById('playAsRedButton').addEventListener('click', () => startSingleplayerGame(2));

document.getElementById('localMultiplayerButton').addEventListener('click', () => {
                // First, completely exit the map maker mode, which restores the UI.
                exitMapMakerMode(); 
                
                // Then, hide the menu modal.
                hideAllModals();
                
                gameState.gameMode = 'local';
                gameState.playerSide = null;

                // --- FIX: Reset Map Dimensions for Standard Play ---
                gameState.gridRadius = 3;
                gameState.renderScale = 1.0;
                gameState.renderOffset = { x: 0, y: 0 };
                // ---------------------------------------------------

                // Finally, initialize the new game grid.
                initializeGrid(DEFAULT_MAP_LAYOUT_RADIUS_3); 
                
                // The initializeGrid function calls updateTurnDisplay, which will now
                // correctly set the canvas border for Player 1.
                showInstruction("New Local Multiplayer game started.", 3000);
            });

            document.getElementById('backToMainMenuButtonSP').addEventListener('click', () => {
                spMenuContent.style.display = 'none';
                mainMenuContent.style.display = 'block';
            });
            document.getElementById('backToMainMenuButtonMP').addEventListener('click', () => {
                mpMenuContent.style.display = 'none';
                mainMenuContent.style.display = 'block';
            });

            document.getElementById('gameMenuModal').addEventListener('click', (e) => {
                if (e.target.id === 'gameMenuModal') {
                    const modal = e.target;
                    modal.classList.remove('modal-visible');
                    setTimeout(() => modal.style.display = 'none', 300);
                }
            });

            document.getElementById('mainMenuCloseButton').addEventListener('click', () => {
                const modal = document.getElementById('gameMenuModal');
                if (modal) {
                    modal.classList.remove('modal-visible');
                    setTimeout(() => modal.style.display = 'none', 300);
                }
            });

            const settingsButton = document.getElementById('settingsButton');
            const settingsModal = document.getElementById('settingsModal');
            const settingsBackButton = document.getElementById('settingsBackButton');
            const gameMenuModal = document.getElementById('gameMenuModal');

            settingsButton.addEventListener('click', () => {
                if (gameMenuModal) {
                    gameMenuModal.classList.remove('modal-visible');
                    setTimeout(() => { gameMenuModal.style.display = 'none'; }, 300);
                }
                if (settingsModal) {
                    setTimeout(() => {
                        settingsModal.style.display = 'flex';
                        setTimeout(() => settingsModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            settingsBackButton.addEventListener('click', () => {
                if (settingsModal) {
                    settingsModal.classList.remove('modal-visible');
                    setTimeout(() => { settingsModal.style.display = 'none'; }, 300);
                }
                if (gameMenuModal) {
                     setTimeout(() => {
                        gameMenuModal.style.display = 'flex';
                        setTimeout(() => gameMenuModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            settingsModal.addEventListener('click', (e) => {
                if (e.target.id === 'settingsModal') {
                    const modal = e.target;
                    modal.classList.remove('modal-visible');
                    setTimeout(() => modal.style.display = 'none', 300);
                }
            });

            // --- Changelog Modal Listeners ---
            const changelogButton = document.getElementById('changelogButton');
            const changelogModal = document.getElementById('changelogModal');
            const changelogBackButton = document.getElementById('changelogBackButton');

            changelogButton.addEventListener('click', () => {
                if (gameMenuModal) {
                    gameMenuModal.classList.remove('modal-visible');
                    setTimeout(() => { gameMenuModal.style.display = 'none'; }, 300);
                }
                if (changelogModal) {
                    setTimeout(() => {
                        changelogModal.style.display = 'flex';
                        setTimeout(() => changelogModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            changelogBackButton.addEventListener('click', () => {
                if (changelogModal) {
                    changelogModal.classList.remove('modal-visible');
                    setTimeout(() => { changelogModal.style.display = 'none'; }, 300);
                }
                if (gameMenuModal) {
                     setTimeout(() => {
                        gameMenuModal.style.display = 'flex';
                        setTimeout(() => gameMenuModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            changelogModal.addEventListener('click', (e) => {
                if (e.target.id === 'changelogModal') {
                    hideAllModals(); // Close all modals and return to the game
                }
            });

            const gameWrapper = document.getElementById('gameWrapper');
            const animationsCheckbox = document.getElementById('settingAnimations');
            const passTurnCheckbox = document.getElementById('settingPassTurnConfirmation');
            const fancyVisualsCheckbox = document.getElementById('settingFancyVisuals');
            const tooltipsCheckbox = document.getElementById('settingTooltips');
            const uiScaleSlider = document.getElementById('settingUiScale');
            const uiScaleValueLabel = document.getElementById('uiScaleValueLabel');

            function applyUiScale() {
                uiScaleSlider.value = gameSettings.uiScale;
                uiScaleValueLabel.textContent = `${Math.round(gameSettings.uiScale * 100)}%`;
                gameWrapper.style.transform = `scale(${gameSettings.uiScale})`;
            }

            loadSettings(); 

            animationsCheckbox.checked = gameSettings.animationsEnabled;
            passTurnCheckbox.checked = gameSettings.passTurnConfirmationEnabled;
            fancyVisualsCheckbox.checked = gameSettings.fancyVisualsEnabled;
            tooltipsCheckbox.checked = gameSettings.tooltipsEnabled;
            applyUiScale(); 

            animationsCheckbox.addEventListener('change', (e) => {
                gameSettings.animationsEnabled = e.target.checked;
                saveSettings();
            });

            passTurnCheckbox.addEventListener('change', (e) => {
                gameSettings.passTurnConfirmationEnabled = e.target.checked;
                saveSettings();
            });
            
            fancyVisualsCheckbox.addEventListener('change', (e) => {
                gameSettings.fancyVisualsEnabled = e.target.checked;
                saveSettings();
            });

            tooltipsCheckbox.addEventListener('change', (e) => {
                gameSettings.tooltipsEnabled = e.target.checked;
                saveSettings();
            });

            uiScaleSlider.addEventListener('input', (e) => {
                const scaleValue = parseFloat(e.target.value);
                gameSettings.uiScale = scaleValue;
                applyUiScale(); 
                saveSettings(); 
            });

            const customConfirmModalOverlay = document.getElementById('customConfirmModal');
            customConfirmModalOverlay.addEventListener('click', (event) => {
                if (event.target === customConfirmModalOverlay) {
                    if (ui.customConfirmModal) {
                        ui.customConfirmModal.classList.remove('modal-visible');
                        setTimeout(() => ui.customConfirmModal.style.display = 'none', 300);
                        currentConfirmAction = null; 
                    }
                }
            });

            const loadGameModalOverlay = document.getElementById('loadGameModal');
            loadGameModalOverlay.addEventListener('click', (event) => {
                if (event.target === loadGameModalOverlay) {
                    hideLoadGameModal();
                }
            });

            document.getElementById('loadGameModalCloseButton').addEventListener('click', hideLoadGameModal);

            document.getElementById('loadFromAutosaveButton').addEventListener('click', () => {
                if (localStorage.getItem('forthexSaveGame')) {
                    loadAutoSave();
                    hideLoadGameModal();
                } else {
                    showInstruction("No autosave found.", 2000);
                }
            });

            document.getElementById('loadFromFileButton').addEventListener('click', () => {
                document.getElementById('fileLoaderInput').click();
            });

            document.getElementById('fileLoaderInput').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);

                        switch(fileLoadContext) {
                            case 'game_save':
                                if (data.saveVersion !== BUILD_VERSION) {
                                    showInstruction("Save file is from an incompatible version.", 3000);
                                    return;
                                }
                                gameState = data;
                                rehydrateGameState();
                                fullGameRedraw();
                                hideLoadGameModal();
                                showInstruction("Game loaded from file!", 2000);
                                break;
                            
                            case 'edit_map':
                                if (loadMapFromDataObject(data)) {
                                    hideLoadGameModal();
                                }
                                break;

                            case 'play_map':
                                if (data.saveVersion !== BUILD_VERSION) {
                                    showInstruction("Map file is from an incompatible version.", 3000);
                                    return;
                                }
                                
                                exitMapMakerMode();
                                hideAllModals();

                                // 1. Determine Radius
                                let loadedRadius = data.radius;
                                if (!loadedRadius) {
                                    // Infer radius for legacy files
                                    let maxCoord = 0;
                                    data.tiles.forEach(([key]) => {
                                        const [q, r] = key.split(',').map(Number);
                                        const dist = Math.max(Math.abs(q), Math.abs(r), Math.abs(-q-r));
                                        if (dist > maxCoord) maxCoord = dist;
                                    });
                                    loadedRadius = maxCoord || 3;
                                }

                                // 2. Resize Grid (Sets Mode and Scale)
                                resizeMapGrid(loadedRadius);

                                // 3. Prepare and Initialize Data
                                const correctedUnits = data.units.map(unit => ({
                                    ...unit,
                                    typeName: unit.typeName.toUpperCase()
                                }));
                                const tileMap = new Map(data.tiles);

                                initializeGrid(tileMap, correctedUnits);

                                gameState.baseCampPositions = data.baseCampPositions;
                                if (gameState.flags) {
                                    gameState.flags.p1_flag.homePosition = data.baseCampPositions.player1;
                                    gameState.flags.p2_flag.homePosition = data.baseCampPositions.player2;
                                }

                                showInstruction(`Custom map '${file.name}' loaded. Player 1's turn.`, 4000);
                                break;
                        }
                    } catch (error) {
                        console.error("Failed to load from file:", error);
                        showInstruction("Error: Invalid or corrupted file.", 3000);
                    }
                };
                reader.readAsText(file);
                event.target.value = null; 
            });

const respawnChoicesDiv = document.getElementById('respawnChoices');
            if (respawnChoicesDiv) {
                respawnChoicesDiv.addEventListener('click', (event) => {
                    // FIX: Don't trigger respawn logic if in swap mode
                    const content = document.getElementById('respawnModalContent');
                    if (content.classList.contains('swap-mode')) return; 

                    const button = event.target.closest('.respawn-button');
                    if (button) {
                        const unitTypeName = button.dataset.unitType;
                        const unitType = UNIT_TYPES[unitTypeName];
                        
                        if (unitType) {
                            const spawnSuccess = spawnUnit(gameState.currentPlayer, unitType);

                            if (spawnSuccess) {
                                const queueKey = `player${gameState.currentPlayer}`;
                                gameState.respawnQueue[queueKey].shift(); 
                                updateRespawnQueueDisplay(); 
                                const queue = gameState.respawnQueue[queueKey];
                                const nextInQueue = queue.length > 0 ? queue[0] : null;

                                if (nextInQueue && nextInQueue.turnsRemaining <= 0) {
                                    showRespawnModal(gameState.currentPlayer);
                                } else {
                                    hideRespawnModal();
                                }
                            } else {
                                showInstruction("Could not spawn unit, base is blocked!", 3000);
                                hideRespawnModal();
                            }
                        }
                    }
                });
            }

            gameState.gridRadius = 3; // Use the default value directly
            initializeGrid();
            // This is the important call to our new function
            updateCssVariables(); 
            populateColorPickers();
            gameLoop();
            showInstruction("Project Hexblade Loaded. Player 1's Turn.", 3000);

            // --- Color Picker Drawer Logic ---
            const colorPickerDrawer = document.getElementById('colorPickerDrawer');
            const drawerHandle = document.getElementById('drawerHandle');
            const drawerTabs = document.getElementById('drawerTabs');
            const tabButtons = document.querySelectorAll('.drawer-tab-button');
            const drawerIcon = drawerHandle.querySelector('svg');
            const tabContent = document.getElementById('drawerTabContent');

            // This function now only CREATES the 5 circles once.
            function populateColorPickers() {
                const container = document.getElementById('color-options');
                if (!container) return;

                container.innerHTML = ''; // Clear any existing circles

                for (let i = 0; i < COLOR_THEMES.length; i++) {
                    const circle = document.createElement('div');
                    circle.className = 'color-option-circle';
                    circle.dataset.themeIndex = i;
                    // Player dataset is now set dynamically when tabs are switched
                    container.appendChild(circle);
                }

                // Set the initial colors and active state to Player 1's palette
                updateColorPickerCircles('player1');
            }

            // This function UPDATES the colors and active state of the 5 circles
            function updateColorPickerCircles(playerKey) {
                const container = document.getElementById('color-options');
                if (!container) return;
                const circles = container.querySelectorAll('.color-option-circle');
                const activeThemeIndex = gameState.playerColorSelections[playerKey];

                circles.forEach((circle, index) => {
                    const theme = COLOR_THEMES[index];
                    circle.style.backgroundColor = theme[playerKey].primary;
                    circle.dataset.player = playerKey.slice(-1); // Set player to '1' or '2'
                    
                    // Update which circle is highlighted as active
                    circle.classList.toggle('active', index === activeThemeIndex);
                });
            }

            // Helper function to update the drawer's border/icon colors based on the active tab
            function updateDrawerColors() {
                const activeTab = document.querySelector('.drawer-tab-button.active');
                if (!activeTab) return;

                const activePlayerKey = activeTab.dataset.tab === 'p1' ? 'player1' : 'player2';
                
                if (colorPickerDrawer.classList.contains('drawer-open')) {
                    colorPickerDrawer.style.borderColor = TEAM_COLORS[activePlayerKey].primary;
                    drawerHandle.style.borderColor = TEAM_COLORS[activePlayerKey].primary;
                    drawerIcon.style.stroke = TEAM_COLORS[activePlayerKey].accent;
                } else {
                    colorPickerDrawer.style.borderColor = '#F0F0F0';
                    drawerHandle.style.borderColor = '#F0F0F0';
                    drawerIcon.style.stroke = '#F0F0F0';
                }
            }

            // Event handler for clicking a color circle
            function handleColorSelection(event) {
                const circle = event.target.closest('.color-option-circle');
                if (!circle) return;

                const player = circle.dataset.player; // '1' or '2'
                const themeIndex = parseInt(circle.dataset.themeIndex, 10);
                const playerKey = `player${player}`;
                const otherPlayerKey = player === '1' ? 'player2' : 'player1';

                // --- Start the transition ---
                gameState.colorTransition.active = true;
                gameState.colorTransition.startTime = Date.now();
                
                // Store the 'from' and 'to' color objects for BOTH players
                gameState.colorTransition.from.player1 = { ...TEAM_COLORS.player1 };
                gameState.colorTransition.from.player2 = { ...TEAM_COLORS.player2 };
                gameState.colorTransition.to[playerKey] = { ...COLOR_THEMES[themeIndex][playerKey] };
                gameState.colorTransition.to[otherPlayerKey] = { ...TEAM_COLORS[otherPlayerKey] }; // The other player's color doesn't change

                // 1. Update the live TEAM_COLORS object for ONLY the selected player
                TEAM_COLORS[playerKey] = { ...COLOR_THEMES[themeIndex][playerKey] };
                gameState.playerColorSelections[playerKey] = themeIndex; // Remember this selection

                // 2. Update the active circle visuals
                const container = circle.parentElement;
                container.querySelectorAll('.color-option-circle').forEach(c => c.classList.remove('active'));
                circle.classList.add('active');

                // 3. Update all DOM UI elements instantly
                updateCssVariables();
                updateTurnDisplay();
                updateDrawerColors();
                saveColorPreferences();
            }

            // Open/Close the drawer
            drawerHandle.addEventListener('click', () => {
                colorPickerDrawer.classList.toggle('drawer-open');
                updateDrawerColors();
            });

            // Switch between P1 and P2 tabs
            drawerTabs.addEventListener('click', (e) => {
                const clickedButton = e.target.closest('.drawer-tab-button');
                if (!clickedButton) return;
                
                const targetTabId = clickedButton.dataset.tab;
                const playerKey = targetTabId === 'p1' ? 'player1' : 'player2';

                // Update button active state
                tabButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.tab === targetTabId);
                });

                // Update the circle colors and then the drawer border
                updateColorPickerCircles(playerKey);
                updateDrawerColors();
            });

            // Attach the click listener for selecting a color
            if (tabContent) {
                tabContent.addEventListener('click', handleColorSelection);
            }

            // Close drawer if clicking outside
            document.addEventListener('click', (e) => {
                if (colorPickerDrawer.classList.contains('drawer-open') && !colorPickerDrawer.contains(e.target)) {
                    colorPickerDrawer.classList.remove('drawer-open');
                    updateDrawerColors(); // Reset colors when closing
                }
            });

            // Prevent outside-click from firing on the handle itself
            drawerHandle.addEventListener('click', (e) => {
                e.stopPropagation();
            });

            // --- Scroll Fade Logic for Action Log ---
            const actionLogContent = document.getElementById('actionLogContent');
            const actionLogWrapper = document.getElementById('actionLogWrapper');
            if(actionLogContent && actionLogWrapper) {
                actionLogContent.addEventListener('scroll', () => {
                    if (actionLogContent.scrollTop > 0) {
                        actionLogWrapper.classList.add('is-scrolled');
                    } else {
                        actionLogWrapper.classList.remove('is-scrolled');
                    }
                });
            }

            // --- End of Color Picker Drawer Logic ---

document.querySelectorAll('.swap-choice').forEach(btn => {
    btn.addEventListener('click', (e) => {
        const typeName = e.target.dataset.type;
        const newType = UNIT_TYPES[typeName];
        if (gameState.selectedUnit) {
            performSwap(gameState.selectedUnit, newType);
            // Restore UI
            document.getElementById('swapSelectionPanel').style.display = 'none';
            document.getElementById('actionsPanel').style.display = 'flex';
            ui.endTurnButton.disabled = false; // Allow end turn now
        }
    });
});
        
        }
    </script>
          
<div id="buildVersionDisplay">FortHex Build B28//3</div>
<div id="confettiContainer"></div>

<div id="victoryInteractionBlocker" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 1999; display: none; background-color: rgba(44, 62, 80, 0.4); -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px); transition: background-color 0.5s ease, backdrop-filter 0.5s ease;"></div>

<div id="colorPickerDrawer">
    <div id="drawerHandle">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path>
        </svg>
    </div>
    <div id="drawerContent">
        <div id="drawerTabs">
            <button class="drawer-tab-button active p1-tab" data-tab="p1">P1</button>
            <button class="drawer-tab-button p2-tab" data-tab="p2">P2</button>
        </div>
        <div id="drawerTabContent">
            <div id="color-options" class="color-options-container"><div class="color-option-circle" data-theme-index="0" style="background-color: rgb(64, 96, 224);" data-player="1"></div><div class="color-option-circle" data-theme-index="1" style="background-color: rgb(64, 80, 208);" data-player="1"></div><div class="color-option-circle active" data-theme-index="2" style="background-color: rgb(64, 64, 192);" data-player="1"></div><div class="color-option-circle" data-theme-index="3" style="background-color: rgb(64, 48, 176);" data-player="1"></div><div class="color-option-circle" data-theme-index="4" style="background-color: rgb(64, 32, 160);" data-player="1"></div></div>
        </div>
    </div>
</div>

</body></html>