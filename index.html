<!doctype html>
<html lang="en"><head><script>(function() {
  const originalConsoleLog = console.log;
  const originalConsoleError = console.error;

  function stringifyArgs(args) {
    return args
      .map((arg) => {
        if (typeof arg === 'object') {
          try {
            return JSON.stringify(arg);
          } catch (error) {
            return '[Circular Object]';
          }
        } else {
          return String(arg);
        }
      })
      .join(' ');
  }

  console.log = function(...args) {
    const logString = stringifyArgs(args);
    window.parent.postMessage({ type: 'log', message: logString }, '*');
    originalConsoleLog.apply(console, args);
  };

  console.error = function(...args) {
    const errorString = stringifyArgs(args);
    window.parent.postMessage({ type: 'error', message: errorString }, '*');
    originalConsoleError.apply(console, args);
  };

  window.addEventListener('error', function(event) {
    const errorString = event.message + ' (' + event.filename + ':' + event.lineno + ':' + event.colno + ') ' + (event.error ? event.error.stack : '');
    window.parent.postMessage({ type: 'error', message: errorString }, '*');
  });

})();</script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FortHex</title>
        <link rel="icon" href="data:image/svg+xml,<svg version='1.1' xmlns='http://www.w3.org/2000/svg' width='300' height='300'><path d='M0,0 L6,0 L31,13 L52,25 L80,41 L106,56 L119,64 L119,200 L104,209 L78,224 L55,237 L32,250 L10,262 L6,264 L0,264 L-23,252 L-46,239 L-74,223 L-100,208 L-113,200 L-113,64 L-91,51 L-65,36 L-37,20 L-10,5 Z ' fill='%23000000' transform='translate(147,18)'/><path d='M0,0 L4,2 L17,24 L29,44 L39,61 L54,86 L67,108 L83,135 L98,160 L107,175 L107,179 L92,188 L83,193 L80,192 L63,163 L49,139 L34,113 L20,89 L5,63 L-11,36 L-23,15 L-22,12 L-6,3 Z ' fill='%23F8BD28' transform='translate(108,54)'/><path d='M0,0 L6,2 L30,16 L55,30 L79,44 L79,47 L52,62 L28,76 L12,85 L9,82 L-8,53 L-17,38 L-28,19 L-27,16 L-6,3 Z ' fill='%2333485D' transform='translate(149,30)'/><path d='M0,0 L2,0 L2,90 L-9,96 L-25,105 L-27,105 L-43,78 L-55,58 L-66,39 L-62,35 L-34,19 L-16,9 L-6,3 Z ' fill='%232B3D4F' transform='translate(253,121)'/><path d='M0,0 L5,0 L16,7 L16,24 L6,30 L-21,45 L-42,57 L-56,65 L-60,64 L-70,47 L-72,42 L-54,31 L-33,19 L-12,7 Z ' fill='%23C13F3F' transform='translate(239,83)'/><path d='M0,0 L4,1 L14,17 L15,23 L0,32 L-26,47 L-44,57 L-58,65 L-68,60 L-72,56 L-72,41 L-59,33 L-34,19 L-11,6 Z ' fill='%233F3FC1' transform='translate(117,153)'/></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Exo+2:wght@400;700&family=Geostar&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Exo 2', sans-serif;
            background-color: var(--bg-color);
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            padding-bottom: 100px;
            box-sizing: border-box; 
            overflow-x: auto;
        }
        #gameWrapper {
            min-width: 1300px; /* Force a minimum width to ensure layout doesn't break */
            transform-origin: top center; /* Scale from the top center */
            transition: transform 0.2s ease-in-out; /* Smooth scaling transition */
            padding-top: 60px; /* Add space at the top so it doesn't overlap the header icons */
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: #4a6075;
            border-radius: 5px;
            height: 10px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: #3090D0;
            cursor: pointer;
            border: 3px solid #ecf0f1;
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3090D0;
            cursor: pointer;
            border: 3px solid #ecf0f1;
        }

        .settings-option:has(input:disabled) label,
        .settings-option:has(input:disabled) span {
            color: #809090;
            cursor: not-allowed;
        }
        input[type="range"]:disabled {
            background: #2c3e50;
            cursor: not-allowed;
        }
        input[type="range"]:disabled::-webkit-slider-thumb {
            background: #809090;
            cursor: not-allowed;
        }
        input[type="range"]:disabled::-moz-range-thumb {
            background: #809090;
            cursor: not-allowed;
        }

        input[type="checkbox"]:disabled {
            background: #4a6075;
            border-color: #809090;
            cursor: not-allowed;
        }
        input[type="checkbox"]:disabled::before {
            box-shadow: inset 1em 1em #809090;
        }

        h1.text-4xl {
             font-family: 'Geostar', cursive;
        }

#confettiContainer {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Allows clicks to go through to the game */
    z-index: 9999; /* On top of everything */
    overflow: hidden;
}

.confetti-piece {
    position: absolute;
    width: 10px;
    height: 20px;
    opacity: 0.9;
    transform-origin: center;
}

#connectionStatusContainer {
    position: absolute;
    top: 20px;
    right: 20px;
    z-index: 2000;
}

#connectionStatusIcon {
    /* Sets the transition target to the 'color' property */
    transition: color 0.4s ease-in-out;
}
.status-online {
    /* We now control the color using the standard CSS 'color' property */
    color: #2ecc71; 
}
.status-offline {
    color: #E04030; /* Bright Red */
}

#topLeftControlsContainer {
    position: absolute;
    top: 20px;
    left: 20px;
    z-index: 2000;
    display: flex;
    align-items: center;
    gap: 15px;
}
#gameMenuTrigger {
    background-color: #34495e;
    border: 2px solid #ecf0f1;
    border-radius: 8px;
    padding: 6px 15px;
    cursor: pointer;
    transition: background-color 0.3s;
    display: flex;
    align-items: center;
    gap: 4px;
    font-size: 1.2em;
    font-weight: bold;
}

#gameIconLink {
    background-color: transparent;
    border: none;
    padding: 5px;
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    transition: background-color 0.3s;
}

#gameMenuTrigger:hover {
    background-color: #4a6075;
}
#gameIconLink:hover {
    background-color: rgba(74, 96, 117, 0.5);
}
.menu-options-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
    width: 100%;
}
.menu-options-container .action-button {
    width: 100%;
    padding: 12px 20px;
    font-size: 1.1em;
    margin: 0;
}

        .settings-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 12px 8px;
            background-color: var(--bg-color);
            border-radius: 5px;
            margin-bottom: 12px;
            border: 1px solid #4a6075;
        }

        .settings-option label {
            font-size: 1.1em;
            color: #ecf0f1;
            cursor: pointer;
        }

        .settings-option input[type="checkbox"] {
            -webkit-appearance: none;
            appearance: none;
            background-color: #4a6075;
            margin: 0;
            font: inherit;
            color: currentColor;
            width: 1.6em;
            height: 1.6em;
            border: 0.15em solid #809090;
            border-radius: 0.25em;
            transform: translateY(-0.075em);
            display: grid;
            place-content: center;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .settings-option input[type="checkbox"]::before {
            content: "";
            width: 0.85em;
            height: 0.85em;
            transform: scale(0);
            transition: 120ms transform ease-in-out;
            box-shadow: inset 1em 1em #FFC020;
            transform-origin: bottom left;
            clip-path: polygon(14% 44%, 0 65%, 50% 100%, 100% 16%, 80% 0%, 43% 62%);
        }

        .settings-option input[type="checkbox"]:checked {
            background-color: #3090D0;
            border-color: #2080B0;
        }

        .settings-option input[type="checkbox"]:checked::before {
            transform: scale(1);
        }

        #gameLayoutContainer {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 20px;
            width: 100%;
            max-width: 1400px;
            padding-left: 10px;
            padding-right: 10px;
            box-sizing: border-box;
        }
        canvas {
            background-color: var(--panel-color);
            border-radius: 10px;
            display: block;
            cursor: default;
            touch-action: none;
        }

        .ui-panel {
            background-color: var(--panel-color);
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            box-shadow: 0 0 10px rgba(0,0,0,0.3);
            display: flex;
            flex-direction: column;
            gap: 15px;
            flex: 0 0 280px;
            box-sizing: border-box;
            min-height: 595px;
            justify-content: flex-start;
        }

        #turnDisplay {
            font-size: 1.5em;
            margin-bottom: 0;
            color: #FFC020;
            text-align: center;
        }

        .ui-panel p {
            margin-bottom: 8px;
            font-size: 0.9em;
        }

        .buttons-container { /* This container is for End Turn Button */
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: auto; /* Pushes End Turn to bottom of right panel */
            padding-top: 15px;
        }
        .ui-panel .buttons-container button { /* End Turn specifics */
             background-color: #E04030;
             box-shadow: 0 3px #C03020;
             color: white;
             border: none;
             padding: 10px 15px;
             border-radius: 5px;
             font-family: 'Exo 2', sans-serif;
             cursor: pointer;
             transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
             display: flex;
             align-items: center;
             justify-content: center;
             gap: 8px;
        }
        .ui-panel .buttons-container button:hover:not(:disabled) {
            background-color: #C03020;
        }
         .ui-panel .buttons-container button:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }

        #settingsButton:hover:not(:disabled) {
        background-color: #708080;
    }

        #generateMapButtonContainer {
            display: flex;
            justify-content: center;
            width: 100%;
            margin-top: 20px; /* Space above button container */
            margin-bottom: 20px; /* Space below button container */
        }

        #downloadButton {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #27B060; 
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            box-shadow: 0 4px #208050; 
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 1001;
        }
        #downloadButton:hover:not(:disabled) {
            background-color: #208050; 
            box-shadow: 0 4px #207040; 
        }
        #downloadButton:active:not(:disabled) {
            box-shadow: 0 1px #207040; 
            transform: translateY(3px);
        }
        #downloadButton svg {
            width: 28px;
            height: 28px;
            stroke: white;
        }

        #tutorialButton {
            position: fixed;
            bottom: 90px; 
            left: 20px;
            width: 60px;
            height: 60px;
            background-color: #9040B0; 
            color: white;
            border: none;
            border-radius: 8px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.1s;
            box-shadow: 0 4px #703090;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            z-index: 1002;
        }
        #tutorialButton:hover:not(:disabled) {
            background-color: #703090; 
            box-shadow: 0 4px #502070; 
        }
        #tutorialButton:active:not(:disabled) {
            box-shadow: 0 1px #502070; 
            transform: translateY(3px);
        }
        #tutorialButton svg {
            width: 32px; 
            height: 32px;
            fill: white; 
        }


        .action-button {
            background-color: #3090D0;
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            font-family: 'Exo 2', sans-serif;
            cursor: pointer;
            transition: background-color 0.3s;
            box-shadow: 0 3px #2080B0;
            margin-left: 5px;
            margin-right: 5px;
        }
    .action-button.selecting {
        background-color: #E04030; /* Red base for cancel state */
        box-shadow: 0 3px #C03020;
    }
    .action-button.selecting:hover:not(:disabled) {
        background-color: #C03020; /* Dark red on hover */
    }
    .action-button:not(.selecting):hover:not(:disabled) {
         background-color: #2080B0;
    }
    .action-button:disabled {
        background-color: #90A0A0;
        color: #bdc3c7;
        cursor: not-allowed;
        box-shadow: 0 3px #809090;
    }
    .action-button:active:not(:disabled) {
         box-shadow: none;
        transform: translateY(3px);
    }

    /* --- Corrected Cancel Button Rules --- */
    .action-button-cancel {
        background-color: #E04030;
        box-shadow: 0 3px #C03020;
    }
    /* By specifying both classes, this rule becomes more specific and will override the generic blue hover. */
    .action-button.action-button-cancel:hover:not(:disabled) {
        background-color: #C03020;
    }
        #generateMapButtonContainer .action-button {
            width: 160px; 
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 10px 15px; 
            margin: 0; 
        }

        #saveGameButton {
            background-color: #F0A010; 
            box-shadow: 0 3px #D05000;
        }
        #saveGameButton:hover:not(:disabled) {
            background-color: #E08020;
        }
        #saveGameButton:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }
        #loadGameButton {
            background-color: #60B0E0; 
            box-shadow: 0 3px #3090D0;
        }
        #loadGameButton:hover:not(:disabled) {
            background-color: #3090D0;
        }
         #loadGameButton:active:not(:disabled) {
            box-shadow: none;
            transform: translateY(3px);
        }

        .unit-info-container {
            width: 100%;
        }
        .unit-info-container p { font-size: 1em; margin: 4px 0; }

        .actions-panel {
            padding-top: 10px;
            border-top: 1px solid #809090;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
            width: 100%;
        }
        .actions-panel h3 {
            font-size: 1.em;
            margin-bottom: 10px;
            color: #FFC020;
            width: 100%;
            text-align: center;
        }
        .message-box {
            position: fixed; top: 20px; left: 50%;
            transform: translateX(-50%); background-color: #E04030;
            color: white; padding: 15px 25px; border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3); z-index: 1000;
            font-size: 1em; display: none;
            text-align: center;
            max-width: 90%;
        }
        .victory-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #2ecc71;
            color: white;
            padding: 30px 50px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            z-index: 2000;
            font-size: 2em;
            text-align: center;
            display: none;
        }
        /* Custom Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 3000; 
            opacity: 0; 
            visibility: hidden; 
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s;
        }
        .modal-overlay.modal-visible { 
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0s; 
        }

        .modal-content {
            background-color: var(--panel-color);
            padding: 25px 30px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            text-align: center;
            width: 90%;
            max-width: 400px;
            color: #ecf0f1;
        }
        .modal-content p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        .modal-buttons {
            display: flex;
            justify-content: space-around;
            gap: 15px;
        }
        .modal-buttons button {
            font-family: 'Exo 2', sans-serif;
            padding: 10px 20px;
            border-radius: 5px;
            border: none;
            cursor: pointer;
            font-size: 1em;
            transition: background-color 0.3s, box-shadow 0.3s;
            color: white;
        }
        .modal-button-ok {
            background-color: #20B060;
            box-shadow: 0 3px #208040;
        }
        .modal-button-ok:hover {
            background-color: #209050;
        }
        .modal-button-cancel {
            background-color: #E04030;
            box-shadow: 0 3px #C03020;
        }
        .modal-button-cancel:hover {
            background-color: #C03020;
        }

#loadOptionsContainer .action-button {
    width: 100%;
    padding: 12px 20px;
    font-size: 1.1em;
    display: flex;
    justify-content: center;
    gap: 10px;
    margin: 0;
}
#loadFromAutosaveButton {
    background-color: #3090D0;
    box-shadow: 0 3px #2080B0;
}
#loadFromAutosaveButton:hover:not(:disabled) {
    background-color: #2080B0;
}
#loadFromFileButton {
    background-color: #20B060;
    box-shadow: 0 3px #208040;
}
#loadFromFileButton:hover:not(:disabled) {
    background-color: #209050;
}

#newMapButton {
    width: 160px;
    background-color: #FFC020; 
    box-shadow: 0 3px #D0B000;
}

#newMapButton:hover:not(:disabled) {
    background-color: #D0B000;
}
#newMapOptionsContainer {
    display: flex;
    justify-content: center;
    gap: 15px;
    width: 100%;
}
#generateMapFromModalButton {
    background-color: #20B060;
    box-shadow: 0 3px #208040;
}
#generateMapFromModalButton:hover:not(:disabled) {
    background-color: #209050;
}

.action-button-cancel {
    background-color: #E04030;
    box-shadow: 0 3px #C03020;
}
.action-button-cancel:hover:not(:disabled) {
    background-color: #C03020;
}

        /* Tutorial Modal Styles */
        #tutorialModalOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(44, 62, 80, 0.7); 
            -webkit-backdrop-filter: blur(3px); 
            backdrop-filter: blur(3px);
            display: none; 
            align-items: center;
            justify-content: center;
            z-index: 2900; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0.3s; 
        }
        #tutorialModalOverlay.modal-visible { 
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease-in-out, visibility 0s linear 0s; 
        }

        #tutorialModalContent {
            background-color: var(--panel-color);
            padding: 20px 30px;
            border-radius: 10px;
            border: 2px solid #ecf0f1;
            box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            color: #ecf0f1;
            width: 90%;
            max-width: 700px; 
            max-height: 80vh; 
            overflow-y: auto;
            position: relative; 
            text-align: left; 
        }
        #tutorialModalContent h2 {
            font-family: 'Geostar', cursive;
            font-size: 2em;
            text-align: center;
            margin-bottom: 15px;
            color: #FFC020;
        }
        #tutorialModalContent p, #tutorialModalContent li {
            font-size: 0.95em;
            margin-bottom: 10px;
            line-height: 1.6;
        }
        #tutorialModalContent strong {
            color: #FFC020;
        }
        #tutorialModalContent ul {
            list-style-type: disc;
            padding-left: 20px;
            margin-bottom:10px;
        }
        .tutorial-modal-close-button {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: #ecf0f1;
            font-size: 2em;
            cursor: pointer;
            line-height: 1;
        }
        .tutorial-modal-close-button:hover {
            color: #FFC020;
        }
        .tutorial-section {
            margin-bottom: 15px;
            border-bottom: 1px solid #4a6075;
            padding-bottom: 10px;
        }
        .tutorial-section:last-child {
            border-bottom: none;
            padding-bottom: 0;
        }
        .tutorial-section-header {
            font-size: 1.2em;
            font-weight: bold;
            cursor: pointer;
            padding: 10px 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #20C0A0; 
        }
        .tutorial-section-header:hover {
            color: #10A080;
        }
        .tutorial-section-content {
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            padding-left: 15px; 
            padding-top: 0px; 
            transition: max-height 0.35s ease-in-out, opacity 0.3s ease-in-out, padding-top 0.35s ease-in-out;
        }
        .tutorial-section-content.open {
            opacity: 1;
            padding-top: 5px; 
             max-height: 1000px; 
        }
        .tutorial-arrow {
            font-size: 0.8em;
            margin-left: 10px;
            transition: transform 0.2s ease-in-out;
        }
        .tutorial-section-header.active .tutorial-arrow {
            transform: rotate(90deg);
        }

        .action-info-header {
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #FFC020;
            width: 100%;
            text-align: center;
            font-weight: bold;
        }
        
         #actionInfoContainer {
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }
        
        #actionLogContent {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px; 
            margin-right: -10px; 
            min-height: 120px;
            display: flex;
            flex-direction: column; 
            justify-content: flex-start;
        }

        #actionLogContent::-webkit-scrollbar {
            width: 8px;
        }
        #actionLogContent::-webkit-scrollbar-track {
            background: #2c3e50;
            border-radius: 4px;
        }
        #actionLogContent::-webkit-scrollbar-thumb {
            background: #4a6075;
            border-radius: 4px;
        }
        #actionLogContent::-webkit-scrollbar-thumb:hover {
            background: #5e7a97;
        }
        .log-entry {
            display: flex;
            align-items: flex-start;
            gap: 10px;
            padding: 8px;
            background-color: var(--bg-color);
            border-radius: 4px;
            margin-top: 5px;
            animation: fadeIn 0.3s ease-in-out;
            transition: border-color 0.4s ease-in-out;
        }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }

        .log-entry.log-p1 {
            border: 2px solid #5dade2; 
        }
        .log-entry.log-p2 {
            border: 2px solid #E04030; 
        }

        .log-icon {
            flex-shrink: 0;
            width: 20px;
            height: 20px;
            margin-top: 0px;
        }
        .log-message {
            font-size: 0.9em;
            line-height: 1.5;
            color: #bdc3c7;
            word-break: break-word;
        }
        .log-message strong { font-weight: bold; }
        .p1-log { color: #5dade2 !important; } 
        .p2-log { color: #E04030 !important; }
        .log-message .damage-text { color: #FFC020; }
        .log-message .heal-text { color: #2ecc71; }
        .log-message .shield-text { color: #30C4C4; }
        .log-message .advantage-text { color: #2ecc71; }
        .log-message .disadvantage-text { color: #E04030; }
        .log-message .keyword-text { color: #F0A010; }

        .respawn-queue-container {
            border-top: 1px solid #809090;
            padding-top: 15px;
            margin-top: auto;
        }
        .respawn-queue-header {
            text-align: center;
            color: #FFC020;
            margin-bottom: 10px;
            font-size: 1.1em;
        }
        .respawn-queue-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .respawn-item {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background-color: var(--bg-color);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.9em;
        }
        .respawn-unit-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .respawn-unit-symbol {
            font-weight: bold;
            font-size: 1.2em;
        }
        .respawn-timer {
            font-weight: bold;
            color: #FFC020;
        }

        /* RESPAWN MODAL STYLES */
        #respawnModalContent {
            text-align: center;
            width: auto;
            max-width: 500px;
            /* Border color will be set by JS */
            transition: border-color 0.3s ease-in-out; 
        }
        #respawnModalContent.modal-p1 { border-color: #5dade2; }
        #respawnModalContent.modal-p2 { border-color: #E04030; }

        #respawnModalContent h3 {
            font-family: 'Geostar', cursive;
            font-size: 1.8em;
            color: #FFC020;
            margin-bottom: 10px;
        }
        #respawnModalContent p {
            font-size: 1.1em;
            margin-bottom: 20px;
        }
        #respawnChoices {
            display: flex; 
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
        }
        .respawn-button {
            background-color: #20B060; 
            color: white;
            border: none;
            width: 70px;
            height: 70px;
            border-radius: 50%; 
            font-family: 'Exo 2', sans-serif;
            font-size: 1em;
            cursor: pointer;
            transition: background-color 0.3s, box-shadow 0.3s, transform 0.2s;
            box-shadow: 0 4px #208040; 
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .respawn-button svg {
            width: 40px;
            height: 40px;
            stroke: white;
            fill: white;
        }
        .respawn-button:hover:not(:disabled) {
            background-color: #209050;
            transform: translateY(-2px);
        }
        .respawn-button:active:not(:disabled) {
            transform: translateY(2px);
            box-shadow: 0 1px #208040;
        }
        .respawn-button:disabled {
            background-color: #809090;
            cursor: not-allowed;
            box-shadow: 0 4px #525a5b;
            opacity: 0.6;
        }
        #buildVersionDisplay {
            position: fixed;
            bottom: 10px;
            right: 15px;
            font-size: 0.8em;
            color: #ecf0f1;
            opacity: 0.6;
            z-index: 1000;
            pointer-events: none; /* Prevents it from blocking clicks on anything underneath */
        }

    </style>
    <style>*, ::before, ::after{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }::backdrop{--tw-border-spacing-x:0;--tw-border-spacing-y:0;--tw-translate-x:0;--tw-translate-y:0;--tw-rotate:0;--tw-skew-x:0;--tw-skew-y:0;--tw-scale-x:1;--tw-scale-y:1;--tw-pan-x: ;--tw-pan-y: ;--tw-pinch-zoom: ;--tw-scroll-snap-strictness:proximity;--tw-gradient-from-position: ;--tw-gradient-via-position: ;--tw-gradient-to-position: ;--tw-ordinal: ;--tw-slashed-zero: ;--tw-numeric-figure: ;--tw-numeric-spacing: ;--tw-numeric-fraction: ;--tw-ring-inset: ;--tw-ring-offset-width:0px;--tw-ring-offset-color:#fff;--tw-ring-color:rgb(59 130 246 / 0.5);--tw-ring-offset-shadow:0 0 #0000;--tw-ring-shadow:0 0 #0000;--tw-shadow:0 0 #0000;--tw-shadow-colored:0 0 #0000;--tw-blur: ;--tw-brightness: ;--tw-contrast: ;--tw-grayscale: ;--tw-hue-rotate: ;--tw-invert: ;--tw-saturate: ;--tw-sepia: ;--tw-drop-shadow: ;--tw-backdrop-blur: ;--tw-backdrop-brightness: ;--tw-backdrop-contrast: ;--tw-backdrop-grayscale: ;--tw-backdrop-hue-rotate: ;--tw-backdrop-invert: ;--tw-backdrop-opacity: ;--tw-backdrop-saturate: ;--tw-backdrop-sepia: ;--tw-contain-size: ;--tw-contain-layout: ;--tw-contain-paint: ;--tw-contain-style: }/* ! tailwindcss v3.4.16 | MIT License | https://tailwindcss.com */*,::after,::before{box-sizing:border-box;border-width:0;border-style:solid;border-color:#e5e7eb}::after,::before{--tw-content:''}:host,html{line-height:1.5;-webkit-text-size-adjust:100%;-moz-tab-size:4;tab-size:4;font-family:ui-sans-serif, system-ui, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";font-feature-settings:normal;font-variation-settings:normal;-webkit-tap-highlight-color:transparent}body{margin:0;line-height:inherit}hr{height:0;color:inherit;border-top-width:1px}abbr:where([title]){-webkit-text-decoration:underline dotted;text-decoration:underline dotted}h1,h2,h3,h4,h5,h6{font-size:inherit;font-weight:inherit}a{color:inherit;text-decoration:inherit}b,strong{font-weight:bolder}code,kbd,pre,samp{font-family:ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;font-feature-settings:normal;font-variation-settings:normal;font-size:1em}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}table{text-indent:0;border-color:inherit;border-collapse:collapse}button,input,optgroup,select,textarea{font-family:inherit;font-feature-settings:inherit;font-variation-settings:inherit;font-size:100%;font-weight:inherit;line-height:inherit;letter-spacing:inherit;color:inherit;margin:0;padding:0}button,select{text-transform:none}button,input:where([type=button]),input:where([type=reset]),input:where([type=submit]){-webkit-appearance:button;background-color:transparent;background-image:none}:-moz-focusring{outline:auto}:-moz-ui-invalid{box-shadow:none}progress{vertical-align:baseline}::-webkit-inner-spin-button,::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}summary{display:list-item}blockquote,dd,dl,figure,h1,h2,h3,h4,h5,h6,hr,p,pre{margin:0}fieldset{margin:0;padding:0}legend{padding:0}menu,ol,ul{list-style:none;margin:0;padding:0}dialog{padding:0}textarea{resize:vertical}input::placeholder,textarea::placeholder{opacity:1;color:#9ca3af}[role=button],button{cursor:pointer}:disabled{cursor:default}audio,canvas,embed,iframe,img,object,svg,video{display:block;vertical-align:middle}img,video{max-width:100%;height:auto}[hidden]:where(:not([hidden=until-found])){display:none}.mb-6{margin-bottom:1.5rem}.text-center{text-align:center}.text-4xl{font-size:2.25rem;line-height:2.5rem}.font-bold{font-weight:700}.text-amber-400{--tw-text-opacity:1;color:rgb(251 191 36 / var(--tw-text-opacity, 1))}</style>
        <style>
        :root {
            --p1-color-secondary: #60B0E0;
            --p2-color-secondary: #F05040;
            --bg-color: #304050;
            --panel-color: #304860;
        }
        #turnDisplay.player1, .log-entry.log-p1, #respawnModalContent.modal-p1 {
            border-color: var(--p1-color-secondary);
        }
        #turnDisplay.player2, .log-entry.log-p2, #respawnModalContent.modal-p2 {
            border-color: var(--p2-color-secondary);
        }
        .p1-log, #p1Supply {
            color: var(--p1-color-secondary) !important;
        }
        .p2-log, #p2Supply {
            color: var(--p2-color-secondary) !important;
        }

        #p1Supply, #p2Supply {
            transition: color 0.4s ease-in-out;
        }
        
        .log-message strong {
            transition: color 0.4s ease-in-out;
        }

        #turnDisplay {
            transition: border-color 0.4s ease-in-out;
        }
        #gameCanvas {
             outline-width: 4px;
             outline-style: solid;
             outline-offset: 2px;
             transition: outline-color 0.4s ease-in-out;
        }


/* --- Color Picker Drawer Styles --- */
#colorPickerDrawer {
    position: fixed;
    top: 50%;
    right: -130px;
    width: 130px;
    transform: translateY(-50%);
    background-color: var(--panel-color);
    border: 2px solid #ecf0f1;
    border-right: none;
    border-radius: 15px 0 0 15px;
    z-index: 2500;
    box-shadow: -5px 0 15px rgba(0,0,0,0.3);
    /* Explicitly define all transitions here */
    transition-property: right, border-color;
    transition-duration: 0.4s, 0.4s;
    transition-timing-function: cubic-bezier(0.25, 0.46, 0.45, 0.94), ease-in-out;
}

#colorPickerDrawer.drawer-open {
    /* End position: drawer is flush with the right edge */
    right: 0;
}

#drawerHandle {
    position: absolute;
    top: 50%;
    left: -40px; /* Adjusted handle width */
    transform: translateY(-50%);
    width: 40px; /* Adjusted handle width */
    height: 70px;
    background-color: var(--panel-color);
    border: 2px solid #ecf0f1;
    border-right: none;
    border-radius: 12px 0 0 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: #ecf0f1;
    transition: border-color 0.4s ease-in-out;
}

#drawerHandle svg {
    stroke: #ecf0f1;
    transition: transform 0.3s ease-in-out, stroke 0.4s ease-in-out;
}

#colorPickerDrawer.drawer-open #drawerHandle svg {
    transform: rotate(90deg);
}

#drawerContent {
    padding: 20px;
    height: 400px; /* Example height */
    display: flex;
    flex-direction: column;
}

#drawerTabs {
    display: flex;
    border-bottom: 2px solid #4a6075;
    margin-bottom: 15px;
}

.drawer-tab-button {
    flex-grow: 1;
    padding: 10px;
    background-color: transparent;
    border: none;
    color: #bdc3c7;
    font-size: 1.1em;
    font-family: 'Exo 2', sans-serif;
    font-weight: bold;
    cursor: pointer;
    border-bottom: 3px solid transparent;
    transition: color 0.4s ease-in-out, border-color 0.4s ease-in-out;
}

.drawer-tab-button:hover {
    color: #ecf0f1;
}

.drawer-tab-button.active.p1-tab {
    color: var(--p1-color-secondary);
    border-bottom-color: var(--p1-color-secondary);
}
.drawer-tab-button.active.p2-tab {
    color: var(--p2-color-secondary);
    border-bottom-color: var(--p2-color-secondary);
}

.drawer-tab-panel {
    display: none; /* Hide all panels by default */
}

.drawer-tab-panel.active {
    display: block; /* Show only the active panel */
}

.color-options-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center; /* Center the whole group vertically */
    gap: 10px; 
    padding-top: 15px;
    padding-bottom: 15px;
    width: 100%;
    height: 100%; 
}

.color-option-circle {
    width: 45px;  /* Increased size */
    height: 45px; /* Increased size */
    border-radius: 50%;
    background-color: #4a6075; 
    border: 3px solid #bdc3c7; /* A slightly thicker border */
    cursor: pointer;
    transition: transform 0.2s ease-in-out, border-color 0.2s ease-in-out, background-color 0.4s ease-in-out; 
}

.color-option-circle:hover {
    transform: scale(1.1);
    border-color: #ecf0f1; /* Brighten border on hover */
}

.color-option-circle.active {
    border-color: #FFC020;
    transform: scale(1.15);
}

#changelogButton {
    background-color: #20B060;
    box-shadow: 0 3px #208040;
}
#changelogButton:hover:not(:disabled) {
    background-color: #209050;
}

    </style>
</head>
<body>
<h1 class="text-4xl font-bold mb-6 text-center text-amber-400">FortHex</h1>

<div id="connectionStatusContainer">       
<svg id="connectionStatusIcon" fill="currentColor" height="34" width="34" version="1.1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 494.45 494.45">
        <g>
            <path d="M395.225,277.325c-6.8,0-13.5-2.6-18.7-7.8c-71.4-71.3-187.4-71.3-258.8,0c-10.3,10.3-27.1,10.3-37.4,0 s-10.3-27.1,0-37.4c92-92,241.6-92,333.6,0c10.3,10.3,10.3,27.1,0,37.4C408.725,274.725,401.925,277.325,395.225,277.325z"/>
            <path d="M323.625,348.825c-6.8,0-13.5-2.6-18.7-7.8c-15.4-15.4-36-23.9-57.8-23.9s-42.4,8.5-57.8,23.9 c-10.3,10.3-27.1,10.3-37.4,0c-10.3-10.3-10.3-27.1,0-37.4c25.4-25.4,59.2-39.4,95.2-39.4s69.8,14,95.2,39.5 c10.3,10.3,10.3,27.1,0,37.4C337.225,346.225,330.425,348.825,323.625,348.825z"/>
            <circle cx="247.125" cy="398.925" r="35.3"/>
            <path d="M467.925,204.625c-6.8,0-13.5-2.6-18.7-7.8c-111.5-111.4-292.7-111.4-404.1,0c-10.3,10.3-27.1,10.3-37.4,0 s-10.3-27.1,0-37.4c64-64,149-99.2,239.5-99.2s175.5,35.2,239.5,99.2c10.3,10.3,10.3,27.1,0,37.4 C481.425,202.025,474.625,204.625,467.925,204.625z"/>
        </g>
    </svg>
</div>

<!-- NEW MENU TRIGGER BUTTON -->
<div id="topLeftControlsContainer">
    <a id="gameIconLink" title="Restart Game">
        <svg version="1.0" width="38" height="38" viewBox="0 0 225 225" preserveAspectRatio="xMidYMid meet" xmlns="http://www.w3.org/2000/svg">
            <g transform="translate(0,225)scale(.075,.075)">
                <path fill="white" d="M 929 -2512 c -294 169 -547 315 -562 325 l -27 17 0 670 0 670 37 24 c 21 13 275 160 565 325 372 212 537 301 558 301 21 0 186 -89 558 -301 290 -165 544 -312 564 -325 l 38 -24 0 -670 0 -670 -38 -24 c -20 -13 -274 -160 -564 -325 -404 -231 -535 -301 -560 -300 -24 0 -177 82 -569 307 z m 972 39 l 397 227 -297 169 c -163 93 -319 182 -347 198 l -51 29 -196 -329 c -108 -182 -198 -335 -199 -342 -2 -10 273 -179 292 -179 3 0 183 102 401 227 z m -506 503 c 158 267 393 661 521 877 129 216 237 398 239 405 4 9 -39 39 -126 88 -72 41 -133 74 -136 73 -4 -2 -251 -423 -528 -903 -172 -297 -495 -852 -510 -875 -12 -20 -6 -25 113 -93 70 -39 130 -68 133 -64 3 4 136 225 294 492 z m 1143 -137 c 9 7 12 35 10 94 l -3 85 -370 208 c -203 115 -370 208 -371 207 -12 -13 -134 -225 -134 -232 0 -5 168 -105 373 -222 l 372 -211 55 31 c 30 16 61 35 68 40 z m 10 764 l -3 447 -135 78 c -74 43 -138 78 -141 78 -7 0 -399 -656 -399 -668 1 -7 659 -381 673 -382 4 0 6 201 5 447 z m -1281 -22 c 35 61 62 113 61 117 -2 5 -170 102 -373 217 l -370 209 -55 -30 c -83 -47 -80 -42 -80 -129 l 0 -78 368 -210 c 202 -115 371 -209 376 -207 5 1 38 51 73 111 z "></path>
            </g>
        </svg>
    </a>
    <a id="gameMenuTrigger">
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="3" y1="12" x2="21" y2="12"></line>
        <line x1="3" y1="6" x2="21" y2="6"></line>
        <line x1="3" y1="18" x2="21" y2="18"></line>
    </svg>
    Menu
</a>
</div>



<!-- UNIFIED GAME MENU MODAL -->
<div id="gameMenuModal" class="modal-overlay">
    <div class="modal-content">
        <!-- Main Menu Content (Visible by default) -->
        <div id="mainMenuContent">
            <h2 class="text-4xl" style="font-family: 'Geostar', cursive; color: #FFC020; margin-bottom: 30px;">FortHex</h2>
            <div class="menu-options-container">
                <button id="singleplayerButton" class="action-button" >Singleplayer (WIP)</button>
                <button id="multiplayerButton" class="action-button">Multiplayer</button>
                <button id="changelogButton" class="action-button">Changelog</button>
                <button id="settingsButton" class="action-button" style="background-color: #90A0A0; box-shadow: 0 3px #708080; margin-top: 10px; display: flex; align-items: center; justify-content: center; gap: 8px;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="3"></circle>
                        <path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path>
                    </svg>
                    Settings
                </button>
            </div>
        </div>

        <!-- Singleplayer Menu Content (Hidden by default) -->
        <div id="singleplayerMenuContent" style="display: none;">
            <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Choose Your Side</h3>
            <div class="menu-options-container">
                <button id="playAsBlueButton" class="action-button" style="background-color: #5dade2; box-shadow: 0 3px #3090D0;">Play as Blue (P1)</button>
                <button id="playAsRedButton" class="action-button" style="background-color: #E04030; box-shadow: 0 3px #C03020;">Play as Red (P2)</button>
            </div>
            <button id="backToMainMenuButtonSP" class="action-button action-button-cancel" style="margin-top: 25px;">Back</button>
        </div>

        <!-- Multiplayer Menu Content (Hidden by default) -->
        <div id="multiplayerMenuContent" style="display: none;">
             <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Multiplayer</h3>
            <div class="menu-options-container">
                <button id="localMultiplayerButton" class="action-button">Local</button>
                <button id="onlineMultiplayerButton" class="action-button" disabled>Online (Coming Soon)</button>
            </div>
             <button id="backToMainMenuButtonMP" class="action-button action-button-cancel" style="margin-top: 25px;">Back</button>
        </div>
    </div>
</div>

<!-- SETTINGS MODAL -->
<div id="settingsModal" class="modal-overlay">
    <div class="modal-content">
        <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Settings</h3>
        <div id="settingsOptionsContainer">
            <div class="settings-option">
                <label for="settingFancyVisuals">Fancy Visuals</label>
                <input type="checkbox" id="settingFancyVisuals" name="fancyVisuals" checked>
            </div>
            <div class="settings-option">
                <label for="settingAnimations">Animations</label>
                <input type="checkbox" id="settingAnimations" name="animations" checked>
            </div>
            <div class="settings-option">
                <label for="settingPassTurnConfirmation">Pass Turn Confirmation</label>
                <input type="checkbox" id="settingPassTurnConfirmation" name="passTurnConfirmation" checked>
            </div>
            <div class="settings-option">
                <label for="settingTooltips">Tooltips</label>
                <input type="checkbox" id="settingTooltips" name="tooltips" disabled>
            </div>
            <div class="settings-option" style="flex-direction: column; align-items: flex-start; padding-top: 15px; padding-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; width: 100%; margin-bottom: 10px;">
                    <label for="settingUiScale">UI Scale</label>
                    <span id="uiScaleValueLabel">100%</span>
                </div>
                <input type="range" id="settingUiScale" min="0.5" max="1.5" value="1" step="0.05" style="width: 100%;" disabled>
            </div>

    
        </div>
        <button id="settingsBackButton" class="action-button action-button-cancel" style="margin-top: 30px; width: 100%;">Back</button>
    </div>
</div>

<!-- COMPLETE CHANGELOG MODAL -->
<div id="changelogModal" class="modal-overlay">
    <div class="modal-content" style="max-width: 500px; text-align: left;">
        <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px; text-align: center;">Changelog</h3>
        <div id="changelogList" style="max-height: 50vh; overflow-y: auto; padding-right: 15px;">
            <h4 style="font-weight: bold; color: #20C0A0; margin-bottom: 10px; font-size: 1.2em;">B27: The Color Update</h4>
            
<ul style="list-style-type: disc; padding-left: 20px;">
    <li style="margin-bottom: 15px;">
        <strong style="color: #F0C020;">Feature: Team Color Customizer!</strong>
        <ul style="list-style-type: circle; padding-left: 20px; margin-top: 5px;">
            <li>A new slide-out drawer on the right allows you to change team colors at any time.</li>
            <li>Choose from 5 distinct color themes for each player independently.</li>
            <li>Your color choices are now saved to your browser and will be remembered for your next game!</li>
        </ul>
    </li>
    <li style="margin-bottom: 15px;">
        <strong style="color: #F0C020;">Feature: Changelog System</strong>
        <ul style="list-style-type: circle; padding-left: 20px; margin-top: 5px;">
            <li>Added a new 'Changelog' button to the main menu so you can see what's new in each update.</li>
        </ul>
    </li>
    <li style="margin-bottom: 15px;">
        <strong style="color: #F0C020;">Improvement: Complete Color System Overhaul</strong>
        <ul style="list-style-type: circle; padding-left: 20px; margin-top: 5px;">
            <li>All team and UI colors have been unified into a central system, making the game's theme consistent and easier to update.</li>
            <li>All button colors across the UI have been updated to a new, quantized color palette for a more cohesive visual style.</li>
        </ul>
    </li>
    <li style="margin-bottom: 15px;">
        <strong style="color: #F0C020;">Improvement: Smooth Visual Transitions</strong>
        <ul style="list-style-type: circle; padding-left: 20px; margin-top: 5px;">
            <li>All UI elements, units, fortification outlines, and supply lines now transition their colors smoothly when a new theme is selected.</li>
        </ul>
    </li>
</ul>

        </div>
        <button id="changelogBackButton" class="action-button action-button-cancel" style="margin-top: 30px; width: 100%;">Back</button>
    </div>
</div>

<div id="gameLayoutContainer">
        <div id="leftPanel" class="ui-panel">
            <div>
                <div id="globalTurnCounterDisplay" class="text-center" style="font-size: 1.5em; color: #FFC020;">Turn: 1</div>
                <div id="supplyPointsContainer" class="text-center" style="font-size: 0.9em; margin-top: 8px;">
                    <span>P1 Supply: <span id="p1Supply">10</span></span> | 
                    <span>P2 Supply: <span id="p2Supply">10</span></span>
                </div>
                <hr style="width: 100%; border-color: #4a6075; margin-top: 10px;">
            </div>
            <div id="selectedUnitInfoContainer" class="unit-info-container" style="display: none;">
                <div id="selectedUnitInfo">
                    <p><strong>Selected Unit:</strong> <span id="unitName"></span></p>
                    <p><strong>HP:</strong> <span id="unitHP"></span>/<span id="unitMaxHP"></span></p>
                    <p><strong>Movement:</strong> <span id="unitMovement"></span></p>
                    <p><strong>Position:</strong> <span id="unitPosition"></span></p>
                    <p><strong>Status:</strong> <span id="unitStatus"></span></p>
                </div>
            </div>
             <!-- ACTION INFO PANEL STRUCTURE -->
            <div id="actionInfoContainer" class="unit-info-container">
                <h3 class="action-info-header">Action Log</h3>
                <div id="actionLogContent">
                    <!-- Action messages will be populated here by JavaScript -->
                </div>
            </div>
            <!-- END OF STRUCTURE -->
            <!-- UNIFIED Respawn Queue Display -->
            <div id="reinforcementsContainer" class="respawn-queue-container" style="display: none;">
                <h4 class="respawn-queue-header">Reinforcements</h4>
                <div id="reinforcementsList" class="respawn-queue-list"></div>
            </div>
        </div>

        <canvas id="gameCanvas"></canvas>

        <div id="rightPanel" class="ui-panel">
            <h2 id="turnDisplay">Player 1's Turn</h2>
            <div id="actionsPanel" class="actions-panel" style="display: none;">
                <h3>Actions</h3>
                <button id="fortifyUnfortifyButton" class="action-button">Fortify</button>
                <button id="buildBridgeButton" class="action-button">Build Bridge</button>
                <button id="attackButton" class="action-button">Attack</button>
            </div>
            <div class="buttons-container">
                <button id="endTurnButton">End Turn</button>
            </div>
        </div>
    </div>

<div id="generateMapButtonContainer" style="display: flex; justify-content: center; gap: 15px; width: 100%; margin-top: 20px; margin-bottom: 20px;">
    <!-- SAVE GAME BUTTON -->
    <button id="saveGameButton" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;">
            <path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path>
            <polyline points="17 21 17 13 7 13 7 21"></polyline>
            <polyline points="7 3 7 8 15 8"></polyline>
        </svg>
        Save Game
    </button>

    <!-- NEW MAP BUTTON -->
    <button id="newMapButton" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;">
            <polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon>
            <line x1="8" y1="2" x2="8" y2="18"></line>
            <line x1="16" y1="6" x2="16" y2="22"></line>
        </svg>
        New Map
    </button>

    <!-- LOAD GAME BUTTON -->
    <button id="loadGameButton" class="action-button">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="width: 20px; height: 20px; stroke: white;">
            <path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path>
        </svg>
        Load Game
    </button>
</div>

<div id="gameWrapper"> 
    <div id="gameLayoutContainer">
        <!-- ... (left panel, canvas, right panel) ... -->
    </div>
    <div id="generateMapButtonContainer">
        <!-- ... (save, new map, load buttons) ... -->
    </div>
</div>

    <button id="tutorialButton" title="Game Tutorial">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
            <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/>
        </svg>
    </button>

    <button id="downloadButton" title="Download Game">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
            <polyline points="7 10 12 15 17 10"></polyline>
            <line x1="12" y1="15" x2="12" y2="3"></line>
        </svg>
    </button>

    <div id="messageBox" class="message-box" style="display: none;">Project Hexblade Loaded. Player 1's Turn.</div>
    <div id="victoryMessage" class="victory-message" style="display: none;"></div>

    <div id="customConfirmModal" class="modal-overlay" style="display: none;"> <!-- Will be controlled by JS -->
        <div class="modal-content">
            <p id="customConfirmMessage">Are you sure you want to generate a new map? This will reset the current game.</p>
            <div class="modal-buttons">
                <button id="customConfirmOkButton" class="modal-button-ok">Confirm</button>
                <button id="customConfirmCancelButton" class="modal-button-cancel">Cancel</button>
            </div>
        </div>
    </div>

<div id="loadGameModal" class="modal-overlay" style="display: none;">
    <div class="modal-content">
        <h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">Load Game</h3>
        <div id="loadOptionsContainer" style="display: flex; flex-direction: row; justify-content: center; gap: 20px;">
            <button id="loadFromAutosaveButton" class="action-button">Load Autosave</button>
            <button id="loadFromFileButton" class="action-button">Load Save File</button>
        </div>
    </div>
</div>

<!-- Hidden file input for loading game saves -->
<input type="file" id="fileLoaderInput" style="display: none;" accept=".fhsave, .json">

<!-- NEW MAP MODAL -->
<div id="newMapModal" class="modal-overlay" style="display: none;">
<div class="modal-content">
<button id="newMapModalCloseButton" class="tutorial-modal-close-button" title="Close">×</button>
<h3 style="font-family: 'Geostar', cursive; font-size: 1.8em; color: #FFC020; margin-bottom: 25px;">New Map</h3>
<div id="newMapOptionsContainer">
<button id="selectMapButton" class="action-button" disabled>Select Map (Coming Soon)</button>
<button id="generateMapFromModalButton" class="action-button">Generate Map</button>
<button id="customMapButton" class="action-button" disabled>Custom Map (Coming Soon)</button>
</div>
</div>
</div>

    <div id="tutorialModalOverlay" style="display: none;"> <!-- Will be controlled by JS -->
        <div id="tutorialModalContent">
            <button id="tutorialCloseButton" class="tutorial-modal-close-button" title="Close Tutorial">×</button>
            <h2>FortHex: Complete Tutorial</h2>
            <p>Welcome to FortHex! This is a turn-based strategy game of wits, warfare, and area control. This guide will teach you everything you need to know to claim victory.</p>

            <div class="tutorial-section">
                <div class="tutorial-section-header">1. How to Play: The Basics <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                    <ul>
                        <li><strong>Selecting &amp; Deselecting:</strong> Click on one of your units to select it. Its stats and available actions will appear in the UI panels. To deselect, click the unit again or any empty space.</li>
                        <li><strong>Movement:</strong> With a unit selected, valid destinations will be highlighted in green. You can either <strong>drag-and-drop</strong> your unit to a highlighted road, or simply <strong>click</strong> on it.</li>
                        <li><strong>Actions:</strong> With a unit selected, click an action button in the right panel (e.g., "Attack," "Fortify"). The game will highlight valid targets. Click a target to confirm. To cancel, click the action button again.</li>
                        <li><strong>Ending Your Turn:</strong> When you have finished all your moves, click the "End Turn" button to pass control to your opponent.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">2. The Objective: How to Win <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                    <p>There are two paths to victory:</p>
                    <ul>
                        <li><strong>Annihilation:</strong> Eliminate all of your opponent's units.</li>
                        <li><strong>Capture the Flag (CTF):</strong> Move one of your units to the enemy's starting base to capture their flag. Successfully bring that unit back to your own starting base to win the game instantly.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">3. The Battlefield: Tiles &amp; Roads <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                    <p>The map is made of hexagonal tiles and the roads connecting them. Your units are positioned on roads.</p>
                    <p><strong>Tiles:</strong> Each tile type affects gameplay.</p>
                    <ul>
                        <li><strong>Plains:</strong> Standard, open ground.</li>
                        <li><strong>Forest:</strong> Provides cover, but slows movement. Blocks Line of Sight.</li>
                        <li><strong>Mountain:</strong> Difficult to cross and blocks Line of Sight.</li>
                        <li><strong>Water:</strong> Impassable.</li>
                    </ul>
                    <p><strong>Roads:</strong> The paths your units travel on. Up to two friendly units can share a road.</p>
                    <ul>
                        <li>Movement costs vary by the terrain on either side of a road (e.g., a road next to a Forest is slower to cross).</li>
                        <li>Moving onto a road next to an enemy-controlled fort costs an extra Movement Point (MP).</li>
                    </ul>
                </div>
            </div>
            
            <div class="tutorial-section">
                <div class="tutorial-section-header">4. Core Mechanic: Fortification <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                    <p>Fortifying is a key strategic action. A unit on a road can move into the center of an adjacent tile to fortify it.</p>
                    <ul>
                        <li><strong>Fortifiable Tiles:</strong> You can only fortify <strong>Plains</strong> and <strong>Forest</strong> tiles.</li>
                        <li><strong>Benefits of Fortification:</strong>
                            <ul>
                                <li><strong>Defense:</strong> Reduces incoming damage. A fortified Pikeman is especially tough.</li>
                                <li><strong>Zone of Control (ZoC):</strong> Automatically damages adjacent enemies, creating a dangerous area for your opponent.</li>
                                <li><strong>Healing &amp; Supply:</strong> A fortified unit can heal 1 HP at the start of your turn. Healing can even grant a temporary 1 HP "shield" above its maximum health.</li>
                            </ul>
                        </li>
                        <li><strong>Unfortify:</strong> A fortified unit can perform an action to move back onto an adjacent road, removing the fortification.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">5. Your Army: The Units <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                    <p>You control four distinct unit types, each with a unique role.</p>
                     <ul>
                        <li><strong>Melee (Symbol: Sword):</strong> A versatile front-line fighter.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 12 | Move: 4 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> The only unit that can build Bridges over Water roads.</li>
                                <li><strong>Weak against:</strong> Horseman | <strong>Strong against:</strong> Archer</li>
                            </ul>
                        </li>
                        <li style="margin-top:10px;"><strong>Archer (Symbol: Arrow):</strong> A ranged unit that attacks from a distance. Must have Line of Sight to its target.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 10 | Move: 3 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> Gains +1 Attack when attacking from a fortified position.</li>
                                <li><strong>Weak against:</strong> Melee | <strong>Strong against:</strong> Pikeman</li>
                            </ul>
                        </li>
                        <li style="margin-top:10px;"><strong>Pikeman (Symbol: Pike):</strong> A defensive powerhouse and anti-cavalry specialist.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 13 | Move: 3 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> Gets a superior defensive bonus when fortified. Its attack can pierce some of an enemy's fortification defense.</li>
                                <li><strong>Weak against:</strong> Archer | <strong>Strong against:</strong> Horseman</li>
                            </ul>
                        </li>
                        <li style="margin-top:10px;"><strong>Horseman (Symbol: Horse Head):</strong> A fast, mobile flanker designed for hit-and-run tactics.
                            <p style="margin-left: 15px; margin-bottom: 5px;">HP: 11 | Move: 5 | Attack: 3</p>
                            <ul>
                                <li><strong>Special:</strong> Can use its remaining Movement Points *after* attacking. Cannot fortify.</li>
                                <li><strong>Weak against:</strong> Pikeman | <strong>Strong against:</strong> Melee</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">6. Advanced Combat: Synergies &amp; Counters <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                     <p>Unit interactions are the key to victory.</p>
                    <ul>
                        <li><strong>Advantage/Disadvantage:</strong> Units get an attack bonus against types they are "strong" against, and a penalty against those they are "weak" against.</li>
                        <li><strong>Spear Wall:</strong> An enemy Horseman attacking a unit next to your fortified Pikeman is stopped in its tracks and cannot move away after the attack.</li>
                        <li><strong>Combined Arms:</strong> An attack from a road with both a friendly Melee and Archer on it will ignore the target's fortification bonus.</li>
                        <li><strong>Cavalry Screen:</strong> If an enemy Melee unit attacks your Horseman, a friendly Archer on the same road will automatically retaliate with a half-damage shot.</li>
                        <li><strong>Split Damage:</strong> If an Archer attacks a road where two enemies are present, its damage is split between them.</li>
                    </ul>
                </div>
            </div>

            <div class="tutorial-section">
                <div class="tutorial-section-header">7. Strategic Systems: The Long Game <span class="tutorial-arrow">►</span></div>
                <div class="tutorial-section-content">
                    <p>Mastering these systems will set you apart from your opponent.</p>
                    <ul>
                        <li><strong>Supply Points:</strong> Each player starts with <strong>10 Supply Points</strong>, a global resource used to maintain supply lines. The cost of a supply line is based on the length and terrain of the path back to your base. If you cannot afford the cost, your unit will fortify but will be "unsupplied" and cannot heal. When a supplied unit is destroyed or unfortifies, its supply cost is refunded.</li>
                        <li><strong>Supply Lines &amp; Healing:</strong> For a fortified unit to heal, it must be "in supply." This requires both a valid supply line path AND enough Supply Points to maintain it. An enemy unit standing on any road in that chain will also break the supply line and prevent healing.</li>
                        <li><strong>Capture the Flag &amp; Supply Raids:</strong> Stealing the enemy flag is a devastating move. When you are carrying their flag, <strong>all of their units, no matter where they are, lose their supply lines and cannot heal.</strong> They must destroy your flag carrier to restore their healing capabilities.</li>
                        <li><strong>Reinforcements (Respawn System):</strong> Destroyed units aren't gone forever. They enter a respawn queue. After 10 turns, you can deploy a new unit at your base. This is limited by a maximum army size (4 units) and a cap on each unit type (2 of each).</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- NEW RESPAWN CHOICE MODAL -->
    <div id="respawnModalOverlay" class="modal-overlay">
        <div id="respawnModalContent" class="modal-content">
            <h3>A Unit Has Fallen!</h3>
            <p>Choose a reinforcement to deploy at your base.</p>
            <div id="respawnChoices">
                <button id="respawnMelee" class="respawn-button" data-unit-type="MELEE" title="Melee"></button>
                <button id="respawnArcher" class="respawn-button" data-unit-type="ARCHER" title="Archer"></button>
                <button id="respawnPikeman" class="respawn-button" data-unit-type="PIKEMAN" title="Pikeman"></button>
                <button id="respawnHorseman" class="respawn-button" data-unit-type="HORSEMAN" title="Horseman"></button>
            </div>
        </div>
    </div>


    <script>
        // --- Game Configuration & Constants ---
        const BUILD_VERSION = "B27//3";
        const HEX_SIZE = 70; 
        const GRID_RADIUS = 3; 

        // Gameplay Constants
        const RESPAWN_TURN_TIMER = 10;
        const MAX_BASE_CAMP_TURNS = 7;
        const MAX_UNITS_PER_PLAYER = 4;
        const UNIT_CAPS = {
            Melee: 2,
            Archer: 2,
            Pikeman: 2,
            Horseman: 2,
        };
        const FORTIFICATION_DAMAGE = 1; 
        const BRIDGE_MAX_HP = 5;        
        const PROJECTILE_SPEED_PIXELS_PER_MS = 0.8;
        const UNIT_ON_EDGE_OFFSET = HEX_SIZE * 0.2; 
        const ATTACK_COST = 1;          
        const FORTIFY_UNFORTIFY_COST = 1; 
        const BUILD_BRIDGE_COST = 1;    
        const MAX_MOVEMENT_COST = 3;    
        const SHIELD_COLOR = '#30C4C4'; 

        // Visual/Interaction Constants
        const UNIT_DRAW_SIZE_ON_EDGE = HEX_SIZE * 0.25; 
        const FORTIFIED_UNIT_DRAW_SIZE = UNIT_DRAW_SIZE_ON_EDGE * 1.2; 
        const HIGHLIGHT_CLICK_RADIUS = HEX_SIZE * 0.35; 
        const UNIT_CLICK_RADIUS = HEX_SIZE * 0.3;       
        const BRIDGE_CLICK_TOLERANCE = HEX_SIZE * 0.15; 
        const DRAG_SCALE_FACTOR = 1.2;  
        const DRAGGED_DISTANCE_THRESHOLD = 5; 
        const PULSE_DURATION_MS = 2000; 
        const COLOR_TRANSITION_DURATION_MS = 400;
        const PATH_DRAW_ANIMATION_DURATION_MS = 750; 
        const PATH_DRAW_PAUSE_DURATION_MS = 500; 
        const PATH_DRAW_HOVER_DELAY_MS = 1000; 

        // Map Generation Constants (Updated for Radius 3)
        const MAX_MOUNTAIN_TILES_TOTAL = 8;
        const MAX_WATER_TILES_TOTAL = 12;
        const MAX_FOREST_TILES_TOTAL = 12;
        const MAX_PLAINS_TILES_TOTAL = 18;

        const MAX_MOUNTAIN_TILES_PER_CLUSTER = 3; // Kept the same for cluster density

        const MOUNTAIN_SPAWN_CHANCE = 0.35;
        const WATER_SPAWN_CHANCE = 0.25;
        const FOREST_SPAWN_CHANCE = 0.5;

        const MIN_WATER_TILES_SOFT = 4;
        const MIN_FOREST_TILES_SOFT = 6;
        const MIN_PLAINS_TILES_SOFT = 12;
        const MIN_CENTRAL_PLAINS_SOFT = 3;

        // Action State Constants
        const ACTION_STATES = {
            IDLE: 'idle',
            UNIT_SELECTED: 'unit_selected',
            SELECTING_FORTIFY_TILE: 'selecting_fortify_tile',
            SELECTING_UNFORTIFY_EDGE: 'selecting_unfortify_edge',
            SELECTING_BRIDGE_EDGE: 'selecting_bridge_edge',
            SELECTING_ATTACK_TARGET: 'selecting_attack_target',
        };

        // All available color themes
        const COLOR_THEMES = [
            { // Theme 1
                player1: { primary: '#4060E0', secondary: '#60D0F0', accent: '#40B0FF' },
                player2: { primary: '#E06040', secondary: '#FF7040', accent: '#FF8060' }
            },
            { // Theme 2
                player1: { primary: '#4050D0', secondary: '#60C0E8', accent: '#50A0FF' },
                player2: { primary: '#D05040', secondary: '#F86040', accent: '#FF7070' }
            },
            { // Theme 3 (Default)
                player1: { primary: '#4040C0', secondary: '#60B0E0', accent: '#6090FF' },
                player2: { primary: '#C04040', secondary: '#F05040', accent: '#FF6080' }
            },
            { // Theme 4
                player1: { primary: '#4030B0', secondary: '#60A0D8', accent: '#7080FF' },
                player2: { primary: '#B03040', secondary: '#E84040', accent: '#FF5090' }
            },
            { // Theme 5
                player1: { primary: '#4020A0', secondary: '#6090D0', accent: '#8070FF' },
                player2: { primary: '#A02040', secondary: '#E03040', accent: '#E03040' }
            }
        ];

        //Team Color Definitions
        const TEAM_COLORS = {
            player1: { ...COLOR_THEMES[2].player1 },
            player2: { ...COLOR_THEMES[2].player2 }
        };

        // Tile Definitions
        const TILE_TYPES = {
            PLAINS:   { name: 'Plains',   color: '#90EE90', baseMoveCost: 1, canFortify: true },
            FOREST:   { name: 'Forest',   color: '#228B22', baseMoveCost: 2, canFortify: true },
            WATER:    { name: 'Water',    color: '#87CEEB', baseMoveCost: Infinity, crossable: false, canFortify: false },
            MOUNTAIN: { name: 'Mountain', color: '#808080', baseMoveCost: 3, canFortify: false, blocksLOS: true } 
        };

        // Unit Definitions
        const UNIT_TYPES = {
            MELEE:    { name: 'Melee',    hp: 12, baseMove: 4, attack: 3, symbol: 'M', canBuildBridge: true,  canFortify: true,  fortificationBonus: 1, attackType: 'melee', defenseNegation: 0, canMoveAfterAttack: false, strengths: ['Archer'],   weaknesses: ['Horseman'] },
            ARCHER:   { name: 'Archer',   hp: 10, baseMove: 3, attack: 3, symbol: 'A', canBuildBridge: false, canFortify: true,  fortificationBonus: 1, attackType: 'ranged', defenseNegation: 0, canMoveAfterAttack: false, strengths: ['Pikeman'],  weaknesses: ['Melee'] },
            PIKEMAN:  { name: 'Pikeman',  hp: 13, baseMove: 3, attack: 3, symbol: 'P', canBuildBridge: false, canFortify: true,  fortificationBonus: 2, attackType: 'melee', defenseNegation: 1, canMoveAfterAttack: false, strengths: ['Horseman'], weaknesses: ['Archer'] },
            HORSEMAN: { name: 'Horseman', hp: 11, baseMove: 5, attack: 3, symbol: 'H', canBuildBridge: false, canFortify: false, fortificationBonus: 0, attackType: 'melee', defenseNegation: 0, canMoveAfterAttack: true,  strengths: ['Melee'],    weaknesses: ['Pikeman'] }
        };

        const UNIT_SVGS = {
            MELEE: `<svg viewBox="170 60 110 280" fill="white">
                        <path d="M 224.613 61.934 L 243.516 108 L 208.709 108.172 L 224.613 61.934 Z"></path>
                        <rect x="210.709" y="108.172" width="31.807" height="192.313"></rect>
                        <rect x="172.161" y="233.27" width="103.853" height="22.254"></rect>
                        <ellipse cx="224.526" cy="312.975" rx="20.582" ry="20.615"></ellipse>
                    </svg>`,
            ARCHER: `<svg viewBox="-10 -18 20 36" fill="white">
                        <path d="M 0 -17.5 L -5 -10 L -1.875 -8.75 L -1.875 5 L -6.25 17.5 L 0 13.75 L 6.25 17.5 L 1.875 5 L 1.875 -8.75 L 5 -10 Z" />
                    </svg>`,
            PIKEMAN: `<svg viewBox="-14 -20 28 40" fill="white">
                        <path d="M -1.35 16.875 L -1.35 1.125 Q -13.5 -3.375 -1.35 -11.25 L 0 -18 L 1.35 -11.25 L 1.35 -7.5 L 8.75 -4.5 L 1.35 -2.25 L 1.35 16.875 Z" />
                    </svg>`,
            HORSEMAN: `<svg viewBox="-12 -16 24 32" fill="white">
                        <path d="M-6 10 L 6 10 L 6 3 L 3 -1 L 9 -3 L 9 -7 L 2 -7 L -2 -12 L -4 -8 L -6 2 Z" />
                    </svg>`
        };

        // Hex Grid Directions (Axial Coordinates)
        const AXIAL_DIRECTIONS = [ { q: 1, r: 0 }, { q: 1, r: -1 }, { q: 0, r: -1 }, { q: -1, r: 0 }, { q: -1, r: 1 }, { q: 0, r: 1 } ];
        const MAP_DIRECTION_TO_EDGE_INDEX = [0, 5, 4, 3, 2, 1];


        const DEFAULT_MAP_LAYOUT_RADIUS_3 = new Map([
            // q=-3
            ['-3,0', TILE_TYPES.WATER], ['-3,1', TILE_TYPES.WATER], ['-3,2', TILE_TYPES.MOUNTAIN], ['-3,3', TILE_TYPES.MOUNTAIN],
            // q=-2
            ['-2,-1', TILE_TYPES.PLAINS], ['-2,0', TILE_TYPES.PLAINS], ['-2,1', TILE_TYPES.FOREST], ['-2,2', TILE_TYPES.FOREST], ['-2,3', TILE_TYPES.MOUNTAIN],
            // q=-1
            ['-1,-2', TILE_TYPES.PLAINS], ['-1,-1', TILE_TYPES.PLAINS], ['-1,0', TILE_TYPES.PLAINS], ['-1,1', TILE_TYPES.PLAINS], ['-1,2', TILE_TYPES.FOREST], ['-1,3', TILE_TYPES.WATER],
            // q=0
            ['0,-3', TILE_TYPES.WATER], ['0,-2', TILE_TYPES.PLAINS], ['0,-1', TILE_TYPES.PLAINS], ['0,0', TILE_TYPES.FOREST], ['0,1', TILE_TYPES.PLAINS], ['0,2', TILE_TYPES.PLAINS], ['0,3', TILE_TYPES.WATER],
            // q=1
            ['1,-3', TILE_TYPES.WATER], ['1,-2', TILE_TYPES.FOREST], ['1,-1', TILE_TYPES.PLAINS], ['1,0', TILE_TYPES.PLAINS], ['1,1', TILE_TYPES.PLAINS], ['1,2', TILE_TYPES.PLAINS],
            // q=2
            ['2,-3', TILE_TYPES.MOUNTAIN], ['2,-2', TILE_TYPES.FOREST], ['2,-1', TILE_TYPES.FOREST], ['2,0', TILE_TYPES.PLAINS], ['2,1', TILE_TYPES.PLAINS],
            // q=3
            ['3,-3', TILE_TYPES.MOUNTAIN], ['3,-2', TILE_TYPES.MOUNTAIN], ['3,-1', TILE_TYPES.WATER], ['3,0', TILE_TYPES.WATER]
        ]);
        
        const FLAG_HOME_POSITIONS = {
            player1: getEdgeKey(-2, -1, -1, -2), // Edge between P1's base tiles
            player2: getEdgeKey(1, 2, 2, 1)      // Edge between P2's base tiles
        };

        // --- Canvas & UI Elements ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        const ui = {
            turnDisplay: document.getElementById('turnDisplay'),
            globalTurnCounterDisplay: document.getElementById('globalTurnCounterDisplay'),
            selectedUnitInfoContainer: document.getElementById('selectedUnitInfoContainer'),
            unitName: document.getElementById('unitName'),
            unitHP: document.getElementById('unitHP'),
            unitMaxHP: document.getElementById('unitMaxHP'),
            unitMovement: document.getElementById('unitMovement'),
            unitPosition: document.getElementById('unitPosition'),
            unitStatus: document.getElementById('unitStatus'),
            actionsPanel: document.getElementById('actionsPanel'),
            fortifyUnfortifyButton: document.getElementById('fortifyUnfortifyButton'),
            buildBridgeButton: document.getElementById('buildBridgeButton'),
            attackButton: document.getElementById('attackButton'),
            endTurnButton: document.getElementById('endTurnButton'),
            downloadButton: document.getElementById('downloadButton'),
            tutorialButton: document.getElementById('tutorialButton'), 
            messageBox: document.getElementById('messageBox'),
            victoryMessage: document.getElementById('victoryMessage'),
            customConfirmModal: document.getElementById('customConfirmModal'),
            customConfirmOkButton: document.getElementById('customConfirmOkButton'),
            customConfirmCancelButton: document.getElementById('customConfirmCancelButton'),
            tutorialModalOverlay: document.getElementById('tutorialModalOverlay'), 
            tutorialCloseButton: document.getElementById('tutorialCloseButton'), 
            tutorialSectionHeaders: document.querySelectorAll('.tutorial-section-header'), 
            actionInfoContainer: document.getElementById('actionInfoContainer'),
            actionLogContent: document.getElementById('actionLogContent'),
        };

        let dragOperationJustConcluded = false;

        // --- Game State ---
    let gameState = {
    gameMode: 'local', // 'local' or 'singleplayer'
    playerSide: null, // 1 or 2, for singleplayer mode
    playerColorSelections: { player1: 2, player2: 2 },
    colorTransition: { active: false, startTime: 0, from: {}, to: {} },
    tiles: new Map(),
    edges: new Map(),
    units: [],
    currentPlayer: 1,
            globalTurnNumber: 1,
            selectedUnit: null,
            hoveredUnitId: null,
            currentReachableMoves: new Map(),
            gameOver: false,
            gridRadius: GRID_RADIUS,
            actionLog: [], 
            flags: null,
            respawnQueue: { player1: [], player2: [] },
            unitCounts: null,
            supplyPoints: { player1: 10, player2: 10 },
            activeAnimations: [],

            // Physical UI states
            isDragging: false,
            draggingUnit: null,
            dragStartX: 0, dragStartY: 0,
            dragUnitRenderX: 0, dragUnitRenderY: 0,
            dragUnitOriginalPosition: null, dragUnitOriginalType: null,
            draggedDistance: 0,
            dragStartTime: null,
            
            // Logical Game State
            currentActionState: ACTION_STATES.IDLE,

            // Data for actions
            validFortifyTargetTileKeys: [],
            validUnfortifyTargetEdgeKeys: [],
            validBridgeTargetEdgeKeys: [],
            validMeleeAttackTargets: [],
            validArcherAttackTargets: [],
            
            // Debug / Animation data
            potentialDebugPathToDraw: null, 
            debugPathHoverStartTime: null,  
            debugPathToDraw: null,          
            debugPathAnimationStartTime: null,
            debugPathPauseStartTime: null, 
    lastDebugPathKey: null, 
    debugAttackRangeHighlights: [],
    visualEffects: [],
    playerActionTaken: { player1: false, player2: false },
};

let currentDrawingColors = JSON.parse(JSON.stringify(TEAM_COLORS));

let gameSettings = {
    animationsEnabled: true, //Enable/Disable All Animations
    fancyVisualsEnabled: true, //Enable/Disable New Tile Textures
    passTurnConfirmationEnabled: true, //Enable/Disable the Skip Turn Confirmation Modal
    tooltipsEnabled: true, //Enable/Disable Tooltips
    //uiScale: 1.0
};

const SETTINGS_STORAGE_KEY = 'forthex_user_settings';
const COLOR_PREF_STORAGE_KEY = 'forthex_color_preferences';

function saveSettings() {
    try {
        const settingsString = JSON.stringify(gameSettings);
        localStorage.setItem(SETTINGS_STORAGE_KEY, settingsString);
    } catch (error) {
        console.error("Could not save settings:", error);
    }
}

function loadSettings() {
    try {
        const savedSettingsString = localStorage.getItem(SETTINGS_STORAGE_KEY);
        if (savedSettingsString) {
            const loadedSettings = JSON.parse(savedSettingsString);
            // Merge loaded settings with defaults to handle new settings in future updates
            gameSettings = Object.assign({}, gameSettings, loadedSettings);
        }
        // If no saved settings, the default gameSettings object is used.
    } catch (error) {
        console.error("Could not load settings:", error);
    }
}

function saveColorPreferences() {
    try {
        const prefsString = JSON.stringify(gameState.playerColorSelections);
        localStorage.setItem(COLOR_PREF_STORAGE_KEY, prefsString);
    } catch (error) {
        console.error("Could not save color preferences:", error);
    }
}

function loadColorPreferences() {
    try {
        const savedPrefsString = localStorage.getItem(COLOR_PREF_STORAGE_KEY);
        if (savedPrefsString) {
            const loadedPrefs = JSON.parse(savedPrefsString);
            // Update the game state with the loaded selections
            gameState.playerColorSelections = Object.assign({}, gameState.playerColorSelections, loadedPrefs);

            // CRITICAL: Update the main TEAM_COLORS object to reflect the loaded preferences
            // This ensures the game starts with the correct colors.
            TEAM_COLORS.player1 = { ...COLOR_THEMES[gameState.playerColorSelections.player1].player1 };
            TEAM_COLORS.player2 = { ...COLOR_THEMES[gameState.playerColorSelections.player2].player2 };
        }
    } catch (error) {
        console.error("Could not load color preferences:", error);
    }
}

        let currentConfirmAction = null;

        // --- Utility Functions ---

        // Hex Color to RGBA
        function hexToRgba(hex, alpha = 1) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }

        // Linearly interpolates between two hex colors
        function lerpColor(colorA, colorB, amount) {
            const ah = parseInt(colorA.replace(/#/g, ''), 16);
            const ar = ah >> 16, ag = (ah >> 8) & 0xff, ab = ah & 0xff;
            const bh = parseInt(colorB.replace(/#/g, ''), 16);
            const br = bh >> 16, bg = (bh >> 8) & 0xff, bb = bh & 0xff;
            const rr = ar + amount * (br - ar);
            const rg = ag + amount * (bg - ag);
            const rb = ab + amount * (bb - ab);
            const newHex = ((1 << 24) + (Math.round(rr) << 16) + (Math.round(rg) << 8) + Math.round(rb)).toString(16).slice(1);
            return `#${newHex}`;
        }

        function axialToPixel(q, r) {
            const x = HEX_SIZE * (Math.sqrt(3) * q + Math.sqrt(3) / 2 * r) + canvas.width / 2;
            const y = HEX_SIZE * (3 / 2 * r) + canvas.height / 2;
            return { x, y };
        }

        function pixelToAxial(x, y) {
            const adjX = x - canvas.width / 2; const adjY = y - canvas.height / 2;
            const q_calc = (Math.sqrt(3) / 3 * adjX - 1 / 3 * adjY) / HEX_SIZE;
            const r_calc = (2 / 3 * adjY) / HEX_SIZE;
            return roundAxial({ q: q_calc, r: r_calc });
        }

        function roundAxial({ q, r }) {
            const s = -q - r;
            let rq = Math.round(q); let rr = Math.round(r); let rs = Math.round(s);
            const q_diff = Math.abs(rq - q); const r_diff = Math.abs(rr - r); const s_diff = Math.abs(rs - s);
            if (q_diff > r_diff && q_diff > s_diff) rq = -rr - rs;
            else if (r_diff > s_diff) rr = -rq - rs;
            return { q: rq, r: rr };
        }

        function getTileKey(q, r) { return `${q},${r}`; }

        function getEdgeKey(q1, r1, q2, r2) {
            if (q1 > q2 || (q1 === q2 && r1 > r2)) {
                [q1, q2] = [q2, q1]; [r1, r2] = [r2, r1];
            }
            return `${q1},${r1}_${q2},${r2}`;
        }

        function getEdgeMidpoint(q1, r1, q2, r2) {
            const p1 = axialToPixel(q1, r1); const p2 = axialToPixel(q2, r2);
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function getNeighbors(q, r) { return AXIAL_DIRECTIONS.map(dir => ({ q: q + dir.q, r: r + dir.r })); }

        function axialDistance(q1, r1, q2, r2) {
            const dq = q1 - q2; const dr = r1 - r2; const ds = (-q1 - r1) - (-q2 - r2);
            return (Math.abs(dq) + Math.abs(dr) + Math.abs(ds)) / 2;
        }

        function findDirectionIndex(dir) {
            for (let i = 0; i < AXIAL_DIRECTIONS.length; i++) {
                if (AXIAL_DIRECTIONS[i].q === dir.q && AXIAL_DIRECTIONS[i].r === dir.r) return i;
            }
            return -1;
        }

        function parseEdgeKey(edgeKey) {
            if (!edgeKey || typeof edgeKey !== 'string' || !edgeKey.includes('_')) {
                return [{q:NaN, r:NaN}, {q:NaN, r:NaN}];
            }
            const parts = edgeKey.split('_');
            const [q1, r1] = parts[0].split(',').map(Number);
            const [q2, r2] = parts[1].split(',').map(Number);
            return [{q: q1, r: r1}, {q: q2, r: r2}];
        }

        function clearDebugPath() { 
            gameState.potentialDebugPathToDraw = null;
            gameState.debugPathHoverStartTime = null;
            gameState.debugPathToDraw = null; 
            gameState.debugPathAnimationStartTime = null;
            gameState.debugPathPauseStartTime = null; 
            gameState.lastDebugPathKey = null;
        }

        function resetActionSelectionStates() {
            gameState.currentActionState = gameState.selectedUnit ? ACTION_STATES.UNIT_SELECTED : ACTION_STATES.IDLE;
            
            gameState.validFortifyTargetTileKeys = [];
            gameState.validUnfortifyTargetEdgeKeys = [];
            gameState.validBridgeTargetEdgeKeys = [];
            gameState.validMeleeAttackTargets = [];
            gameState.validArcherAttackTargets = [];
            gameState.debugAttackRangeHighlights = [];
            
            clearDebugPath();
        }

        function distSq(p1, p2) { return (p1.x - p2.x)**2 + (p1.y - p2.y)**2; }
        
        function pointDistance(p1, p2) { return Math.sqrt(distSq(p1,p2)); }


        function distToSegmentSquared(p, v, w) {
            const l2 = distSq(v, w); if (l2 === 0) return distSq(p, v);
            let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
            t = Math.max(0, Math.min(1, t));
            const projection = { x: v.x + t * (w.x - v.x), y: v.y + t * (w.y - v.y) };
            return distSq(p, projection);
        }

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function lerp(start, end, amount) {
    return start + (end - start) * amount;
}

function getUnitScreenPosition(unit) {
    if (!unit) return null;
    let unitX, unitY;

    if (unit.isFortified) {
        const tile = gameState.tiles.get(unit.position);
        if (tile) {
            const center = axialToPixel(tile.q, tile.r);
            unitX = center.x;
            unitY = center.y;
        }
    } else {
        const edge = gameState.edges.get(unit.position);
        if (edge) {
            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            unitX = mid.x;
            unitY = mid.y;
            const unitsOnEdge = edge.units.filter(u => u.positionType === 'edge');
            const unitIndex = unitsOnEdge.findIndex(u => u.id === unit.id);
            if (unitsOnEdge.length > 1 && unitIndex !== -1) {
                const offsetSign = (unitIndex % 2 === 0) ? -1 : 1;
                const p1 = axialToPixel(edge.q1, edge.r1);
                const p2 = axialToPixel(edge.q2, edge.r2);
                let dx = p2.x - p1.x, dy = p2.y - p1.y;
                const len = Math.sqrt(dx * dx + dy * dy) || 1;
                let perpX = -dy / len, perpY = dx / len;
                unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
                unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
            }
        }
    }
    if (unitX !== undefined) {
        return { x: unitX, y: unitY };
    }
    return null;
}

        function padZero(num) {
            return String(num).padStart(2, '0');
        }

        function isLand(tileType) {
            return tileType === TILE_TYPES.PLAINS || tileType === TILE_TYPES.FOREST || tileType === TILE_TYPES.MOUNTAIN;
        }

function isEdgeAdjacentToSpearWall(unit, edgeKey) {
    if (!unit || !edgeKey) return false;

    const enemyPlayer = unit.player === 1 ? 2 : 1;
    const [h1, h2] = parseEdgeKey(edgeKey);
    if (isNaN(h1.q) || isNaN(h2.q)) return false;

    // This set now ONLY contains the two tiles that form the edge.
    const tilesThatFormTheEdge = new Set();
    tilesThatFormTheEdge.add(getTileKey(h1.q, h1.r));
    tilesThatFormTheEdge.add(getTileKey(h2.q, h2.r));

    for (const tileKey of tilesThatFormTheEdge) {
        const tile = gameState.tiles.get(tileKey);
        if (tile && tile.fortifiedByPlayer === enemyPlayer) {
            const fortifiedUnit = gameState.units.find(u => u.position === tileKey && u.isFortified);
            if (fortifiedUnit && fortifiedUnit.type.name === 'Pikeman') {
                return true; 
            }
        }
    }
    return false;
}

        function isRoad(edgeKey) {
            const edge = gameState.edges.get(edgeKey);
            if (!edge) return false;

            const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
            const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));

            if (!tile1 || !tile2) return false;

            // A road cannot be on an edge connected to a water tile.
            return tile1.type !== TILE_TYPES.WATER && tile2.type !== TILE_TYPES.WATER;
        }

        // --- LOS Helper Functions ---
        function getEdgesOfTile(q, r) {
            const edges = new Set(); 
            getNeighbors(q, r).forEach(neighborCoords => {
                if (gameState.tiles.has(getTileKey(neighborCoords.q, neighborCoords.r))) {
                    edges.add(getEdgeKey(q, r, neighborCoords.q, neighborCoords.r));
                }
            });
            return Array.from(edges);
        }

        function isEdgePartOfTile(tileQ, tileR, edgeKey) {
            if (!edgeKey) return false;
            const [h1, h2] = parseEdgeKey(edgeKey);
            return (h1.q === tileQ && h1.r === tileR) || (h2.q === tileQ && h2.r === tileR);
        }

        function isEdgeRotationallyAdjacentToEdgeOnTile(centerTileQ, centerTileR, referenceEdgeKey, targetEdgeKey) {
            if (!isEdgePartOfTile(centerTileQ, centerTileR, referenceEdgeKey) || 
                !isEdgePartOfTile(centerTileQ, centerTileR, targetEdgeKey) ||
                referenceEdgeKey === targetEdgeKey) {
                return false;
            }

            const [ref_h1, ref_h2] = parseEdgeKey(referenceEdgeKey);
            const [tar_h1, tar_h2] = parseEdgeKey(targetEdgeKey);

            let pivotHex, otherHexFromRefEdge, otherHexFromTargetEdge;

            if (ref_h1.q === centerTileQ && ref_h1.r === centerTileR) { pivotHex = ref_h1; otherHexFromRefEdge = ref_h2; }
            else if (ref_h2.q === centerTileQ && ref_h2.r === centerTileR) { pivotHex = ref_h2; otherHexFromRefEdge = ref_h1; }
            else { return false; }
            
            if (tar_h1.q === centerTileQ && tar_h1.r === centerTileR) { otherHexFromTargetEdge = tar_h2; }
            else if (tar_h2.q === centerTileQ && tar_h2.r === centerTileR) { otherHexFromTargetEdge = tar_h1; }
            else { return false; }

            const dirToRefOther = { q: otherHexFromRefEdge.q - pivotHex.q, r: otherHexFromRefEdge.r - pivotHex.r };
            const dirToTargetOther = { q: otherHexFromTargetEdge.q - pivotHex.q, r: otherHexFromTargetEdge.r - pivotHex.r };

            const refDirIdx = findDirectionIndex(dirToRefOther);
            const targetDirIdx = findDirectionIndex(dirToTargetOther);

            if (refDirIdx === -1 || targetDirIdx === -1) return false;

            return (targetDirIdx === (refDirIdx + 1) % 6) || (targetDirIdx === (refDirIdx + 5) % 6);
        }


        // --- Initialization ---
         function initializeGrid(tileLayoutMap = null) {
            canvas.width = (2 * gameState.gridRadius + 1.5) * (HEX_SIZE * Math.sqrt(3));
            canvas.height = (2 * gameState.gridRadius + 1) * (HEX_SIZE * 2 * 0.75) + HEX_SIZE;
            document.querySelectorAll('.ui-panel').forEach(panel => { panel.style.minHeight = canvas.height + 'px'; });

            gameState.tiles.clear(); gameState.edges.clear(); gameState.units = [];
            gameState.gameOver = false; ui.victoryMessage.style.display = 'none';
            ui.endTurnButton.disabled = false;
            gameState.selectedUnit = null; 
            gameState.hoveredUnitId = null; 
            gameState.currentPlayer = 1;
            gameState.globalTurnNumber = 1; 
            updateGlobalTurnDisplay();
            gameState.isDragging = false; 
            gameState.draggingUnit = null; 
            gameState.currentReachableMoves.clear();
            resetActionSelectionStates();
            gameState.actionLog = [];
            gameState.respawnQueue = { player1: [], player2: [] };
            updateActionLogDisplay();
            
            gameState.supplyPoints = { player1: 10, player2: 10 };
            updateSupplyPointsDisplay();

            gameState.unitCounts = {
                player1: { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 },
                player2: { Melee: 0, Archer: 0, Pikeman: 0, Horseman: 0 }
            };

            // Initialize Flags
            gameState.flags = {
                'p1_flag': {
                    id: 'p1_flag',
                    player: 1,
                    homePosition: FLAG_HOME_POSITIONS.player1,
                    status: 'at_base', 
                    carrierId: null
                },
                'p2_flag': {
                    id: 'p2_flag',
                    player: 2,
                    homePosition: FLAG_HOME_POSITIONS.player2,
                    status: 'at_base',
                    carrierId: null
                }
            };

            if (tileLayoutMap) {
                tileLayoutMap.forEach((type, key) => {
                    const [q, r] = key.split(',').map(Number);
                    gameState.tiles.set(key, { q, r, type, fortifiedByPlayer: null });
                });
            } else {
                if (typeof DEFAULT_MAP_LAYOUT_RADIUS_3 !== 'undefined' && gameState.gridRadius === 3) {
                    DEFAULT_MAP_LAYOUT_RADIUS_3.forEach((type, key) => {
                        const [q, r] = key.split(',').map(Number);
                        gameState.tiles.set(key, { q, r, type, fortifiedByPlayer: null });
                    });
                } else {
                    console.error(`Could not load default map for radius ${gameState.gridRadius}. Generating a blank plains map.`);
                    for (let q = -gameState.gridRadius; q <= gameState.gridRadius; q++) {
                        for (let r = -gameState.gridRadius; r <= gameState.gridRadius; r++) {
                            if (Math.abs(q + r) <= gameState.gridRadius) {
                                const tileKey = getTileKey(q, r);
                                gameState.tiles.set(tileKey, { q, r, type: TILE_TYPES.PLAINS, fortifiedByPlayer: null });
                            }
                        }
                    }
                }
            }

            gameState.tiles.forEach(tile => {
                const {q, r} = tile;
                getNeighbors(q, r).forEach(n_coord => {
                     if (gameState.tiles.has(getTileKey(n_coord.q, n_coord.r))) {
                        const edgeKey = getEdgeKey(q, r, n_coord.q, n_coord.r);
                        if (!gameState.edges.has(edgeKey)) {
                             gameState.edges.set(edgeKey, {
                                q1: q, r1: r, q2: n_coord.q, r2: n_coord.r,
                                units: [], bridge: false, bridgeHp: null, isPathway: true
                            });
                        }
                    }
                });
            });

// If a tileLayoutMap is provided, decide how to place units.
if (tileLayoutMap) {
    // If it's the default map, use the default hardcoded positions.
    if (tileLayoutMap === DEFAULT_MAP_LAYOUT_RADIUS_3) {
        gameState.units.push(createUnit(1, UNIT_TYPES.MELEE,    getEdgeKey(1, -2, 0, -2)));
        gameState.units.push(createUnit(1, UNIT_TYPES.ARCHER,   getEdgeKey(-2, 0, -1, -1)));
        gameState.units.push(createUnit(1, UNIT_TYPES.PIKEMAN,  getEdgeKey(-1, -1, 0, -2)));
        gameState.units.push(createUnit(1, UNIT_TYPES.HORSEMAN, getEdgeKey(-2, 0, -2, 1)));
        
        gameState.units.push(createUnit(2, UNIT_TYPES.MELEE,    getEdgeKey(-1, 2, 0, 2)));
        gameState.units.push(createUnit(2, UNIT_TYPES.ARCHER,   getEdgeKey(1, 1, 2, 0)));
        gameState.units.push(createUnit(2, UNIT_TYPES.PIKEMAN,  getEdgeKey(0, 2, 1, 1)));
        gameState.units.push(createUnit(2, UNIT_TYPES.HORSEMAN, getEdgeKey(2, 0, 2, -1)));

         gameState.units.forEach(unit => {
            const edge = gameState.edges.get(unit.position);
            if (edge) edge.units.push(unit);
            else console.error("Failed to place unit on default edge:", unit.position, unit);
        });
    } else {
        // Otherwise, it's a newly generated map, so place units for that.
        placeUnitsOnNewGeneratedMap();
    }
} else { 
    // If no map was provided at all, fallback to default map and units.
    gameState.units.push(createUnit(1, UNIT_TYPES.MELEE,    getEdgeKey(1, -2, 0, -2)));
    gameState.units.push(createUnit(1, UNIT_TYPES.ARCHER,   getEdgeKey(-2, 0, -1, -1)));
    gameState.units.push(createUnit(1, UNIT_TYPES.PIKEMAN,  getEdgeKey(-1, -1, 0, -2)));
    gameState.units.push(createUnit(1, UNIT_TYPES.HORSEMAN, getEdgeKey(-2, 0, -2, 1)));
    
    gameState.units.push(createUnit(2, UNIT_TYPES.MELEE,    getEdgeKey(-1, 2, 0, 2)));
    gameState.units.push(createUnit(2, UNIT_TYPES.ARCHER,   getEdgeKey(1, 1, 2, 0)));
    gameState.units.push(createUnit(2, UNIT_TYPES.PIKEMAN,  getEdgeKey(0, 2, 1, 1)));
    gameState.units.push(createUnit(2, UNIT_TYPES.HORSEMAN, getEdgeKey(2, 0, 2, -1)));

     gameState.units.forEach(unit => {
        const edge = gameState.edges.get(unit.position);
        if (edge) edge.units.push(unit);
        else console.error("Failed to place unit on default edge:", unit.position, unit);
    });
}                                                       

            gameState.units.forEach(unit => {
                unit.currentMove = unit.type.baseMove; unit.hasPerformedMajorAction = false;
            });
            updateTurnDisplay(); 
            updateSelectedUnitInfoPanel(); 
            checkVictoryCondition();
        }

        function createUnit(player, type, edgeKey) {
            const unitId = `unit_${player}_${type.name.toLowerCase()}_${Date.now()}_${Math.random().toString(16).slice(2)}`;
            
            if (gameState.unitCounts) {
                gameState.unitCounts[`player${player}`][type.name]++;
            }

            return {
    id: unitId, player, type, hp: type.hp, maxHp: type.hp,
    currentMove: type.baseMove, positionType: 'edge', position: edgeKey,
    isFortified: false, fortifiedTileKey: null, hasPerformedMajorAction: false,
    isCarryingFlag: false,
    turnsFortifiedAtBase: 0,
    turnsFortified: 0,
    fortifyCooldown: 0,
    canHeal: true,
    supplyLine: null,
    lastAttackedByHostileOnTurn: 0,
};
        }

        function spawnUnit(player, unitType) {
            const homeBaseEdgeKey = FLAG_HOME_POSITIONS[`player${player}`];
            let spawnEdgeKey = null;

            const isEdgeValidForSpawn = (edgeKey) => {
                const edge = gameState.edges.get(edgeKey);
                // A valid edge must exist, have less than 2 units, and have NO enemy units.
                // Also ensure it's not the home flag edge itself.
                if (edgeKey === homeBaseEdgeKey) return false;
                return edge && edge.units.length < 2 && !edge.units.some(u => u.player !== player);
            };

            // Search rotationally adjacent edges for a valid spawn point
            const adjacentEdges = getRotationallyAdjacentEdges(homeBaseEdgeKey);
            for (const edgeKey of adjacentEdges) {
                if (isEdgeValidForSpawn(edgeKey)) {
                    spawnEdgeKey = edgeKey;
                    break; 
                }
            }

            if (spawnEdgeKey) {
                const newUnit = createUnit(player, unitType, spawnEdgeKey);
                gameState.units.push(newUnit);
                const edge = gameState.edges.get(spawnEdgeKey);
                edge.units.push(newUnit);
                logAction(`P${player} ${unitType.name} has returned to the fight!`, player);
                return true;
            }
            
            logAction(`P${player} Base is blocked! Cannot respawn ${unitType.name}.`, player);
            return false;
        }

        function pointDistance(p1, p2) { return Math.sqrt(distSq(p1,p2)); }

        // --- Drawing Functions ---
        function drawHexFill(q, r, tileType) {
            const { x, y } = axialToPixel(q, r);

            if (gameSettings.fancyVisualsEnabled) {
                // --- FANCY VISUALS ON ---
                if (tileType === TILE_TYPES.MOUNTAIN) {
                    const mountainColors = [
                        '#808080', '#707070', '#606060', '#707070', '#808080', '#A0A0A0'
                    ];
                    const vertices = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        vertices.push({ x: x + HEX_SIZE * Math.cos(angle), y: y + HEX_SIZE * Math.sin(angle) });
                    }
                    for (let i = 0; i < 6; i++) {
                        const v1 = vertices[i];
                        const v2 = vertices[(i + 1) % 6];
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.closePath();
                        ctx.fillStyle = mountainColors[i];
                        ctx.fill();
                    }
                } else if (tileType === TILE_TYPES.FOREST) {
                    const forestEdgeColors = [
                        '#209020', '#207020', '#206020', '#207020', '#209020', '#209F20'
                    ];
                    const baseVertices = [];
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        baseVertices.push({ x: x + HEX_SIZE * Math.cos(angle), y: y + HEX_SIZE * Math.sin(angle) });
                    }
                    for (let i = 0; i < 6; i++) {
                        const v1 = baseVertices[i];
                        const v2 = baseVertices[(i + 1) % 6];
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                        ctx.lineTo(v1.x, v1.y);
                        ctx.lineTo(v2.x, v2.y);
                        ctx.closePath();
                        ctx.fillStyle = forestEdgeColors[i];
                        ctx.fill();
                    }
                    const topHexSize = HEX_SIZE * 0.75;
                    const topHexColor = '#208020';
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = x + topHexSize * Math.cos(angle);
                        const vy = y + topHexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath();
                    ctx.fillStyle = topHexColor;
                    ctx.fill();
                } else if (tileType === TILE_TYPES.WATER) {
                    ctx.save();
                    ctx.translate(x, y);
                    ctx.rotate(-60 * Math.PI / 180);
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = HEX_SIZE * Math.cos(angle);
                        const vy = HEX_SIZE * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath();
                    ctx.clip();
                    const stripeColors = ['#60B0CF', '#6AC0D4', '#75D0DA', '#80E0E0'];
                    const stripeCount = 4;
                    const hexTotalWidth = HEX_SIZE * Math.sqrt(3);
                    const stripeWidth = hexTotalWidth / stripeCount;
                    const startX = -(hexTotalWidth / 2);
                    for (let i = 0; i < stripeCount; i++) {
                        ctx.fillStyle = stripeColors[i];
                        const stripeX = startX + (i * stripeWidth);
                        ctx.fillRect(stripeX, -HEX_SIZE, stripeWidth + 1, HEX_SIZE * 2);
                    }
                    ctx.restore();
                } else if (tileType === TILE_TYPES.PLAINS) {
                    // --- NEW: Logic for concentric Plains hexagons ---
                    const plainsColors = ['#70E070', '#7AE07A', '#85E085', '#90E090']; // 25, 26, 27, 28
                    const plainsSizeMultipliers = [1.0, 0.75, 0.50, 0.25]; // 100%, 75%, 50%, 25%

                    // Loop from largest to smallest to draw them on top of each other
                    for (let i = 0; i < plainsSizeMultipliers.length; i++) {
                        const currentSize = HEX_SIZE * plainsSizeMultipliers[i];
                        ctx.fillStyle = plainsColors[i];
                        
                        ctx.beginPath();
                        for (let j = 0; j < 6; j++) {
                            const angle = Math.PI / 180 * (60 * j - 30);
                            const vx = x + currentSize * Math.cos(angle);
                            const vy = y + currentSize * Math.sin(angle);
                            if (j === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                        }
                        ctx.closePath();
                        ctx.fill();
                    }

                } else { 
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = x + HEX_SIZE * Math.cos(angle); 
                        const vy = y + HEX_SIZE * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath(); 
                    ctx.fillStyle = tileType.color;
                    ctx.fill();
                }
            } else {
                // --- FANCY VISUALS OFF (SIMPLE SOLID COLORS) ---
                let fallbackColor;
                switch (tileType) {
                    case TILE_TYPES.MOUNTAIN:
                        fallbackColor = '#808080';
                        break;
                    case TILE_TYPES.FOREST:
                        fallbackColor = '#208020';
                        break;
                    case TILE_TYPES.WATER:
                        fallbackColor = '#80E0E0';
                        break;
                    case TILE_TYPES.PLAINS:
                        fallbackColor = '#90E090';
                        break;
                    default:
                        fallbackColor = tileType.color;
                }
                
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 180 * (60 * i - 30);
                    const vx = x + HEX_SIZE * Math.cos(angle); 
                    const vy = y + HEX_SIZE * Math.sin(angle);
                    if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                }
                ctx.closePath(); 
                ctx.fillStyle = fallbackColor;
                ctx.fill();
            }
        }

        function drawHexEdgesAndBoundaries() {
            const edgeLineWidth = 2;
            gameState.edges.forEach(edge => {
                const tileA = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
                const tileB = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
                if (!tileA || !tileB) return;
                const typeA = tileA.type; const typeB = tileB.type; let edgeStrokeColor;
                const landEdgeColor = '#A05030'; const beachEdgeColor = '#F0E090'; const waterEdgeColor = '#4080C0';
                if (isLand(typeA) && isLand(typeB)) edgeStrokeColor = landEdgeColor;
                else if ((isLand(typeA) && typeB === TILE_TYPES.WATER) || (typeA === TILE_TYPES.WATER && isLand(typeB))) edgeStrokeColor = beachEdgeColor;
                else if (typeA === TILE_TYPES.WATER && typeB === TILE_TYPES.WATER) edgeStrokeColor = waterEdgeColor;
                else edgeStrokeColor = '#1a252f';

                const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
                const edgeMidX = (p1_center.x + p2_center.x) / 2; const edgeMidY = (p1_center.y + p2_center.y) / 2;
                const dx_centers = p2_center.x - p1_center.x; const dy_centers = p2_center.y - p1_center.y;
                let perp_dx = -dy_centers; let perp_dy = dx_centers;
                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                if (len_perp_vec === 0) return;
                perp_dx = (perp_dx / len_perp_vec) * (HEX_SIZE / 2); perp_dy = (perp_dy / len_perp_vec) * (HEX_SIZE / 2);
                ctx.beginPath(); ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy); ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                ctx.strokeStyle = edgeStrokeColor; ctx.lineWidth = edgeLineWidth; ctx.stroke();
            });

             const boundaryEdgeColor = '#000000';
             gameState.tiles.forEach(tile => {
                 const {q, r} = tile; const {x: centerX, y: centerY} = axialToPixel(q,r);
                 for (let directionIndex = 0; directionIndex < 6; directionIndex++) {
                     const neighborDir = AXIAL_DIRECTIONS[directionIndex];
                     const neighborQ = q + neighborDir.q; const neighborR = r + neighborDir.r;
                     if (!gameState.tiles.has(getTileKey(neighborQ, neighborR))) {
                         const edgeIndexOfCurrentHex = MAP_DIRECTION_TO_EDGE_INDEX[directionIndex];
                         const v1_idx = edgeIndexOfCurrentHex; const v2_idx = (edgeIndexOfCurrentHex + 1) % 6;
                         const vert1_angle = Math.PI / 180 * (60 * v1_idx - 30);
                         const edge_v1_x = centerX + HEX_SIZE * Math.cos(vert1_angle); const edge_v1_y = centerY + HEX_SIZE * Math.sin(vert1_angle);
                         const vert2_angle = Math.PI / 180 * (60 * v2_idx - 30);
                         const edge_v2_x = centerX + HEX_SIZE * Math.cos(vert2_angle); const edge_v2_y = centerY + HEX_SIZE * Math.sin(vert2_angle);
                         ctx.beginPath(); ctx.moveTo(edge_v1_x, edge_v1_y); ctx.lineTo(edge_v2_x, edge_v2_y);
                         ctx.strokeStyle = boundaryEdgeColor; ctx.lineWidth = edgeLineWidth; ctx.stroke();
                     }
                 }
             });
        }

        function drawUnitHealthBar(ctx, unitX, unitY, ringOuterRadius, ringThickness, currentHp, maxHp) {
            if (maxHp <= 0) return;
            
            const displayHpPercentage = Math.max(0, Math.min(1, currentHp / maxHp)); 
            const isShielded = currentHp > maxHp;

            const startAngle = -Math.PI / 2; 
            const fullAngle = 2 * Math.PI;
            const healthRingCenterlineRadius = ringOuterRadius - (ringThickness / 2);
            
            const originalLineWidth = ctx.lineWidth; 
            const originalLineCap = ctx.lineCap;
            ctx.lineWidth = ringThickness; 
            ctx.lineCap = 'butt';

            if (displayHpPercentage < 1) {
                ctx.beginPath(); 
                ctx.strokeStyle = '#4A4A4A'; 
                const healthEndAngle = startAngle + displayHpPercentage * fullAngle;
                ctx.arc(unitX, unitY, healthRingCenterlineRadius, healthEndAngle, startAngle + fullAngle, false);
                ctx.stroke();
            }

            if (displayHpPercentage > 0) {
                ctx.beginPath(); 
                ctx.strokeStyle = isShielded ? SHIELD_COLOR : '#32CD32'; 
                const currentHealthEndAngle = startAngle + displayHpPercentage * fullAngle;
                ctx.arc(unitX, unitY, healthRingCenterlineRadius, startAngle, currentHealthEndAngle, false);
                ctx.stroke();
            }
            
            ctx.lineWidth = originalLineWidth; 
            ctx.lineCap = originalLineCap;
        }


        function drawFortificationOutlines() {
            const fortifiedTilesP1 = new Set();
            const fortifiedTilesP2 = new Set();

            gameState.tiles.forEach((tile, key) => {
                if (tile.fortifiedByPlayer === 1) {
                    fortifiedTilesP1.add(key);
                } else if (tile.fortifiedByPlayer === 2) {
                    fortifiedTilesP2.add(key);
                }
            });

            const p1BaseEdgeKey = FLAG_HOME_POSITIONS.player1;
            const [p1_h1, p1_h2] = parseEdgeKey(p1BaseEdgeKey);
            const p1BaseTileKeys = [getTileKey(p1_h1.q, p1_h1.r), getTileKey(p1_h2.q, p1_h2.r)];
            p1BaseTileKeys.forEach(key => fortifiedTilesP1.add(key));


            const p2BaseEdgeKey = FLAG_HOME_POSITIONS.player2;
            const [p2_h1, p2_h2] = parseEdgeKey(p2BaseEdgeKey);
            const p2BaseTileKeys = [getTileKey(p2_h1.q, p2_h1.r), getTileKey(p2_h2.q, p2_h2.r)];
            p2BaseTileKeys.forEach(key => fortifiedTilesP2.add(key));


            const drawBordersForPlayer = (tileSet, color) => {
                tileSet.forEach(tileKey => {
                    const tile = gameState.tiles.get(tileKey);
                    if (!tile) return;

                    const { x: centerX, y: centerY } = axialToPixel(tile.q, tile.r);

                    for (let i = 0; i < 6; i++) {
                        const neighborDir = AXIAL_DIRECTIONS[i];
                        const neighborQ = tile.q + neighborDir.q;
                        const neighborR = tile.r + neighborDir.r;
                        const neighborKey = getTileKey(neighborQ, neighborR);

                        // Only draw the edge if the neighbor is not in the same player's fortified set.
                        if (!tileSet.has(neighborKey)) {
                             // FIX: Use the mapping constant to get the correct edge index for drawing
                             const v1_idx = MAP_DIRECTION_TO_EDGE_INDEX[i];
                             const v2_idx = (v1_idx + 1) % 6;
                             
                             const vert1_angle = Math.PI / 180 * (60 * v1_idx - 30);
                             const edge_v1_x = centerX + HEX_SIZE * Math.cos(vert1_angle);
                             const edge_v1_y = centerY + HEX_SIZE * Math.sin(vert1_angle);

                             const vert2_angle = Math.PI / 180 * (60 * v2_idx - 30);
                             const edge_v2_x = centerX + HEX_SIZE * Math.cos(vert2_angle);
                             const edge_v2_y = centerY + HEX_SIZE * Math.sin(vert2_angle);
                             
                             ctx.beginPath();
                             ctx.moveTo(edge_v1_x, edge_v1_y);
                             ctx.lineTo(edge_v2_x, edge_v2_y);
                             ctx.strokeStyle = color;
                             ctx.lineWidth = 5;
                             ctx.stroke();
                        }
                    }
                });
            };

            drawBordersForPlayer(fortifiedTilesP1, currentDrawingColors.player1.primary);
            drawBordersForPlayer(fortifiedTilesP2, currentDrawingColors.player2.primary);
        }

        function drawContestedEdgeIndicator() {
            const CONTESTED_EDGE_COLOR = '#C440C4';

            gameState.edges.forEach(edge => {
                if (edge.units.length < 2) return;

                const playerOnEdge = edge.units[0].player;
                const allUnitsSamePlayer = edge.units.every(u => u.player === playerOnEdge);
                if (!allUnitsSamePlayer) return;

                const hasArcher = edge.units.some(u => u.type.name === 'Archer');
                const hasMelee = edge.units.some(u => u.type.name === 'Melee');
                
                if (!hasArcher || !hasMelee) return;

                const opponentPlayer = playerOnEdge === 1 ? 2 : 1;
                const tile1 = gameState.tiles.get(getTileKey(edge.q1, edge.r1));
                const tile2 = gameState.tiles.get(getTileKey(edge.q2, edge.r2));
                const isContested = (tile1 && tile1.fortifiedByPlayer === opponentPlayer) || 
                                  (tile2 && tile2.fortifiedByPlayer === opponentPlayer);

                if (isContested) {
                    const p1_center = axialToPixel(edge.q1, edge.r1);
                    const p2_center = axialToPixel(edge.q2, edge.r2);
                    const edgeMidX = (p1_center.x + p2_center.x) / 2;
                    const edgeMidY = (p1_center.y + p2_center.y) / 2;

                    let perp_dx = -(p2_center.y - p1_center.y);
                    let perp_dy = p2_center.x - p1_center.x;
                    const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                    if (len_perp_vec > 0) {
                        const scale = HEX_SIZE / 2;
                        perp_dx = (perp_dx / len_perp_vec) * scale;
                        perp_dy = (perp_dy / len_perp_vec) * scale;
                        
                        const startX = edgeMidX + perp_dx;
                        const startY = edgeMidY + perp_dy;
                        const endX = edgeMidX - perp_dx;
                        const endY = edgeMidY - perp_dy;

                        ctx.beginPath();
                        ctx.moveTo(startX, startY);
                        ctx.lineTo(endX, endY);
                        ctx.strokeStyle = CONTESTED_EDGE_COLOR;
                        ctx.lineWidth = 5;
                        ctx.stroke();
                    }
                }
            });
        }


        function drawActionSelectionHighlights(targetKeys, type) {
            if (!targetKeys || targetKeys.length === 0) return;
            let fillColor, strokeColor;
            switch(type) {
                case 'fortify':
                    fillColor = 'rgba(255, 255, 0, 0.3)'; strokeColor = '#FFD700';
                    targetKeys.forEach(tileKey => {
                        const tile = gameState.tiles.get(tileKey);
                        if (tile) {
                           const { x, y } = axialToPixel(tile.q, tile.r); ctx.beginPath();
                           for (let i = 0; i < 6; i++) {
                               const angle = Math.PI / 180 * (60 * i - 30);
                               const vx = x + HEX_SIZE * Math.cos(angle); const vy = y + HEX_SIZE * Math.sin(angle);
                               if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                           }
                           ctx.closePath(); ctx.fillStyle = fillColor; ctx.fill();
                           ctx.strokeStyle = strokeColor; ctx.lineWidth = 3; ctx.stroke();
                        }
                    });
                    break;
                case 'unfortify': case 'bridge':
                    fillColor = type === 'unfortify' ? 'rgba(0, 150, 255, 0.4)' : 'rgba(139, 69, 19, 0.4)';
                    strokeColor = type === 'unfortify' ? '#007ACC' : '#8B4513';
                    targetKeys.forEach(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        if (edge) {
                            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                            ctx.beginPath(); ctx.arc(mid.x, mid.y, HEX_SIZE * 0.25, 0, 2 * Math.PI);
                            ctx.fillStyle = fillColor; ctx.fill();
                            ctx.strokeStyle = strokeColor; ctx.lineWidth = 2; ctx.stroke();
                        }
                    });
                    break;
                

            }
        }

function drawBridge(edge, color = '#8B4513', outlineColor = null, outlineWidth = 0) {
    const p1_center = axialToPixel(edge.q1, edge.r1);
    const p2_center = axialToPixel(edge.q2, edge.r2);
    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
    const angle = Math.atan2(p2_center.y - p1_center.y, p2_center.x - p1_center.x);
    
    // The main bridge body dimensions
    const bridgeLength = HEX_SIZE * 0.9; 
    const bridgeThickness = HEX_SIZE * 0.15;

    ctx.save();
    ctx.translate(mid.x, mid.y);
    ctx.rotate(angle + Math.PI / 2); // Rotate to align with the edge itself

    // --- Draw the main bridge body (darker brown) ---
    ctx.fillStyle = color; // e.g., #8B4513
    ctx.fillRect(-bridgeLength / 2, -bridgeThickness / 2, bridgeLength, bridgeThickness);
    
    // --- Draw the 4 perpendicular planks (lighter brown) ---
    const plankColor = '#A0522D'; // A lighter, Sienna brown
    const plankLength = bridgeThickness * 1.2; // Planks stick out a little
    const plankWidth = 5; // Thinner than before
    const gap = bridgeLength / 4.5; // The unit of spacing

    ctx.fillStyle = plankColor;
    // Plank 1 (Far Left) at -1.5 gaps
    ctx.fillRect(-gap * 1.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
    // Plank 2 (Inner Left) at -0.5 gaps
    ctx.fillRect(-gap * 0.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
    // Plank 3 (Inner Right) at +0.5 gaps
    ctx.fillRect(gap * 0.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);
    // Plank 4 (Far Right) at +1.5 gaps
    ctx.fillRect(gap * 1.5 - (plankWidth / 2), -plankLength / 2, plankWidth, plankLength);


    if (outlineColor && outlineWidth > 0) {
        ctx.strokeStyle = outlineColor;
        ctx.lineWidth = outlineWidth;
        // Outline the main body only for clarity
        ctx.strokeRect(-bridgeLength / 2, -bridgeThickness / 2, bridgeLength, bridgeThickness);
    }

    ctx.restore();
}

        function drawBridges() { gameState.edges.forEach(edge => { if (edge.bridge) drawBridge(edge); }); }

        function drawBridgeAttackHighlightsOnly(targetsToHighlight) {
            if (!targetsToHighlight || targetsToHighlight.length === 0) return;
            targetsToHighlight.forEach(targetInfo => {
                if (targetInfo.isBridgeTarget && targetInfo.edgeKey) {
                    const edge = gameState.edges.get(targetInfo.edgeKey);
                    if (edge && edge.bridge) drawBridge(edge, 'rgba(139, 69, 19, 0.5)', 'rgba(255, 0, 0, 0.9)', 3);
                }
            });
        }

        function drawFlags() {
            if (!gameState.flags) return;

            Object.values(gameState.flags).forEach(flag => {
                if (flag.status === 'at_base') {
                    const edge = gameState.edges.get(flag.homePosition);
                    if (!edge) return;
                    
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    const teamColor = currentDrawingColors[`player${flag.player}`].secondary;
                    const flagIconColor = '#ecf0f1'; 
                    const flagPoleColor = '#2c3e50';
                    const circleRadius = HEX_SIZE * 0.18;
                    const flagSize = circleRadius * 1.2; 

                    ctx.save();
                    ctx.translate(mid.x, mid.y);

                    ctx.beginPath();
                    ctx.arc(0, 0, circleRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = teamColor; 
                    ctx.fill();

                    ctx.strokeStyle = '#1a252f';
                    ctx.lineWidth = 2;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-3, flagSize * 0.5);
                    ctx.lineTo(-3, -flagSize * 0.5);
                    ctx.strokeStyle = flagPoleColor;
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(-2, -flagSize * 0.5);
                    ctx.lineTo(flagSize * 0.45, -flagSize * 0.3);
                    ctx.lineTo(-2, -flagSize * 0);
                    ctx.closePath();
                    ctx.fillStyle = flagIconColor; 
                    ctx.fill(); 
                    
                    ctx.restore();
                }
            });
        }

        function drawSupplyLines() {
            const currentTime = Date.now();
            
            gameState.units.forEach(unit => {
                if (unit.isFortified && unit.supplyLine && unit.supplyLine.path) {
                    const path = unit.supplyLine.path;
                    if (path.length === 0) return;

                    // Check for interception to determine color
                    const isIntercepted = path.some(edgeKey => {
                    const edge = gameState.edges.get(edgeKey);
                    if (!edge) return false;
                    // An edge is intercepted if it has an enemy unit that is NOT currently being dragged.
                    return edge.units.some(u => u.player !== unit.player && (!gameState.isDragging || u.id !== gameState.draggingUnit.id));
                });

                    // Set line style based on status
                    let lineColor, lineWidth, isDashed;
                    if (isIntercepted) {
                        lineColor = '#F0A010'; // Bright orange for broken supply
                        lineWidth = 4;
                        isDashed = true;
                    } else {
                        lineColor = unit.player === 1 ? hexToRgba(currentDrawingColors.player1.accent, 0.8) : hexToRgba(currentDrawingColors.player2.accent, 0.8);
                        // Create a pulse effect for the line width
                        const pulse = (Math.sin(currentTime / 300) + 1) / 2; // Varies between 0 and 1
                        lineWidth = 2 + pulse * 3; // Varies between 2 and 5
                        isDashed = false;
                    }

                    ctx.save();
                    ctx.strokeStyle = lineColor;
                    ctx.lineWidth = lineWidth;
                    ctx.lineCap = 'round';
                    if (isDashed) {
                        ctx.setLineDash([15, 10]);
                    }

                    // Draw the supply line along the edges
                    path.forEach(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        if(edge) {
                            const p1_center = axialToPixel(edge.q1, edge.r1);
                            const p2_center = axialToPixel(edge.q2, edge.r2);
                            const edgeMidX = (p1_center.x + p2_center.x) / 2;
                            const edgeMidY = (p1_center.y + p2_center.y) / 2;
                            
                            let perp_dx = -(p2_center.y - p1_center.y);
                            let perp_dy = p2_center.x - p1_center.x;
                            const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                            
                            if (len_perp_vec > 0) {
                                const scale = HEX_SIZE / 2;
                                perp_dx = (perp_dx / len_perp_vec) * scale;
                                perp_dy = (perp_dy / len_perp_vec) * scale;

                                ctx.beginPath();
                                ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy);
                                ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                                ctx.stroke();
                            }
                        }
                    });
                    
                    ctx.restore();
                }
            });
        }

        function drawUnitAttackHighlightsOnly(targetsToHighlight) {
            if (!targetsToHighlight || targetsToHighlight.length === 0) return;
            targetsToHighlight.forEach(targetInfo => {
                if (!targetInfo.isBridgeTarget && targetInfo.unit) {
                    const targetUnit = targetInfo.unit; let unitX, unitY;
                    const unitSizeToHighlight = HEX_SIZE * 0.3;
                    if (targetUnit.isFortified && targetUnit.positionType === 'center' && targetInfo.tileKeyForTarget) {
                        const tile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                        if (tile) { const centerPixel = axialToPixel(tile.q, tile.r); unitX = centerPixel.x; unitY = centerPixel.y; }
                        else return;
                    } else if (targetInfo.edgeKey) {
                        const edge = gameState.edges.get(targetInfo.edgeKey); if (!edge) return;
                        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2); unitX = mid.x; unitY = mid.y;
                        const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                        const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === targetUnit.id);
                        if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                            const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                            let dx = p2.x - p1.x, dy = p2.y - p1.y; const len = Math.sqrt(dx*dx + dy*dy) || 1;
                            let perpX = -dy / len, perpY = dx / len;
                            unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                            unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                        }
                    } else return;
                    ctx.beginPath(); ctx.arc(unitX, unitY, unitSizeToHighlight, 0, 2 * Math.PI);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)'; ctx.lineWidth = 3; ctx.stroke();
                }
            });
        }

        function drawSword(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 0.75; 
            ctx.strokeStyle = symbolColor;
            ctx.fillStyle = symbolColor;
            ctx.lineWidth = Math.max(1.5, symbolDisplayRadius * 0.08);
            ctx.lineJoin = 'round';
            const pommelRadius = scale * 0.15;
            const pommelY = centerY + scale * 0.55;
            ctx.beginPath();
            ctx.arc(centerX, pommelY, pommelRadius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.lineCap = 'round';
            const guardWidth = scale * 0.75;
            const guardY = centerY + scale * 0.2;
            const guardThickness = scale * 0.15;
            ctx.beginPath();
            ctx.moveTo(centerX - guardWidth / 2, guardY);
            ctx.lineTo(centerX + guardWidth / 2, guardY);
            const oldWidth = ctx.lineWidth;
            ctx.lineWidth = guardThickness;
            ctx.stroke();
            ctx.lineWidth = oldWidth;
            ctx.lineCap = 'butt';
            const bladeWidth = scale * 0.22;
            const bladeHeight = scale * 0.9;
            const bladeY = guardY - bladeHeight;
            ctx.beginPath();
            ctx.rect(centerX - bladeWidth / 2, bladeY, bladeWidth, bladeHeight);
            ctx.fill();
            const tipBaseY = bladeY;
            const tipHeight = scale * 0.35;
            const tipTopY = tipBaseY - tipHeight;
            const tipWidth = bladeWidth * 1.1;
            ctx.beginPath();
            ctx.moveTo(centerX, tipTopY); 
            ctx.lineTo(centerX - tipWidth / 2, tipBaseY); 
            ctx.lineTo(centerX + tipWidth / 2, tipBaseY); 
            ctx.closePath();
            ctx.fill();
        }

        function drawArrow(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 1.0; 
            ctx.fillStyle = symbolColor;
            ctx.strokeStyle = symbolColor; 
            ctx.lineWidth = Math.max(1.0, symbolDisplayRadius * 0.05);
            ctx.lineJoin = 'round';
            ctx.beginPath();
            const tipY = centerY - scale * 0.7;
            ctx.moveTo(centerX, tipY);
            const headBaseY = centerY - scale * 0.4;
            const headWidth = scale * 0.4;
            ctx.lineTo(centerX - headWidth / 2, headBaseY); 
            const shaftWidth = scale * 0.15;
            const shaftTopY = centerY - scale * 0.35;
            ctx.lineTo(centerX - shaftWidth / 2, headBaseY);
            ctx.lineTo(centerX - shaftWidth / 2, shaftTopY);
            const fletchTopY = centerY + scale * 0.2;
            const fletchBottomY = centerY + scale * 0.7;
            const fletchWidth = scale * 0.5;
            ctx.lineTo(centerX - shaftWidth / 2, fletchTopY); 
            ctx.lineTo(centerX - fletchWidth / 2, fletchBottomY); 
            ctx.lineTo(centerX, centerY + scale * 0.55); 
            ctx.lineTo(centerX + fletchWidth / 2, fletchBottomY); 
            ctx.lineTo(centerX + shaftWidth / 2, fletchTopY);
            ctx.lineTo(centerX + shaftWidth / 2, shaftTopY);
            ctx.lineTo(centerX + shaftWidth / 2, headBaseY);
            ctx.lineTo(centerX + headWidth / 2, headBaseY);
            ctx.closePath();
            ctx.fill();
        }

        function drawPikemanSymbol(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 0.9; 
            ctx.strokeStyle = symbolColor;
            ctx.fillStyle = symbolColor;
            ctx.lineWidth = Math.max(1.0, symbolDisplayRadius * 0.05);
            ctx.lineJoin = 'round';
            ctx.beginPath();
            const shaftWidth = scale * 0.12;
            const shaftBottomY = centerY + scale * 0.75;
            ctx.moveTo(centerX - shaftWidth / 2, shaftBottomY);
            const axeBottomY = centerY + scale * 0.05;
            ctx.lineTo(centerX - shaftWidth / 2, axeBottomY);
            const axeTopY = centerY - scale * 0.35;
            ctx.quadraticCurveTo(
                centerX - scale * 0.6, 
                centerY - scale * 0.15,
                centerX - shaftWidth / 2, axeTopY 
            );
            const spearBaseY = centerY - scale * 0.5;
            ctx.lineTo(centerX - shaftWidth / 2, spearBaseY);
            const spearTipY = centerY - scale * 0.8;
            ctx.lineTo(centerX, spearTipY); 
            ctx.lineTo(centerX + shaftWidth / 2, spearBaseY); 
            const spikeTopY = centerY - scale * 0.3;
            ctx.lineTo(centerX + shaftWidth / 2, spikeTopY);
            const spikePointX = centerX + scale * 0.35;
            const spikeMidY = centerY - scale * 0.2;
            const spikeBottomY = centerY - scale * 0.1;
            ctx.lineTo(spikePointX, spikeMidY); 
            ctx.lineTo(centerX + shaftWidth / 2, spikeBottomY); 
            ctx.lineTo(centerX + shaftWidth / 2, shaftBottomY);
            ctx.closePath();
            ctx.fill();
        }

        function drawHorsemanSymbol(ctx, centerX, centerY, symbolDisplayRadius, symbolColor) {
            const scale = symbolDisplayRadius * 1.0;
            ctx.fillStyle = symbolColor;
            ctx.beginPath();
            ctx.moveTo(centerX - scale * 0.3, centerY + scale * 0.5);
            ctx.lineTo(centerX + scale * 0.3, centerY + scale * 0.5);
            ctx.lineTo(centerX + scale * 0.3, centerY + scale * 0.15);
            ctx.lineTo(centerX + scale * 0.15, centerY - scale * 0.05);
            ctx.lineTo(centerX + scale * 0.45, centerY - scale * 0.15);
            ctx.lineTo(centerX + scale * 0.45, centerY - scale * 0.35);
            ctx.lineTo(centerX + scale * 0.1, centerY - scale * 0.35);
            ctx.lineTo(centerX - scale * 0.1, centerY - scale * 0.6);
            ctx.lineTo(centerX - scale * 0.2, centerY - scale * 0.4);
            ctx.lineTo(centerX - scale * 0.3, centerY + scale * 0.1);
            ctx.closePath();
            ctx.fill();
        }

        function drawUnitSymbol(ctx, unit, x, y, radius, symbolColor) {
            const symbolDisplaySize = Math.max(1, radius);
            if (unit.type.symbol === 'M') {
                drawSword(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'A') {
                drawArrow(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'P') {
                drawPikemanSymbol(ctx, x, y, symbolDisplaySize, symbolColor);
            } else if (unit.type.symbol === 'H') {
                drawHorsemanSymbol(ctx, x, y, symbolDisplaySize, symbolColor);
            } else { 
                ctx.fillStyle = symbolColor;
                ctx.font = `bold ${symbolDisplaySize * 1.5}px 'Exo 2'`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(unit.type.symbol, x, y);
            }
        }

        function drawSingleUnit(ctx, unit, x, y, radius, overrideSymbolColor = null) {

    ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            ctx.fillStyle = unit.player === 1 ? currentDrawingColors.player1.primary : currentDrawingColors.player2.primary;
            ctx.fill();
            
            const healthBarVisualThickness = radius * 0.3;
            drawUnitHealthBar(ctx, x, y, radius, healthBarVisualThickness, unit.hp, unit.maxHp);
            
            ctx.beginPath();
            ctx.arc(x, y, radius, 0, 2 * Math.PI);
            
            let mainBorderColor;
            let mainBorderWidth = 3;

            if (unit.isCarryingFlag) {
                const enemyPlayer = unit.player === 1 ? 2 : 1;
                mainBorderColor = currentDrawingColors[`player${enemyPlayer}`].primary;
            } else if (gameState.selectedUnit && gameState.selectedUnit.id === unit.id) {
                mainBorderColor = '#FFD700';
            } else if (gameState.hoveredUnitId === unit.id && unit.player === gameState.currentPlayer) {
                mainBorderColor = '#ADD8E6'; 
                mainBorderWidth = 2.5;
            } else {
                mainBorderColor = unit.isFortified ? '#FFF' : '#000';
                mainBorderWidth = unit.isFortified ? 2 : 1.5;
            }
            
            ctx.strokeStyle = mainBorderColor;
            ctx.lineWidth = mainBorderWidth;
            ctx.stroke();

            const symbolColor = overrideSymbolColor || (unit.isFortified ? '#000' : '#FFF');
            const radiusForSymbol = radius - healthBarVisualThickness;
            drawUnitSymbol(ctx, unit, x, y, radiusForSymbol, symbolColor);
            drawUnitSymbol(ctx, unit, x, y, radiusForSymbol, symbolColor);
        }

        function drawUnits() {
            const animatedUnitIds = new Set(gameState.activeAnimations.map(a => (a.unit || a.attacker).id));
            const offsetDistance = UNIT_ON_EDGE_OFFSET;

            gameState.edges.forEach((edge) => {
                const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge' && (!gameState.isDragging || u.id !== gameState.draggingUnit.id));
                if (edgeUnitsOnly.length > 0) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    const p1_hex_center = axialToPixel(edge.q1, edge.r1); const p2_hex_center = axialToPixel(edge.q2, edge.r2);
                    let dx_centers = p2_hex_center.x - p1_hex_center.x; let dy_centers = p2_hex_center.y - p1_hex_center.y;
                    const len_centers = Math.sqrt(dx_centers*dx_centers + dy_centers*dy_centers) || 1;
                    let perpX = -dy_centers / len_centers; let perpY = dx_centers / len_centers;
                    
                    edgeUnitsOnly.forEach((unit, index) => {
                        if (animatedUnitIds.has(unit.id)) return;
                        let unitX = mid.x, unitY = mid.y;
                        if (edgeUnitsOnly.length > 1) {
                            const offsetSign = (index % 2 === 0) ? -1 : 1;
                            unitX += perpX * offsetDistance * offsetSign * (0.5); 
                            unitY += perpY * offsetDistance * offsetSign * (0.5);
                        }
                        drawSingleUnit(ctx, unit, unitX, unitY, UNIT_DRAW_SIZE_ON_EDGE);
                    });
                }
            });

            gameState.units.forEach(unit => {
                if (animatedUnitIds.has(unit.id)) return;
                if (unit.isFortified && unit.positionType === 'center' && (!gameState.isDragging || unit.id !== gameState.draggingUnit.id)) {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const {x, y} = axialToPixel(tile.q, tile.r);
                        drawSingleUnit(ctx, unit, x, y, FORTIFIED_UNIT_DRAW_SIZE);
                    }
                }
            });

            if (gameState.isDragging && gameState.draggingUnit) {
                const unit = gameState.draggingUnit;
                const unitX = gameState.dragUnitRenderX;
                const unitY = gameState.dragUnitRenderY;
                const fullRadius = (unit.isFortified ? FORTIFIED_UNIT_DRAW_SIZE : UNIT_DRAW_SIZE_ON_EDGE) * DRAG_SCALE_FACTOR;

                if (gameSettings.fancyVisualsEnabled) {
                    // --- FANCY VISUALS ON: Draw the shadow first ---
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                    ctx.shadowBlur = 25;
                    ctx.shadowOffsetX = 0;
                    ctx.shadowOffsetY = 0;
                    
                    const shadowCasterRadius = fullRadius * 0.8;
                    ctx.beginPath();
                    ctx.arc(unitX, unitY, shadowCasterRadius, 0, 2 * Math.PI);
                    ctx.fillStyle = '#000';
                    ctx.fill();

                    // Reset shadow properties before drawing the main unit
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;

                    // Then draw the unit on top
                    drawSingleUnit(ctx, unit, unitX, unitY, fullRadius);
                } else {
                    // --- FANCY VISUALS OFF: Just draw the unit, no shadow ---
                    drawSingleUnit(ctx, unit, unitX, unitY, fullRadius);
                }
            }
        }


function drawMovementHighlights() {
    const unitForHighlights = gameState.isDragging ? gameState.draggingUnit : gameState.selectedUnit;

    const isActionSelectionActive = gameState.currentActionState !== ACTION_STATES.IDLE && 
                                    gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED;

    if (!unitForHighlights || unitForHighlights.isFortified || (!gameState.isDragging && isActionSelectionActive)) {
        return;
    }
    
    // CRITICAL FIX: Do not show movement highlights for AI units.
    if (gameState.gameMode === 'singleplayer' && unitForHighlights.player !== gameState.playerSide) {
        return;
    }
            
            if (!gameState.isDragging) {
                if (unitForHighlights.currentMove < 1) return;
                if (unitForHighlights.hasPerformedMajorAction && !unitForHighlights.type.canMoveAfterAttack) {
                    return;
                }
            }

            gameState.currentReachableMoves.forEach((data, edgeKey) => {
                if (!gameState.isDragging && edgeKey === unitForHighlights.position) return;
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    ctx.beginPath(); ctx.arc(mid.x, mid.y, HEX_SIZE * 0.2, 0, 2 * Math.PI);
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; ctx.fill();
                    ctx.strokeStyle = 'rgba(0, 100, 0, 0.6)'; ctx.lineWidth = 2; ctx.stroke();
                }
            });
        }

        function drawDebugPath() {
            const currentTime = Date.now();

            if (gameState.potentialDebugPathToDraw && gameState.debugPathHoverStartTime !== null) {
                if (currentTime - gameState.debugPathHoverStartTime >= PATH_DRAW_HOVER_DELAY_MS) {
                    if (gameState.debugPathToDraw !== gameState.potentialDebugPathToDraw) {
                        gameState.debugPathToDraw = gameState.potentialDebugPathToDraw;
                        gameState.debugPathAnimationStartTime = currentTime; 
                        gameState.debugPathPauseStartTime = null;
                        gameState.lastDebugPathKey = gameState.debugPathToDraw ? gameState.debugPathToDraw.join('-') : null;
                    }
                }
            } else if (!gameState.potentialDebugPathToDraw && gameState.debugPathToDraw !== null) {
                gameState.debugPathToDraw = null;
                gameState.debugPathAnimationStartTime = null;
                gameState.debugPathPauseStartTime = null;
                gameState.lastDebugPathKey = null;
            }

            const pathEdgeKeysArray = gameState.debugPathToDraw;
            if (!pathEdgeKeysArray || pathEdgeKeysArray.length < 2) {
                return; 
            }
            
            let progress = 0;
            if (gameState.debugPathPauseStartTime !== null) { 
                if (currentTime - gameState.debugPathPauseStartTime >= PATH_DRAW_PAUSE_DURATION_MS) {
                    gameState.debugPathAnimationStartTime = currentTime; 
                    gameState.debugPathPauseStartTime = null;
                    progress = 0; 
                } else {
                    progress = 1.0; 
                }
            } else if (gameState.debugPathAnimationStartTime !== null) { 
                const elapsedTime = currentTime - gameState.debugPathAnimationStartTime;
                progress = elapsedTime / PATH_DRAW_ANIMATION_DURATION_MS;

                if (progress >= 1.0) {
                    progress = 1.0;
                    if (gameState.lastDebugPathKey === pathEdgeKeysArray.join('-')) {
                        gameState.debugPathPauseStartTime = currentTime; 
                    }
                }
            } else {
                return; 
            }
            
            progress = Math.min(1, progress); 


            ctx.save();
            ctx.strokeStyle = '#E6C410'; 
            ctx.lineWidth = 5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const points = pathEdgeKeysArray.map(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (!edge) return null;
                return getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            }).filter(p => p !== null);

            if (points.length < 2) { ctx.restore(); return; }

            let totalPathLength = 0;
            for (let i = 0; i < points.length - 1; i++) {
                totalPathLength += pointDistance(points[i], points[i+1]);
            }
            if (totalPathLength === 0) { ctx.restore(); return; }

            const drawableLength = totalPathLength * progress;
            let lengthDrawn = 0;

            ctx.beginPath();
            ctx.moveTo(points[0].x, points[0].y);

            for (let i = 0; i < points.length - 1; i++) {
                const p1 = points[i];
                const p2 = points[i+1];
                const segmentLength = pointDistance(p1, p2);

                if (lengthDrawn + segmentLength <= drawableLength) {
                    ctx.lineTo(p2.x, p2.y);
                    lengthDrawn += segmentLength;
                } else {
                    const remainingLengthToDraw = drawableLength - lengthDrawn;
                    if (remainingLengthToDraw > 0 && segmentLength > 0) {
                        const fraction = remainingLengthToDraw / segmentLength;
                        const endX = p1.x + (p2.x - p1.x) * fraction;
                        const endY = p1.y + (p2.y - p1.y) * fraction;
                        ctx.lineTo(endX, endY);
                    }
                    break; 
                }
            }
            ctx.stroke();
            ctx.restore();
        }

        function drawDebugAttackRangeHighlights() {
            if (gameState.currentActionState !== ACTION_STATES.SELECTING_ATTACK_TARGET) return;
            if (!gameState.debugAttackRangeHighlights || gameState.debugAttackRangeHighlights.length === 0) return;

            const currentTime = Date.now();
            const pulseProgress = (currentTime % PULSE_DURATION_MS) / PULSE_DURATION_MS; 
            const minOpacity = 0.0;
            const maxOpacity = 0.9;
            const opacity = minOpacity + (Math.sin(pulseProgress * 2 * Math.PI) + 1) / 2 * (maxOpacity - minOpacity);
            
            ctx.save();
            ctx.strokeStyle = `rgba(255, 140, 0, ${opacity})`; 
            ctx.lineWidth = 5; 

            gameState.debugAttackRangeHighlights.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (!edge) return;

                const p1_center = axialToPixel(edge.q1, edge.r1);
                const p2_center = axialToPixel(edge.q2, edge.r2);

                const edgeMidX = (p1_center.x + p2_center.x) / 2;
                const edgeMidY = (p1_center.y + p2_center.y) / 2;

                let dx_centers = p2_center.x - p1_center.x;
                let dy_centers = p2_center.y - p1_center.y;

                let perp_dx = -dy_centers;
                let perp_dy = dx_centers;

                const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);
                if (len_perp_vec === 0) return; 

                const scale = (HEX_SIZE / 2) * 0.95; 
                perp_dx = (perp_dx / len_perp_vec) * scale;
                perp_dy = (perp_dy / len_perp_vec) * scale;

                ctx.beginPath();
                ctx.moveTo(edgeMidX + perp_dx, edgeMidY + perp_dy);
                ctx.lineTo(edgeMidX - perp_dx, edgeMidY - perp_dy);
                ctx.stroke();
            });
            ctx.restore();
        }

function triggerDamageVisual(targetUnit, attackStatus = 'normal') {
    // Get the unit's screen position and size for the effect
    let targetX, targetY, targetRadius;
    if (targetUnit.isFortified) {
        const tile = gameState.tiles.get(targetUnit.position);
        if (tile) {
            const center = axialToPixel(tile.q, tile.r);
            targetX = center.x;
            targetY = center.y;
            targetRadius = FORTIFIED_UNIT_DRAW_SIZE;
        }
    } else {
        const edge = gameState.edges.get(targetUnit.position);
        if (edge) {
            const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
            targetX = mid.x;
            targetY = mid.y;
            targetRadius = UNIT_DRAW_SIZE_ON_EDGE;
            // Adjust for stacked units
            const unitsOnEdge = edge.units.filter(u => u.positionType === 'edge');
            const unitIndex = unitsOnEdge.findIndex(u => u.id === targetUnit.id);
            if(unitsOnEdge.length > 1 && unitIndex !== -1) {
                const offsetSign = (unitIndex % 2 === 0) ? -1 : 1;
                const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                let dx = p2.x - p1.x, dy = p2.y - p1.y; const len = Math.sqrt(dx*dx + dy*dy) || 1;
                let perpX = -dy / len, perpY = dx / len;
                targetX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                targetY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
            }
        }
    }

    if (targetX !== undefined) {
        // --- DAMAGE RING LOGIC (Unchanged) ---
        const baseEffect = {
            type: 'damage_ring',
            x: targetX, y: targetY,
            unitRadius: targetRadius,
            startTime: Date.now(),
            duration: 500
        };

        if (attackStatus === 'disadvantage') {
            baseEffect.subType = 'disadvantage';
            gameState.visualEffects.push(baseEffect);
        } else if (attackStatus === 'advantage') {
            const effect1 = { ...baseEffect, subType: 'advantage' };
            const effect2 = { ...baseEffect, subType: 'advantage', startTime: Date.now() + 250 };
            gameState.visualEffects.push(effect1, effect2);
        } else {
            baseEffect.subType = 'normal';
            gameState.visualEffects.push(baseEffect);
        }

        // --- UPDATED UNIT FLASH LOGIC ---
        const flashEffect = {
            type: 'unit_flash',
            targetUnitId: targetUnit.id,
            startTime: Date.now(),
            flashCount: 1,
            color: 'rgba(255, 0, 0, 0.5)', // Default: Red
            duration: 300, // Shorter duration for single flashes
        };

        if (attackStatus === 'advantage') {
            flashEffect.flashCount = 2;
            flashEffect.duration = 600; // Longer duration for two flashes
        } else if (attackStatus === 'disadvantage') {
            flashEffect.color = 'rgba(255, 165, 0, 0.5)'; // Orange color
        }
        // For 'normal', the default red, single-flash settings are correct.

        gameState.visualEffects.push(flashEffect);
    }
}

function drawVisualEffects() {
    if (gameState.visualEffects.length === 0) return;

    const currentTime = Date.now();
    const effectsToRemove = [];
    
    ctx.save();
    gameState.visualEffects.forEach((effect, index) => {
        const elapsedTime = currentTime - effect.startTime;
        const progress = elapsedTime / effect.duration;

        if (progress >= 1) {
            effectsToRemove.push(index);
            if (effect.onComplete) {
                effect.onComplete();
            }
            return;
        }

        if (effect.type === 'damage_ring') {
            const startRadius = effect.unitRadius;
            const endRadius = startRadius * 1.8;
            
            const currentRadius = startRadius + (endRadius - startRadius) * progress;
            const opacity = 1.0 - progress;

            ctx.beginPath();
            ctx.arc(effect.x, effect.y, currentRadius, 0, 2 * Math.PI);

            let ringColor = `rgba(255, 50, 50, ${opacity})`;
            if (effect.subType === 'disadvantage') {
                ringColor = `rgba(255, 165, 0, ${opacity})`;
            }
            
            ctx.strokeStyle = ringColor;
            ctx.lineWidth = 3 + (4 * (1 - progress));
            ctx.stroke();
        } else if (effect.type === 'shield_ring') {
            const startRadius = effect.unitRadius;
            const endRadius = startRadius * 2.0;
            
            const currentRadius = startRadius + (endRadius - startRadius) * progress;
            const opacity = 1.0 - progress;

            ctx.beginPath();
            ctx.arc(effect.x, effect.y, currentRadius, 0, 2 * Math.PI);
            ctx.strokeStyle = `rgba(48, 196, 196, ${opacity})`; 
            ctx.lineWidth = 4 + (3 * (1 - progress));
            ctx.stroke();
        } else if (effect.type === 'unit_flash') {
            const unit = gameState.units.find(u => u.id === effect.targetUnitId);
            if (!unit) return;

            let isVisible = false;
            if (effect.flashCount === 2) {
                isVisible = (progress >= 0 && progress < 0.15) || (progress >= 0.25 && progress < 0.40);
            } else {
                isVisible = (progress >= 0 && progress < 0.40);
            }

            if (isVisible) {
                let unitX, unitY, unitRadius;
                if (unit.isFortified) {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const center = axialToPixel(tile.q, tile.r);
                        unitX = center.x;
                        unitY = center.y;
                        unitRadius = FORTIFIED_UNIT_DRAW_SIZE;
                    }
                } else {
                    const edge = gameState.edges.get(unit.position);
                    if (edge) {
                        const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                        unitX = mid.x;
                        unitY = mid.y;
                        unitRadius = UNIT_DRAW_SIZE_ON_EDGE;
                        const unitsOnEdge = edge.units.filter(u => u.positionType === 'edge');
                        const unitIndex = unitsOnEdge.findIndex(u => u.id === unit.id);
                        if (unitsOnEdge.length > 1 && unitIndex !== -1) {
                            const offsetSign = (unitIndex % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edge.q1, edge.r1);
                            const p2 = axialToPixel(edge.q2, edge.r2);
                            let dx = p2.x - p1.x, dy = p2.y - p1.y;
                            const len = Math.sqrt(dx * dx + dy * dy) || 1;
                            let perpX = -dy / len, perpY = dx / len;
                            unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
                            unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * 0.5;
                        }
                    }
                }
                
                if (unitX !== undefined) {
                    ctx.fillStyle = effect.color;
                    ctx.beginPath();
                    ctx.arc(unitX, unitY, unitRadius, 0, 2 * Math.PI);
                    ctx.fill();
                }
            }
        } else if (effect.type === 'flag_capture_burst') {
            const easedProgress = 1 - Math.pow(1 - progress, 3); // A strong ease-out for the expansion

            // The maximum length the line will grow to, using your adjusted factor.
            const maxLineLength = HEX_SIZE * 0.4; 
            
            // The line's length at the current moment in the animation.
            const currentLineLength = maxLineLength * easedProgress;

            // Overall effect opacity (fades out the whole effect over time).
            const globalOpacity = 1.0 - progress;

            const baseColor = effect.player === 1 ? currentDrawingColors.player1.accent : currentDrawingColors.player2.accent;
            
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI / 3) * i; 
                
                // --- THE FIX: Anchor the start and only animate the end ---

                // The START of the line is now FIXED at the unit's border.
                const startRadius = UNIT_DRAW_SIZE_ON_EDGE * 1.1;
                const startX = effect.x + Math.cos(angle) * startRadius;
                const startY = effect.y + Math.sin(angle) * startRadius;
                
                // The END of the line moves outwards from the start point.
                const endX = startX + Math.cos(angle) * currentLineLength;
                const endY = startY + Math.sin(angle) * currentLineLength;
                // --- END OF FIX ---

                // The gradient should fade from opaque at the base to transparent at the tip.
                const gradient = ctx.createLinearGradient(startX, startY, endX, endY);
                gradient.addColorStop(0, hexToRgba(baseColor, globalOpacity));
                gradient.addColorStop(1, hexToRgba(baseColor, 0));

                ctx.strokeStyle = gradient;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
            }
        }
    });
    ctx.restore();

    for (let i = effectsToRemove.length - 1; i >= 0; i--) {
        gameState.visualEffects.splice(effectsToRemove[i], 1);
    }
}

function animateUnitAlongPath(unit, path, duration) {
    const animation = {
        unit: unit,
        path: path,
        startTime: Date.now(),
        duration: duration,
        isFinished: false,
        onComplete: null,
    };

    // Remove the unit from its starting edge immediately so it doesn't get drawn there.
const startEdge = gameState.edges.get(unit.position);
if(startEdge) {
    startEdge.units = startEdge.units.filter(u => u.id !== unit.id);
}
    // The unit is now "in animation" and not on any specific edge or tile.
    unit.positionType = 'animating';
    
    gameState.activeAnimations.push(animation);
    return animation;
}

function drawAnimations() {
    if (gameState.activeAnimations.length === 0) return; 
    
    const stillAnimating = [];
    const currentTime = Date.now();

    gameState.activeAnimations.forEach(anim => {
        const elapsedTime = currentTime - anim.startTime;
        let progress = elapsedTime / anim.duration;

        if (progress >= 1) {
            if (anim.onComplete) anim.onComplete();
            return;
        }

        const unitToAnimate = anim.unit || anim.attacker;
        
        if (anim.type === 'attack_lunge' || anim.type === 'attack_projectile') {
            // ... (All attack animation logic remains unchanged) ...
            const startPos = getUnitScreenPosition(unitToAnimate);
            if (!startPos) { stillAnimating.push(anim); return; }
            const drawRadius = unitToAnimate.isFortified ? FORTIFIED_UNIT_DRAW_SIZE : UNIT_DRAW_SIZE_ON_EDGE;
            if (anim.type === 'attack_lunge') {
                const targetPos = getUnitScreenPosition(anim.target);
                if (!targetPos) { stillAnimating.push(anim); return; }
                let currentPos = { x: startPos.x, y: startPos.y };
                const lungeDistanceFactor = 0.5; const windupDistanceFactor = -0.2;
                if (progress < 0.25) {
                    const phaseProgress = progress / 0.25;
                    currentPos.x = lerp(startPos.x, targetPos.x, phaseProgress * windupDistanceFactor);
                    currentPos.y = lerp(startPos.y, targetPos.y, phaseProgress * windupDistanceFactor);
                } else if (progress < 0.5) {
                    const phaseProgress = (progress - 0.25) / 0.25;
                    const windupX = lerp(startPos.x, targetPos.x, windupDistanceFactor); const windupY = lerp(startPos.y, targetPos.y, windupDistanceFactor);
                    const peakX = lerp(startPos.x, targetPos.x, lungeDistanceFactor); const peakY = lerp(startPos.y, targetPos.y, lungeDistanceFactor);
                    currentPos.x = lerp(windupX, peakX, phaseProgress); currentPos.y = lerp(windupY, peakY, phaseProgress);
                } else {
                    const phaseProgress = (progress - 0.5) / 0.5;
                    const peakX = lerp(startPos.x, targetPos.x, lungeDistanceFactor); const peakY = lerp(startPos.y, targetPos.y, lungeDistanceFactor);
                    currentPos.x = lerp(peakX, startPos.x, phaseProgress); currentPos.y = lerp(peakY, startPos.y, phaseProgress);
                }
                drawSingleUnit(ctx, unitToAnimate, currentPos.x, currentPos.y, drawRadius);
            } else { 
                const totalPreShotDuration = anim.preShotDuration.draw + anim.preShotDuration.hold;
                if (elapsedTime < totalPreShotDuration) {
                    const recoilFactor = -0.1; const someTargetPos = getUnitScreenPosition(anim.targets[0]);
                    if (!someTargetPos) { stillAnimating.push(anim); return; }
                    const recoilX = lerp(startPos.x, someTargetPos.x, recoilFactor); const recoilY = lerp(startPos.y, someTargetPos.y, recoilFactor);
                    if (elapsedTime < anim.preShotDuration.draw) {
                        const phaseProgress = elapsedTime / anim.preShotDuration.draw;
                        const currentX = lerp(startPos.x, recoilX, phaseProgress); const currentY = lerp(startPos.y, recoilY, phaseProgress);
                        drawSingleUnit(ctx, unitToAnimate, currentX, currentY, drawRadius);
                    } else {
                        drawSingleUnit(ctx, unitToAnimate, recoilX, recoilY, drawRadius);
                    }
                } else {
                    drawSingleUnit(ctx, unitToAnimate, startPos.x, startPos.y, drawRadius);
                    const travelElapsedTime = elapsedTime - totalPreShotDuration; const travelProgress = travelElapsedTime / anim.travelDuration;
                    anim.targets.forEach(targetUnit => {
                        const targetPos = getUnitScreenPosition(targetUnit); if (!targetPos) return;
                        const projectileX = lerp(startPos.x, targetPos.x, travelProgress); const projectileY = lerp(startPos.y, targetPos.y, travelProgress);
                        ctx.beginPath(); ctx.moveTo(projectileX, projectileY);
                        const dx = targetPos.x - startPos.x; const dy = targetPos.y - startPos.y;
                        const len = Math.sqrt(dx*dx + dy*dy) || 1;
                        const tailX = projectileX - (dx/len) * 15; const tailY = projectileY - (dy/len) * 15;
                        ctx.lineTo(tailX, tailY);
                        ctx.strokeStyle = '#90A0A0'; ctx.lineWidth = 3; ctx.stroke();
                    });
                }
            }
        } else if (anim.type === 'fortify' || anim.type === 'unfortify') {
             const startPos = getUnitScreenPosition(unitToAnimate);
             if (!startPos && anim.type === 'fortify') { stillAnimating.push(anim); return; }
            if (anim.type === 'fortify') {
                 const [q, r] = anim.targetTileKey.split(',').map(Number);
                 const endPos = axialToPixel(q, r);
                 const fortifyDrawRadius = FORTIFIED_UNIT_DRAW_SIZE;
                 const travelPhaseDuration = 0.4; 
                 if (progress < travelPhaseDuration) {
                     let travelProgress = progress / travelPhaseDuration;
                     const easedTravelProgress = 1 - Math.pow(1 - travelProgress, 3);
                     const currentX = lerp(startPos.x, endPos.x, easedTravelProgress);
                     const currentY = lerp(startPos.y, endPos.y, easedTravelProgress);
                     drawSingleUnit(ctx, anim.unit, currentX, currentY, fortifyDrawRadius);
                 } 
                 else {
                     const newSymbolColor = '#000';
                     drawSingleUnit(ctx, anim.unit, endPos.x, endPos.y, fortifyDrawRadius, newSymbolColor);
                     let ringPhaseProgress = (progress - travelPhaseDuration) / (1 - travelPhaseDuration);
                     const easedRingProgress = Math.pow(ringPhaseProgress, 2);
                     const ringOpacity = easedRingProgress;
                     const ringColor = anim.unit.player === 1 ? `rgba(91, 148, 255, ${ringOpacity})` : `rgba(255, 99, 132, ${ringOpacity})`;
                     const currentHexSize = HEX_SIZE * easedRingProgress;
                     ctx.strokeStyle = ringColor;
                     ctx.lineWidth = 4;
                     ctx.beginPath();
                     for (let i = 0; i < 6; i++) {
                         const angle = Math.PI / 180 * (60 * i - 30);
                         const vx = endPos.x + currentHexSize * Math.cos(angle);
                         const vy = endPos.y + currentHexSize * Math.sin(angle);
                         if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                     }
                     ctx.closePath();
                     ctx.stroke();
                 }
            } else { // unfortify
                 const collapsePhaseDuration = 0.5;
                 const [q, r] = anim.startTileKey.split(',').map(Number);
                 const unfortifyStartPos = axialToPixel(q, r);
                if (progress < collapsePhaseDuration) {
                    drawSingleUnit(ctx, anim.unit, unfortifyStartPos.x, unfortifyStartPos.y, FORTIFIED_UNIT_DRAW_SIZE, '#000');
                    let phaseProgress = progress / collapsePhaseDuration;
                    const easedProgress = Math.pow(phaseProgress, 2);
                    const ringOpacity = 1.0 - easedProgress;
                    const ringColor = anim.unit.player === 1 ? `rgba(91, 148, 255, ${ringOpacity})` : `rgba(255, 99, 132, ${ringOpacity})`;
                    const currentHexSize = HEX_SIZE * (1.0 - easedProgress);
                    ctx.strokeStyle = ringColor;
                    ctx.lineWidth = 4;
                    ctx.beginPath();
                    for (let i = 0; i < 6; i++) {
                        const angle = Math.PI / 180 * (60 * i - 30);
                        const vx = unfortifyStartPos.x + currentHexSize * Math.cos(angle);
                        const vy = unfortifyStartPos.y + currentHexSize * Math.sin(angle);
                        if (i === 0) ctx.moveTo(vx, vy); else ctx.lineTo(vx, vy);
                    }
                    ctx.closePath();
                    ctx.stroke();
                } else {
                    const [endH1, endH2] = parseEdgeKey(anim.targetEdgeKey);
                    const endPos = getEdgeMidpoint(endH1.q, endH1.r, endH2.q, endH2.r);
                    let phaseProgress = (progress - collapsePhaseDuration) / (1 - collapsePhaseDuration);
                    const easedProgress = 1 - Math.pow(1 - phaseProgress, 3);
                    const currentX = lerp(unfortifyStartPos.x, endPos.x, easedProgress);
                    const currentY = lerp(unfortifyStartPos.y, endPos.y, easedProgress);
                    drawSingleUnit(ctx, anim.unit, currentX, currentY, UNIT_DRAW_SIZE_ON_EDGE, '#FFF');
                }
            }
        } else if (anim.type === 'build_bridge') {
            const builder = anim.unit;
            const startPos = getUnitScreenPosition(builder);
            const targetEdge = gameState.edges.get(anim.targetEdgeKey);

            if (!startPos || !targetEdge) { stillAnimating.push(anim); return; }

            const targetEdgePos = getEdgeMidpoint(targetEdge.q1, targetEdge.r1, targetEdge.q2, targetEdge.r2);
            
            // Define the "build" position near the edge
            const buildPos = {
                x: lerp(startPos.x, targetEdgePos.x, 0.4), // Move 40% of the way to the edge
                y: lerp(startPos.y, targetEdgePos.y, 0.4)
            };

            let currentPos = { x: 0, y: 0 };
            
            // --- Phase 1: Move FORWARD, fade in main body (0 -> 0.25) ---
            if (progress < 0.25) {
                const phaseProgress = progress / 0.25;
                currentPos.x = lerp(startPos.x, buildPos.x, phaseProgress);
                currentPos.y = lerp(startPos.y, buildPos.y, phaseProgress);
                
                ctx.globalAlpha = phaseProgress;
                drawBridge(targetEdge, '#8B4513'); // Main body only
                ctx.globalAlpha = 1.0;
            }
            // --- Phase 2: Move BACK (0.25 -> 0.5) ---
            else if (progress < 0.5) {
                const phaseProgress = (progress - 0.25) / 0.25;
                currentPos.x = lerp(buildPos.x, startPos.x, phaseProgress);
                currentPos.y = lerp(buildPos.y, startPos.y, phaseProgress);
                
                drawBridge(targetEdge, '#8B4513'); // Main body is now solid
            }
            // --- Phase 3: Move FORWARD again, fade in planks (0.5 -> 0.75) ---
            else if (progress < 0.75) {
                const phaseProgress = (progress - 0.5) / 0.25;
                currentPos.x = lerp(startPos.x, buildPos.x, phaseProgress);
                currentPos.y = lerp(startPos.y, buildPos.y, phaseProgress);

                drawBridge(targetEdge, '#8B4513'); // Draw solid main body first
                ctx.globalAlpha = phaseProgress;
                drawBridge(targetEdge, 'transparent'); // Draw planks on top with fade
                ctx.globalAlpha = 1.0;
            }
            // --- Phase 4: Move BACK again (0.75 -> 1.0) ---
            else {
                const phaseProgress = (progress - 0.75) / 0.25;
                currentPos.x = lerp(buildPos.x, startPos.x, phaseProgress);
                currentPos.y = lerp(buildPos.y, startPos.y, phaseProgress);
                
                drawBridge(targetEdge); // Draw full, solid bridge
            }
            
            // Draw the builder at its calculated current position for this frame
            drawSingleUnit(ctx, builder, currentPos.x, currentPos.y, UNIT_DRAW_SIZE_ON_EDGE);
        }
        
        stillAnimating.push(anim);
    });

    gameState.activeAnimations = stillAnimating;
}

        function gameLoop() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // --- Handle smooth color transition for canvas elements ---
            if (gameState.colorTransition.active) {
                const elapsedTime = Date.now() - gameState.colorTransition.startTime;
                const progress = Math.min(elapsedTime / COLOR_TRANSITION_DURATION_MS, 1);

                // Animate each player's primary, SECONDARY, AND accent colors independently
                currentDrawingColors.player1.primary = lerpColor(gameState.colorTransition.from.player1.primary, gameState.colorTransition.to.player1.primary, progress);
                currentDrawingColors.player2.primary = lerpColor(gameState.colorTransition.from.player2.primary, gameState.colorTransition.to.player2.primary, progress);
                currentDrawingColors.player1.secondary = lerpColor(gameState.colorTransition.from.player1.secondary, gameState.colorTransition.to.player1.secondary, progress); 
                currentDrawingColors.player2.secondary = lerpColor(gameState.colorTransition.from.player2.secondary, gameState.colorTransition.to.player2.secondary, progress); 
                currentDrawingColors.player1.accent = lerpColor(gameState.colorTransition.from.player1.accent, gameState.colorTransition.to.player1.accent, progress);
                currentDrawingColors.player2.accent = lerpColor(gameState.colorTransition.from.player2.accent, gameState.colorTransition.to.player2.accent, progress);

                if (progress >= 1) {
                    gameState.colorTransition.active = false;
                }
            } else {
                // Ensure drawing colors are synced if no transition is active
                currentDrawingColors.player1.primary = TEAM_COLORS.player1.primary;
                currentDrawingColors.player2.primary = TEAM_COLORS.player2.primary;
                currentDrawingColors.player1.secondary = TEAM_COLORS.player1.secondary;
                currentDrawingColors.player2.secondary = TEAM_COLORS.player2.secondary;
                currentDrawingColors.player1.accent = TEAM_COLORS.player1.accent;
                currentDrawingColors.player2.accent = TEAM_COLORS.player2.accent;
            }
            gameState.tiles.forEach(tile => drawHexFill(tile.q, tile.r, tile.type));
            drawHexEdgesAndBoundaries();
            drawFortificationOutlines();
            drawContestedEdgeIndicator();
            drawFlags();
            
            drawSupplyLines();
            
            drawDebugAttackRangeHighlights() 

            if (!gameState.isDragging) {
                switch(gameState.currentActionState) {
                    case ACTION_STATES.SELECTING_FORTIFY_TILE:
                        drawActionSelectionHighlights(gameState.validFortifyTargetTileKeys, 'fortify');
                        break;
                    case ACTION_STATES.SELECTING_UNFORTIFY_EDGE:
                        drawActionSelectionHighlights(gameState.validUnfortifyTargetEdgeKeys, 'unfortify');
                        break;
                    case ACTION_STATES.SELECTING_BRIDGE_EDGE:
                        drawActionSelectionHighlights(gameState.validBridgeTargetEdgeKeys, 'bridge');
                        break;
                    case ACTION_STATES.SELECTING_ATTACK_TARGET:
                        const currentAttackTargets = gameState.selectedUnit?.type.attackType === 'melee' 
                            ? gameState.validMeleeAttackTargets 
                            : gameState.validArcherAttackTargets;
                        drawBridgeAttackHighlightsOnly(currentAttackTargets); 
                        break;
                }
            }
            
drawDebugPath();
drawAnimations();
drawBridges();
drawMovementHighlights();
drawUnits(); // Draws stationary units
drawVisualEffects();

 if (!gameState.isDragging && gameState.currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET) {
                 const currentAttackTargets = gameState.selectedUnit?.type.attackType === 'melee'
                    ? gameState.validMeleeAttackTargets 
                    : gameState.validArcherAttackTargets;
                 drawUnitAttackHighlightsOnly(currentAttackTargets); 
             }
            requestAnimationFrame(gameLoop);
        }

            // Function to set CSS Variables from the TEAM_COLORS object
            function updateCssVariables() {
                const root = document.documentElement;
                root.style.setProperty('--p1-color-secondary', TEAM_COLORS.player1.secondary);
                root.style.setProperty('--p2-color-secondary', TEAM_COLORS.player2.secondary);
            }


        // --- UI Update Functions ---
        function updateTurnDisplay() {
            if (ui.turnDisplay) {
                ui.turnDisplay.textContent = `Player ${gameState.currentPlayer}'s Turn`;
            } else {
                console.error('[UI Update] CRITICAL: ui.turnDisplay element is null or undefined!');
            }

            // Update canvas outline color based on the current player
            if (gameState.currentPlayer === 1) {
                canvas.style.outlineColor = TEAM_COLORS.player1.secondary;
            } else {
                canvas.style.outlineColor = TEAM_COLORS.player2.secondary;
            }
        }

        function updateGlobalTurnDisplay() {
            if (ui.globalTurnCounterDisplay) {
                ui.globalTurnCounterDisplay.textContent = `Turn: ${gameState.globalTurnNumber}`;
            }
        }

        function updateActionButtonState(button, baseText, cancelText, isSelecting, canPerformCondition, additionalDisabledCondition = false) {
            button.textContent = isSelecting ? cancelText : baseText;
            button.classList.toggle('selecting', isSelecting);
            if (isSelecting) {
                button.disabled = false;
            } else {
                button.disabled = !canPerformCondition || additionalDisabledCondition;
            }
        }
        
        function updateSelectedUnitInfoPanel() {
            const { selectedUnit, currentActionState } = gameState;

            if (currentActionState !== ACTION_STATES.SELECTING_ATTACK_TARGET) {
                gameState.debugAttackRangeHighlights = [];
            }
            
            if (selectedUnit && !gameState.isDragging) {
                ui.selectedUnitInfoContainer.style.display = 'block';
                ui.actionInfoContainer.style.display = 'none';
                ui.actionsPanel.style.display = 'flex';
                ui.unitName.textContent = `${selectedUnit.type.name} (P${selectedUnit.player})`;
                ui.unitHP.textContent = selectedUnit.hp; ui.unitMaxHP.textContent = selectedUnit.maxHp;
                ui.unitMovement.textContent = Math.floor(selectedUnit.currentMove);
                ui.unitPosition.textContent = selectedUnit.positionType === 'edge' ? `Edge (${selectedUnit.position.substring(0,7)}...)` : `Center (${selectedUnit.position})`;
                let statusText = "Ready";
                if (selectedUnit.isCarryingFlag) statusText = "Carrying Flag";
                else if (selectedUnit.hp > selectedUnit.maxHp) statusText = "Shielded";
                else if (selectedUnit.isFortified) statusText = `Fortified on ${selectedUnit.fortifiedTileKey}`;
                else if (selectedUnit.hasPerformedMajorAction) statusText = "Action Taken";
                else if (selectedUnit.currentMove < 1) statusText = "No MP Left";
                ui.unitStatus.textContent = statusText;

                const canPerformMajorAction = !selectedUnit.hasPerformedMajorAction;
                const canAttack = selectedUnit.currentMove >= ATTACK_COST && !selectedUnit.hasPerformedMajorAction;

                if (selectedUnit.type.canFortify) {
                    ui.fortifyUnfortifyButton.style.display = 'inline-block';
                    const isSelectingFortify = currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE;
                    const isSelectingUnfortify = currentActionState === ACTION_STATES.SELECTING_UNFORTIFY_EDGE;
                    
                    let fortifyDisabledCondition = false;
                    if (selectedUnit.isFortified) { // Unfortify logic
                        if (!isSelectingUnfortify) {
                           fortifyDisabledCondition = getPotentialUnfortifyTargets(selectedUnit).length === 0;
                        }
                        updateActionButtonState(ui.fortifyUnfortifyButton, "Unfortify", "Cancel Unfortify", isSelectingUnfortify, canPerformMajorAction, fortifyDisabledCondition);
                    } else { // Fortify logic
                        if (!isSelectingFortify) {
                            const edgeCoords = parseEdgeKey(selectedUnit.position);
                            if (edgeCoords && edgeCoords.length === 2 && !isNaN(edgeCoords[0].q)) {
                                const tile1 = gameState.tiles.get(getTileKey(edgeCoords[0].q, edgeCoords[0].r));
                                const tile2 = gameState.tiles.get(getTileKey(edgeCoords[1].q, edgeCoords[1].r));
                                const canFortifyTile1 = tile1 && tile1.type.canFortify && tile1.fortifiedByPlayer === null;
                                const canFortifyTile2 = tile2 && tile2.type.canFortify && tile2.fortifiedByPlayer === null;
                                fortifyDisabledCondition = !(canFortifyTile1 || canFortifyTile2) || selectedUnit.positionType === 'center';
                            } else {
                                fortifyDisabledCondition = true;
                            }
                        }
                        updateActionButtonState(ui.fortifyUnfortifyButton, "Fortify", "Cancel Fortify", isSelectingFortify, canPerformMajorAction, fortifyDisabledCondition);
                    }
                } else {
                    ui.fortifyUnfortifyButton.style.display = 'none';
                }

                ui.buildBridgeButton.style.display = selectedUnit.type.canBuildBridge ? 'inline-block' : 'none';
                if (selectedUnit.type.canBuildBridge) {
                    const isSelectingBridge = currentActionState === ACTION_STATES.SELECTING_BRIDGE_EDGE;
                    let bridgeDisabledCondition = selectedUnit.isFortified;
                    if (!isSelectingBridge && !bridgeDisabledCondition) {
                        bridgeDisabledCondition = getPotentialBridgeTargets(selectedUnit).length === 0;
                    }
                    updateActionButtonState(ui.buildBridgeButton, "Build Bridge", "Cancel Bridge", isSelectingBridge, canPerformMajorAction, bridgeDisabledCondition);
                }

                ui.attackButton.style.display = selectedUnit.type.attackType ? 'inline-block' : 'none';
                if (selectedUnit.type.attackType) {
                    const isSelectingAttack = currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET;
                    let attackDisabledCondition = false;
                    if (!isSelectingAttack) {
                        if (selectedUnit.type.attackType === 'melee') {
                            attackDisabledCondition = getValidMeleeAttackTargets(selectedUnit).length === 0;
                        } else if (selectedUnit.type.attackType === 'ranged') {
                            attackDisabledCondition = getValidArcherAttackTargets(selectedUnit).length === 0;
                        }
                    }
                    updateActionButtonState(ui.attackButton, "Attack", "Cancel Attack", isSelectingAttack, canAttack, attackDisabledCondition);
                }
            } else if (!gameState.isDragging) {
                ui.selectedUnitInfoContainer.style.display = 'none';
                ui.actionInfoContainer.style.display = 'block';
                ui.actionsPanel.style.display = 'none';
                resetActionSelectionStates();
                ui.fortifyUnfortifyButton.textContent = "Fortify"; ui.fortifyUnfortifyButton.classList.remove('selecting');
                ui.buildBridgeButton.textContent = "Build Bridge"; ui.buildBridgeButton.classList.remove('selecting');
                ui.attackButton.textContent = "Attack"; ui.attackButton.classList.remove('selecting');
            }
        }

        function showRespawnModal(player) {
            const overlay = document.getElementById('respawnModalOverlay');
            const content = document.getElementById('respawnModalContent');
            if (!overlay || !content) return;

            // --- NEW: Check for total army size limit ---
            const currentUnitCount = gameState.units.filter(u => u.player === player).length;
            if (currentUnitCount >= MAX_UNITS_PER_PLAYER) {
                logAction(`P${player} has reached the maximum army size! Cannot reinforce.`, player);
                // Reset the timer for the unit in the queue so it can try again next turn.
                const queueKey = `player${player}`;
                if (gameState.respawnQueue[queueKey][0]) {
                    gameState.respawnQueue[queueKey][0].turnsRemaining = 1;
                }
                updateRespawnQueueDisplay(); // Show the reset timer
                return; // Exit without showing the modal
            }

            // --- Original Logic (now runs only if army size is okay) ---
            content.className = `modal-content modal-p${player}`;

            const counts = gameState.unitCounts[`player${player}`];
            
            const meleeButton = document.getElementById('respawnMelee');
            meleeButton.disabled = counts.Melee >= UNIT_CAPS.Melee;
            meleeButton.innerHTML = UNIT_SVGS.MELEE;

            const archerButton = document.getElementById('respawnArcher');
            archerButton.disabled = counts.Archer >= UNIT_CAPS.Archer;
            archerButton.innerHTML = UNIT_SVGS.ARCHER;
            
            const pikemanButton = document.getElementById('respawnPikeman');
            pikemanButton.disabled = counts.Pikeman >= UNIT_CAPS.Pikeman;
            pikemanButton.innerHTML = UNIT_SVGS.PIKEMAN;

            const horsemanButton = document.getElementById('respawnHorseman');
            horsemanButton.disabled = counts.Horseman >= UNIT_CAPS.Horseman;
            horsemanButton.innerHTML = UNIT_SVGS.HORSEMAN;

            overlay.style.display = 'flex';
            setTimeout(() => overlay.classList.add('modal-visible'), 10);
        }

        function hideRespawnModal() {
            const overlay = document.getElementById('respawnModalOverlay');
            if (!overlay) return;
            
            overlay.classList.remove('modal-visible');
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 300);
        }

        function updateRespawnQueueDisplay() {
            const container = document.getElementById('reinforcementsContainer');
            const listEl = document.getElementById('reinforcementsList');

            if (!container || !listEl) return;

            listEl.innerHTML = ''; 

            const p1Queue = gameState.respawnQueue.player1.map(item => ({ ...item, player: 1 }));
            const p2Queue = gameState.respawnQueue.player2.map(item => ({ ...item, player: 2 }));
            const combinedQueue = [...p1Queue, ...p2Queue];

            if (combinedQueue.length > 0) {
                container.style.display = 'block';
                combinedQueue.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = `log-entry respawn-item log-p${item.player}`;
                    
                    const unitInfo = `
                        <div class="respawn-unit-info">
                            <span class="respawn-unit-symbol">${item.unitType.symbol}</span>
                            <span>${item.unitType.name}</span>
                        </div>`;
                    const timerInfo = `<div class="respawn-timer">${item.turnsRemaining} Turns</div>`;
                    
                    itemDiv.innerHTML = unitInfo + timerInfo;
                    listEl.appendChild(itemDiv);
                });
            } else {
                container.style.display = 'none';
            }
        }

        function showInstruction(message, duration = 3000) {
            ui.messageBox.textContent = message.replace(/<br>/g, ' '); 
            ui.messageBox.style.display = 'block';
            if (ui.messageBox.timeoutId) clearTimeout(ui.messageBox.timeoutId);
            ui.messageBox.timeoutId = setTimeout(() => { ui.messageBox.style.display = 'none'; }, duration);
        }

function handleUnitDeath(unitToDie, reason = "destroyed") {
    // Check if the unit is still in the game's master list.
    // This is the most reliable way to prevent errors from destroying the same unit twice.
    const unitExists = gameState.units.some(u => u.id === unitToDie.id);
    if (!unitExists) {
        return; // Already destroyed in this action.
    }

    // Immediately call destroyUnit, no animation.
    destroyUnit(unitToDie, reason);
}

        function logAction(message, player, duration = 3000) {
            showInstruction(message, duration);
            gameState.actionLog.push({ message: message, player: player });
            if (gameState.actionLog.length > 10) {
                gameState.actionLog.shift();
            }
            updateActionLogDisplay();
        }
        
        // --- Game Logic Core ---
        function destroyUnit(unitToDestroy, reason = "destroyed") {
            const activePlayer = gameState.currentPlayer;
            const destroyedPlayer = unitToDestroy.player;
            const wasFortified = unitToDestroy.isFortified;

            gameState.unitCounts[`player${destroyedPlayer}`][unitToDestroy.type.name]--;

    if (unitToDestroy.isCarryingFlag) {
        const flag = Object.values(gameState.flags).find(f => f.carrierId === unitToDestroy.id);
        if (flag) {
            flag.status = 'at_base';
            flag.carrierId = null;
            unitToDestroy.isCarryingFlag = false;
            logAction(`The P${flag.player} flag has been returned to base!`, activePlayer);

            // Restore supply points and recalculate the entire network
            updateSupplyPointsBasedOnFlagStatus(flag.player); // This restores points to 10
            recalculatePlayerSupplyNetwork(flag.player);      // This recalculates lines and deducts costs
        }
    }

    const queueKey = `player${destroyedPlayer}`;

            gameState.respawnQueue[queueKey].push({
                unitType: unitToDestroy.type,
                turnsRemaining: RESPAWN_TURN_TIMER
            });
            updateRespawnQueueDisplay();

            if (reason === "bridge_collapse") {
                logAction(`P${destroyedPlayer} ${unitToDestroy.type.name} fell as the bridge collapsed!`, activePlayer, 3500);
            } else if (reason === "zoc_move" || reason === "zoc_turn_start" || reason === "fort_zoc") {
                logAction(`P${destroyedPlayer} ${unitToDestroy.type.name} destroyed by ZoC!`, activePlayer, 3500);
            } else {
                logAction(`P${destroyedPlayer} ${unitToDestroy.type.name} has been destroyed!`, activePlayer, 3000);
            }

            if (unitToDestroy.positionType === 'edge') {
                const edgeOfUnit = gameState.edges.get(unitToDestroy.position);
                if (edgeOfUnit) edgeOfUnit.units = edgeOfUnit.units.filter(u => u.id !== unitToDestroy.id);
            } else if (unitToDestroy.positionType === 'center' && wasFortified) {
                const fortifiedTile = gameState.tiles.get(unitToDestroy.position);
                if (fortifiedTile && fortifiedTile.fortifiedByPlayer === destroyedPlayer) fortifiedTile.fortifiedByPlayer = null;
            }

            gameState.units = gameState.units.filter(u => u.id !== unitToDestroy.id);

        // If the destroyed unit was fortified, its removal might change the supply network
        if (wasFortified) {
            const playerFlag = gameState.flags[`p${destroyedPlayer}_flag`];
            // Only recalculate the network if that player's flag is NOT currently stolen.
            if (playerFlag && playerFlag.status !== 'carried') {
                recalculatePlayerSupplyNetwork(destroyedPlayer);
            } else {
                // If the flag is stolen, just refund the supply points without recalculating the network.
                // This prevents other forts from being re-supplied accidentally.
                if (unitToDestroy.supplyLine && unitToDestroy.supplyLine.cost > 0) {
                    gameState.supplyPoints[`player${destroyedPlayer}`] += Math.round(unitToDestroy.supplyLine.cost);
                    updateSupplyPointsDisplay();
                }
            }
        }
        
        if (gameState.selectedUnit && gameState.selectedUnit.id === unitToDestroy.id) {
                gameState.selectedUnit = null;
                gameState.currentReachableMoves.clear();
                resetActionSelectionStates();
                updateSelectedUnitInfoPanel();
            }
            if (gameState.hoveredUnitId === unitToDestroy.id) {
                gameState.hoveredUnitId = null;
                canvas.style.cursor = 'default';
            }
            if (gameState.draggingUnit && gameState.draggingUnit.id === unitToDestroy.id) {
                gameState.isDragging = false;
                gameState.draggingUnit = null;
                canvas.style.cursor = 'default';
            }

            checkVictoryCondition();
        }



        function getEdgeCost(unit, edgeKey) {
            const edge = gameState.edges.get(edgeKey); if (!edge) return Infinity;
            const tileCoords = parseEdgeKey(edgeKey);
            const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
            const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
            if (!tile1 || !tile2) return Infinity;
            let baseCost;
            if (edge.bridge) baseCost = 1;
            else {
                if (tile1.type === TILE_TYPES.WATER || tile2.type === TILE_TYPES.WATER) return Infinity;
                if (tile1.type === TILE_TYPES.MOUNTAIN || tile2.type === TILE_TYPES.MOUNTAIN) baseCost = TILE_TYPES.MOUNTAIN.baseMoveCost;
                else if (tile1.type === TILE_TYPES.FOREST || tile2.type === TILE_TYPES.FOREST) baseCost = TILE_TYPES.FOREST.baseMoveCost;
                else baseCost = TILE_TYPES.PLAINS.baseMoveCost;
            }
            let fortificationPenalty = 0; 
            const enemyPlayer = unit.player === 1 ? 2 : 1;
            const enemyBaseEdgeKey = FLAG_HOME_POSITIONS[`player${enemyPlayer}`];
            const enemyBaseTiles = [enemyBaseEdgeKey.split('_')[0], enemyBaseEdgeKey.split('_')[1]];

            if ((tile1.fortifiedByPlayer && tile1.fortifiedByPlayer === enemyPlayer) ||
                (tile2.fortifiedByPlayer && tile2.fortifiedByPlayer === enemyPlayer) ||
                enemyBaseTiles.includes(getTileKey(tile1.q, tile1.r)) ||
                enemyBaseTiles.includes(getTileKey(tile2.q, tile2.r))) 
            {
                fortificationPenalty = 1;
            }
            const finalCost = baseCost + fortificationPenalty;
            return Math.min(finalCost, MAX_MOVEMENT_COST);
        }

        // --- Pathfinding ---
        function getRotationallyAdjacentEdges(currentEdgeKey) {
            const adjacentEdges = new Set(); const [h1, h2] = parseEdgeKey(currentEdgeKey);
            if (isNaN(h1.q) || isNaN(h2.q)) return [];
            const findEdgesAroundPivot = (pivotHex, fromHex) => {
                const dirToFromHex = { q: fromHex.q - pivotHex.q, r: fromHex.r - pivotHex.r };
                const initialDirIndex = findDirectionIndex(dirToFromHex); if (initialDirIndex === -1) return;
                const ccwDirIndex = (initialDirIndex + 1) % 6; const cwDirIndex = (initialDirIndex + 5) % 6;
                const ccwNeighborCoords = { q: pivotHex.q + AXIAL_DIRECTIONS[ccwDirIndex].q, r: pivotHex.r + AXIAL_DIRECTIONS[ccwDirIndex].r };
                const cwNeighborCoords = { q: pivotHex.q + AXIAL_DIRECTIONS[cwDirIndex].q, r: pivotHex.r + AXIAL_DIRECTIONS[cwDirIndex].r };
                if (gameState.tiles.has(getTileKey(ccwNeighborCoords.q, ccwNeighborCoords.r))) adjacentEdges.add(getEdgeKey(pivotHex.q, pivotHex.r, ccwNeighborCoords.q, ccwNeighborCoords.r));
                if (gameState.tiles.has(getTileKey(cwNeighborCoords.q, cwNeighborCoords.r))) adjacentEdges.add(getEdgeKey(pivotHex.q, pivotHex.r, cwNeighborCoords.q, cwNeighborCoords.r));
            };
            findEdgesAroundPivot(h1, h2); findEdgesAroundPivot(h2, h1);
            return Array.from(adjacentEdges);
        }

        function getPossibleMoves(unit) {
            if (!unit || unit.currentMove < 1 || unit.isFortified) return new Map();
            
            if (unit.hasPerformedMajorAction) {
                if (!unit.type.canMoveAfterAttack) {
                    return new Map();
                }
                if (isEdgeAdjacentToSpearWall(unit, unit.position)) {
                    return new Map(); 
                }
            }

            const playerHomeFlagEdge = FLAG_HOME_POSITIONS[`player${unit.player}`];
            let reachable = new Map();
            let frontier = [{ edgeKey: unit.position, pathCost: 0, pathTaken: [unit.position] }];
            let minCostsFound = new Map(); minCostsFound.set(unit.position, 0);
            
            while (frontier.length > 0) {
                frontier.sort((a, b) => a.pathCost - b.pathCost); 
                const current = frontier.shift();

                if (current.pathCost > (minCostsFound.get(current.edgeKey) || Infinity)) continue;
                
                const rotationallyAdjacentEdges = getRotationallyAdjacentEdges(current.edgeKey);

                for (const nextAdjacentEdgeKey of rotationallyAdjacentEdges) {
                    // Add exception for flag carriers
                    // A unit cannot move onto its own team's flag edge, UNLESS it is carrying the enemy flag.
                    if (nextAdjacentEdgeKey === playerHomeFlagEdge && !unit.isCarryingFlag) {
                        continue;
                    }

                    if (nextAdjacentEdgeKey === unit.position && current.pathTaken.length === 1) continue;
                    const nextAdjacentEdgeObject = gameState.edges.get(nextAdjacentEdgeKey); if (!nextAdjacentEdgeObject) continue;
                    if (nextAdjacentEdgeObject.units.some(u => u.player !== unit.player)) continue;
                    const friendlyUnitsOnNext = nextAdjacentEdgeObject.units.filter(u => u.player === unit.player);
                    if (friendlyUnitsOnNext.length >= 2 && !friendlyUnitsOnNext.find(u => u.id === unit.id)) continue;
                    const costToTraverseNextEdge = getEdgeCost(unit, nextAdjacentEdgeKey); if (costToTraverseNextEdge === Infinity) continue;
                    const newTotalPathCost = current.pathCost + costToTraverseNextEdge;
                    if (newTotalPathCost <= unit.currentMove) {
                        const knownMinCost = minCostsFound.get(nextAdjacentEdgeKey) || Infinity;
                        if (newTotalPathCost < knownMinCost) {
                            minCostsFound.set(nextAdjacentEdgeKey, newTotalPathCost);
                            const newPathTaken = current.pathTaken.concat(nextAdjacentEdgeKey);
                            frontier.push({ edgeKey: nextAdjacentEdgeKey, pathCost: newTotalPathCost, pathTaken: newPathTaken });
                            if (nextAdjacentEdgeKey !== unit.position) reachable.set(nextAdjacentEdgeKey, { cost: newTotalPathCost, path: newPathTaken });
                        }
                    }
                }
            }
            return reachable;
        }

        function findSupplyPath(startFortTileKey, player) {
            // If the player's flag is stolen, they cannot have a supply line.
            const playerFlag = gameState.flags[`p${player}`];
            if (playerFlag && playerFlag.status === 'carried') {
                return null;
            }

            const baseEdgeKey = FLAG_HOME_POSITIONS[`player${player}`];
            const [baseH1, baseH2] = parseEdgeKey(baseEdgeKey);
            
            // The "start" for our pathfinding are all edges adjacent to the fort
            const startTile = gameState.tiles.get(startFortTileKey);
            if (!startTile) return null;
            const startEdges = getEdgesOfTile(startTile.q, startTile.r);
            
            // The "goals" are all edges adjacent to either base tile
            const endEdges = new Set([...getEdgesOfTile(baseH1.q, baseH1.r), ...getEdgesOfTile(baseH2.q, baseH2.r)]);

            let frontier = [];
            for (const edge of startEdges) {
                if (isRoad(edge)) {
                     frontier.push({ edgeKey: edge, cost: getEdgeCost({player}, edge), path: [edge] });
                }
            }

            let visited = new Map();
            startEdges.forEach(edge => visited.set(edge, { cost: 0, path: [] }));

            while (frontier.length > 0) {
                frontier.sort((a, b) => a.cost - b.cost);
                const current = frontier.shift();

                if (endEdges.has(current.edgeKey)) {
                    // Path found! Now calculate the adjusted cost.
                    let adjustedCost = current.cost;
                    const fullPath = current.path;

                    // Subtract the cost of the first and last edge segments.
                    if (fullPath.length > 0) {
                        adjustedCost -= getEdgeCost({ player }, fullPath[0]);
                    }
                    if (fullPath.length > 1) {
                        adjustedCost -= getEdgeCost({ player }, fullPath[fullPath.length - 1]);
                    }

                    const visualPath = fullPath.length > 2 ? fullPath.slice(1, -1) : [];
                    return { path: visualPath, cost: Math.max(0, adjustedCost) }; // Ensure cost isn't negative
                }

                const adjacentEdges = getRotationallyAdjacentEdges(current.edgeKey);
                for (const neighborEdgeKey of adjacentEdges) {
                    if (!isRoad(neighborEdgeKey)) continue;

                    const costToNeighbor = getEdgeCost({ player }, neighborEdgeKey);
                    const newCost = current.cost + costToNeighbor;

                    if (!visited.has(neighborEdgeKey) || newCost < visited.get(neighborEdgeKey).cost) {
                        const newPath = [...current.path, neighborEdgeKey];
                        visited.set(neighborEdgeKey, { cost: newCost, path: newPath });
                        frontier.push({ edgeKey: neighborEdgeKey, cost: newCost, path: newPath });
                    }
                }
            }

            return null; // No path found
        }

        function recalculatePlayerSupplyNetwork(playerNum) {
            const playerSupplyKey = `player${playerNum}`;
            const maxSupply = 10;

            // Guard clause to prevent supply calculation if flag is stolen
            const playerFlag = gameState.flags[`p${playerNum}_flag`];
            if (playerFlag && playerFlag.status === 'carried') {
                // If the flag is stolen, no unit can be in supply.
                // Nullify all supply lines but DO NOT change supply points.
                gameState.units.forEach(unit => {
                    if (unit.player === playerNum) {
                        unit.supplyLine = null;
                    }
                });
                // The player's supply points should remain at 0.
                return; // Exit the function immediately.
            }

            // Reset all non-base supply lines for the player to start fresh
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    const playerBaseTiles = [FLAG_HOME_POSITIONS[playerSupplyKey].split('_')[0], FLAG_HOME_POSITIONS[playerSupplyKey].split('_')[1]];
                    if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                         unit.supplyLine = null;
                    }
                }
            });

            // Find all fortified units and their potential individual paths
            const potentialSupplies = [];
            const fortifiedUnits = gameState.units.filter(u => u.player === playerNum && u.isFortified);

            fortifiedUnits.forEach(unit => {
                const playerBaseTiles = [FLAG_HOME_POSITIONS[playerSupplyKey].split('_')[0], FLAG_HOME_POSITIONS[playerSupplyKey].split('_')[1]];
                if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                    const pathData = findSupplyPath(unit.fortifiedTileKey, playerNum);
                    if (pathData) {
                        potentialSupplies.push({
                            unit: unit,
                            cost: Math.round(pathData.cost), // Individual cost for sorting
                            pathData: pathData
                        });
                    }
                }
            });

            // Prioritize supplying the forts with the cheapest lines first to maximize efficiency
            potentialSupplies.sort((a, b) => a.cost - b.cost);

            let allUsedRoads = new Set();
            let networkSupplyCost = 0;
            
            // Go through the prioritized list and establish supply lines if the network can afford it
            potentialSupplies.forEach(supply => {
                const pathEdges = new Set(supply.pathData.path);
                
                // Calculate the cost of adding this fort's unique roads to the network
                let incrementalCost = 0;
                pathEdges.forEach(road => {
                    if (!allUsedRoads.has(road)) {
                        incrementalCost += getEdgeCost({ player: playerNum }, road);
                    }
                });

                if (networkSupplyCost + incrementalCost <= maxSupply) {
                    // Fund this supply line
                    networkSupplyCost += incrementalCost;
                    supply.unit.supplyLine = supply.pathData;
                    
                    // Add the newly funded roads to the master set of used roads
                    pathEdges.forEach(road => allUsedRoads.add(road));
                } else {
                    // Can't afford it, so it remains unsupplied
                    supply.unit.supplyLine = null;
                }
            });

            // Update the player's remaining supply points based on the final network cost
            gameState.supplyPoints[playerSupplyKey] = maxSupply - Math.round(networkSupplyCost);
            updateSupplyPointsDisplay();
        }

function fundNewFortification(unit) {
    const player = unit.player;
    const playerSupplyKey = `player${player}`;

    const pathData = findSupplyPath(unit.fortifiedTileKey, player);

    if (pathData && pathData.cost <= gameState.supplyPoints[playerSupplyKey]) {
        // Can afford it, fund the new line
        unit.supplyLine = pathData;
        gameState.supplyPoints[playerSupplyKey] -= Math.round(pathData.cost);
        logAction(`P${player} ${unit.type.name} established a supply line (Cost: ${Math.round(pathData.cost)}).`, player);
    } else {
        // Cannot afford it or no path exists, remains unsupplied
        unit.supplyLine = null;
        logAction(`P${player} ${unit.type.name} fortified, but is unsupplied.`, player);
    }
    updateSupplyPointsDisplay();
}

        function severSupplyLinesForPlayer(playerNum) {
            logAction(`P${playerNum}'s flag was stolen! Supply lines have been cut.`, playerNum === 1 ? 2 : 1);
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    unit.supplyLine = null;
                }
            });
        }

        function recalculateSupplyLinesForPlayer(playerNum) {
            logAction(`P${playerNum}'s flag has been returned! Supply lines are re-established.`, playerNum);
            gameState.units.forEach(unit => {
                if (unit.player === playerNum && unit.isFortified) {
                    const playerBaseTiles = [FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
                    if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                        unit.supplyLine = findSupplyPath(unit.fortifiedTileKey, unit.player);
                    }
                }
            });
        }

        function attemptToResupplyForts(playerNum) {
            const playerSupplyKey = `player${playerNum}`;
            const unsuppliedForts = gameState.units.filter(u => 
                u.player === playerNum && 
                u.isFortified && 
                u.supplyLine === null
            );

            if (unsuppliedForts.length === 0) return;

            // Find potential supply lines and their costs for all unsupplied forts
            const potentialResupplies = [];
            unsuppliedForts.forEach(unit => {
                const playerBaseTiles = [FLAG_HOME_POSITIONS[playerSupplyKey].split('_')[0], FLAG_HOME_POSITIONS[playerSupplyKey].split('_')[1]];
                if (!playerBaseTiles.includes(unit.fortifiedTileKey)) {
                    const supplyPathData = findSupplyPath(unit.fortifiedTileKey, playerNum);
                    if (supplyPathData) {
                        potentialResupplies.push({
                            unit: unit,
                            cost: Math.round(supplyPathData.cost),
                            pathData: supplyPathData
                        });
                    }
                }
            });

            // Prioritize the cheapest supply lines first
            potentialResupplies.sort((a, b) => a.cost - b.cost);

            // Attempt to fund the new supply lines
            potentialResupplies.forEach(resupply => {
                if (gameState.supplyPoints[playerSupplyKey] >= resupply.cost) {
                    gameState.supplyPoints[playerSupplyKey] -= resupply.cost;
                    resupply.unit.supplyLine = resupply.pathData;
                    logAction(`P${playerNum} ${resupply.unit.type.name} is now in supply! (Cost: ${resupply.cost})`, playerNum);
                }
            });
            
            updateSupplyPointsDisplay();
        }

        // --- Action: Fortify / Unfortify ---
function getPotentialUnfortifyTargets(unit) {
    if (!unit || !unit.isFortified || unit.positionType !== 'center') return [];
    const fortifiedTile = gameState.tiles.get(unit.position); if (!fortifiedTile) return [];
    
    const playerHomeFlagEdge = FLAG_HOME_POSITIONS[`player${unit.player}`];
    const validTargets = [];

    getNeighbors(fortifiedTile.q, fortifiedTile.r).forEach(neighborCoords => {
        const edgeKey = getEdgeKey(fortifiedTile.q, fortifiedTile.r, neighborCoords.q, neighborCoords.r);
        
        // CRITICAL FIX: Prevent unfortifying onto the player's own home flag tile.
        if (edgeKey === playerHomeFlagEdge) {
            return; // Skip this edge, it's not a valid target.
        }

        const edge = gameState.edges.get(edgeKey);
        if (edge && getEdgeCost(unit, edgeKey) !== Infinity) {
             const enemyOnEdge = edge.units.some(u => u.player !== unit.player);
             const friendliesOnEdge = edge.units.filter(u => u.player === unit.player).length;
             if (!enemyOnEdge && friendliesOnEdge < 2) {
                 validTargets.push(edgeKey);
             }
         }
     });
     return validTargets;
}

function completeFortify(unitToFortify, targetTileKeyToFortify) {
    if (!unitToFortify || unitToFortify.hasPerformedMajorAction || unitToFortify.isFortified) { showInstruction("Cannot fortify now.", 2000); return; }
    const targetTileObject = gameState.tiles.get(targetTileKeyToFortify);
    if (!targetTileObject || !targetTileObject.type.canFortify) { showInstruction("Invalid tile to fortify.", 2000); return; }
    if (targetTileObject.fortifiedByPlayer !== null) {
        showInstruction(`Tile ${targetTileKeyToFortify.substring(0,5)}... already fortified.`, 2500);
        resetActionSelectionStates(); 
        updateSelectedUnitInfoPanel(); return;
    }
    
    const animation = {
        type: 'fortify',
        unit: unitToFortify,
        targetTileKey: targetTileKeyToFortify,
        startTime: Date.now(),
        duration: 450,

        onComplete: async () => {
            gameState.playerActionTaken[`player${gameState.currentPlayer}`] = true;
            const fortifyingPlayer = unitToFortify.player;
            
            const currentEdge = gameState.edges.get(unitToFortify.position);
            if (currentEdge) currentEdge.units = currentEdge.units.filter(u => u.id !== unitToFortify.id);
            unitToFortify.isFortified = true; unitToFortify.fortifiedTileKey = targetTileKeyToFortify;
            unitToFortify.positionType = 'center'; unitToFortify.position = targetTileKeyToFortify;
            unitToFortify.currentMove = 0; unitToFortify.hasPerformedMajorAction = true;
            targetTileObject.fortifiedByPlayer = fortifyingPlayer;
            logAction(`${unitToFortify.type.name} fortified on tile ${targetTileKeyToFortify.substring(0,5)}...`, fortifyingPlayer, 2500);

            const playerFlag = gameState.flags[`p${fortifyingPlayer}_flag`];
            if (playerFlag && playerFlag.status !== 'carried') {
                // --- THIS IS THE FIX ---
                // Instead of funding one fort, recalculate the entire player's network
                // to account for shared supply lines.
                recalculatePlayerSupplyNetwork(fortifyingPlayer);
                // --- END OF FIX ---
            } else {
                logAction(`P${unitToFortify.player} ${unitToFortify.type.name} fortified, but is unsupplied due to stolen flag.`, fortifyingPlayer, 3000);
            }

            let unitsToDestroy = [];
            getNeighbors(targetTileObject.q, targetTileObject.r).forEach(neighborCoords => {
                 const edgeKey = getEdgeKey(targetTileObject.q, targetTileObject.r, neighborCoords.q, neighborCoords.r);
                 const adjacentEdge = gameState.edges.get(edgeKey);
                 if (adjacentEdge) {
                     adjacentEdge.units.forEach(enemyUnit => {
                         if (enemyUnit.player !== fortifyingPlayer && enemyUnit.positionType === 'edge') {
                             enemyUnit.hp -= FORTIFICATION_DAMAGE;
                             logAction(`P${enemyUnit.player} ${enemyUnit.type.name} takes ZoC. HP: ${enemyUnit.hp}`, fortifyingPlayer);
                             if (enemyUnit.hp <= 0 && !unitsToDestroy.find(u => u.id === enemyUnit.id)) unitsToDestroy.push(enemyUnit);
                         }
                     });
                 }
             });
            unitsToDestroy.forEach(u => handleUnitDeath(u, "zoc_fort"));

            gameState.currentReachableMoves.clear();
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
            if (!gameState.gameOver) checkVictoryCondition();
        }
    };
    
    if (gameSettings.animationsEnabled) {
        gameState.activeAnimations.push(animation);
    } else {
        animation.onComplete();
    }
    
    resetActionSelectionStates(); 
    updateSelectedUnitInfoPanel();
}

        function handleFortifyActionLogic() {
            const { selectedUnit } = gameState;
             if (!selectedUnit || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified || selectedUnit.positionType !== 'edge') { showInstruction("Cannot fortify.", 2000); return; }
            const edgeCoords = parseEdgeKey(selectedUnit.position);
             if (!edgeCoords || edgeCoords.length !== 2 || isNaN(edgeCoords[0].q)) { showInstruction("Unit not on valid edge.", 2000); return; }

            const enemyPlayer = selectedUnit.player === 1 ? 2 : 1;
            const enemyBaseEdgeKey = FLAG_HOME_POSITIONS[`player${enemyPlayer}`];
            const [enemy_h1, enemy_h2] = parseEdgeKey(enemyBaseEdgeKey);
            const enemyBaseTileKeys = new Set([getTileKey(enemy_h1.q, enemy_h1.r), getTileKey(enemy_h2.q, enemy_h2.r)]);

            const tile1Key = getTileKey(edgeCoords[0].q, edgeCoords[0].r); 
            const tile2Key = getTileKey(edgeCoords[1].q, edgeCoords[1].r);
            const tile1 = gameState.tiles.get(tile1Key); 
            const tile2 = gameState.tiles.get(tile2Key);
            
            gameState.validFortifyTargetTileKeys = [];
            if (tile1 && tile1.type.canFortify && tile1.fortifiedByPlayer === null && !enemyBaseTileKeys.has(tile1Key)) {
                gameState.validFortifyTargetTileKeys.push(tile1Key);
            }
            if (tile2 && tile2.type.canFortify && tile2.fortifiedByPlayer === null && !enemyBaseTileKeys.has(tile2Key)) {
                gameState.validFortifyTargetTileKeys.push(tile2Key);
            }

            if (gameState.validFortifyTargetTileKeys.length === 0) { showInstruction("No valid adjacent tile to fortify.", 2000); return; }
            
            if (gameState.validFortifyTargetTileKeys.length === 1) {
                // --- THIS IS THE FIX ---
                // We now pass both the selected unit and the target tile key, as required.
                completeFortify(selectedUnit, gameState.validFortifyTargetTileKeys[0]);
            } else { 
                gameState.currentActionState = ACTION_STATES.SELECTING_FORTIFY_TILE;
                showInstruction("Select tile to fortify.", 3000); 
            }
            updateSelectedUnitInfoPanel();
        }

function completeUnfortify(unitToUnfortify, targetEdgeKey) {
    if (!unitToUnfortify || !unitToUnfortify.isFortified || unitToUnfortify.hasPerformedMajorAction) {
        showInstruction("Cannot unfortify now.", 2000); 
        return; 
    }
    const targetEdge = gameState.edges.get(targetEdgeKey); 
    if (!targetEdge) { 
        showInstruction("Invalid target edge.", 2000); 
        return; 
    }
    if (targetEdge.units.some(u => u.player !== unitToUnfortify.player) || targetEdge.units.filter(u => u.player === unitToUnfortify.player).length >= 2) {
         showInstruction("Target edge blocked.", 2000); 
         resetActionSelectionStates();
         updateSelectedUnitInfoPanel(); 
         return;
    }

    const startTileKey = unitToUnfortify.position;
    const oldFortifiedTile = gameState.tiles.get(startTileKey);
    
    if (oldFortifiedTile) {
        oldFortifiedTile.fortifiedByPlayer = null;
    }
    unitToUnfortify.supplyLine = null;

    const animation = {
        type: 'unfortify',
        unit: unitToUnfortify,
        startTileKey: startTileKey,
        targetEdgeKey: targetEdgeKey,
        startTime: Date.now(),
        duration: 600,

        onComplete: async () => {
            const unfortifyingPlayer = unitToUnfortify.player;
            
            unitToUnfortify.fortifyCooldown = unitToUnfortify.turnsFortified * 5; 

            unitToUnfortify.isFortified = false;
            unitToUnfortify.turnsFortifiedAtBase = 0;
            unitToUnfortify.turnsFortified = 0;      
            unitToUnfortify.supplyLine = null;
            unitToUnfortify.fortifiedTileKey = null;
            unitToUnfortify.positionType = 'edge'; 
            unitToUnfortify.position = targetEdgeKey;
            unitToUnfortify.currentMove = 0; 
            unitToUnfortify.hasPerformedMajorAction = true;
            targetEdge.units.push(unitToUnfortify);
            logAction(`${unitToUnfortify.type.name} unfortified to ${targetEdgeKey.substring(0,7)}...`, unfortifyingPlayer, 2500);
            
            recalculatePlayerSupplyNetwork(unfortifyingPlayer);

            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
        }
    };

    if (gameSettings.animationsEnabled) {
        gameState.activeAnimations.push(animation);
    } else {
        animation.onComplete();
    }
    
    resetActionSelectionStates();
    updateSelectedUnitInfoPanel();
}

        function handleUnfortifyActionLogic() {
            const { selectedUnit } = gameState;
            if (!selectedUnit || !selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) { showInstruction("Cannot unfortify.", 2000); return; }
            gameState.validUnfortifyTargetEdgeKeys = getPotentialUnfortifyTargets(selectedUnit);
            if (gameState.validUnfortifyTargetEdgeKeys.length === 0) { showInstruction("No valid edge to unfortify to.", 2500); return; }
            
            gameState.currentActionState = ACTION_STATES.SELECTING_UNFORTIFY_EDGE;
            showInstruction("Select edge to move to.", 3000); 
            updateSelectedUnitInfoPanel();
        }

        function handleFortifyUnfortifyButtonClick() {
            if (gameState.gameMode === 'singleplayer' && gameState.selectedUnit && gameState.selectedUnit.player !== gameState.playerSide) return;
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState; 
            if (!selectedUnit) return;

            if (gameState.currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE || gameState.currentActionState === ACTION_STATES.SELECTING_UNFORTIFY_EDGE) {
                const message = gameState.currentActionState === ACTION_STATES.SELECTING_FORTIFY_TILE ? "Fortify cancelled." : "Unfortify cancelled.";
                resetActionSelectionStates();
                showInstruction(message, 1500);
            } else if (selectedUnit.isFortified) {
                handleUnfortifyActionLogic();
            } else {
                handleFortifyActionLogic();
            }
            updateSelectedUnitInfoPanel();
        }

        // --- Action: Build Bridge ---
        function getPotentialBridgeTargets(unit) {
            if (!unit || unit.positionType !== 'edge' || !unit.type.canBuildBridge || unit.isFortified) return [];

            const rotationallyAdjacentEdges = getRotationallyAdjacentEdges(unit.position);
            
            return rotationallyAdjacentEdges.filter(adjEdgeKey => {
                if (adjEdgeKey === unit.position) return false; 
                
                const edgeData = gameState.edges.get(adjEdgeKey);
                if (edgeData && !edgeData.bridge) { 
                    const adjEdgeTileCoords = parseEdgeKey(adjEdgeKey);
                    if (adjEdgeTileCoords.some(coord => isNaN(coord.q))) return false;

                    const t1 = gameState.tiles.get(getTileKey(adjEdgeTileCoords[0].q, adjEdgeTileCoords[0].r));
                    const t2 = gameState.tiles.get(getTileKey(adjEdgeTileCoords[1].q, adjEdgeTileCoords[1].r));
                    
                    return (t1 && t1.type === TILE_TYPES.WATER) || (t2 && t2.type === TILE_TYPES.WATER);
                }
                return false;
            });
        }


        function handleBuildBridgeAction() {
            if (gameState.gameMode === 'singleplayer' && gameState.selectedUnit && gameState.selectedUnit.player !== gameState.playerSide) return;
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState;

            if (gameState.currentActionState === ACTION_STATES.SELECTING_BRIDGE_EDGE) {
                resetActionSelectionStates();
                showInstruction("Bridge selection cancelled.", 1500);
                updateSelectedUnitInfoPanel(); 
                return;
            }
            if (!selectedUnit || !selectedUnit.type.canBuildBridge || selectedUnit.isFortified || selectedUnit.hasPerformedMajorAction) {
                showInstruction(selectedUnit && selectedUnit.hasPerformedMajorAction ? "Unit acted." : "Cannot build bridge.", 2000); 
                return;
            }
            gameState.validBridgeTargetEdgeKeys = getPotentialBridgeTargets(selectedUnit);
            if (gameState.validBridgeTargetEdgeKeys.length === 0) {
                showInstruction("No valid water edge for bridge.", 2000);
            } else { 
                gameState.currentActionState = ACTION_STATES.SELECTING_BRIDGE_EDGE;
                showInstruction("Select water edge for bridge.", 3000); 
            }
            updateSelectedUnitInfoPanel();
        }

function completeBuildBridge(targetEdgeKey) {
    const { selectedUnit } = gameState;
    if (!selectedUnit || !selectedUnit.type.canBuildBridge || selectedUnit.hasPerformedMajorAction || selectedUnit.isFortified) {
         showInstruction("Cannot build bridge.", 2000); 
         resetActionSelectionStates();
         updateSelectedUnitInfoPanel(); 
         return;
    }
    const edgeToBridge = gameState.edges.get(targetEdgeKey);
    if (!edgeToBridge || edgeToBridge.bridge) {
        showInstruction("Cannot build bridge here.", 2000); 
        resetActionSelectionStates();
        updateSelectedUnitInfoPanel(); 
        return;
    }

    const animation = {
        type: 'build_bridge',
        unit: selectedUnit,
        targetEdgeKey: targetEdgeKey,
        startTime: Date.now(),
        duration: 500,

        onComplete: () => {
            edgeToBridge.bridge = true; 
            edgeToBridge.bridgeHp = BRIDGE_MAX_HP;
            selectedUnit.currentMove = 0; 
            selectedUnit.hasPerformedMajorAction = true;
            logAction(`${selectedUnit.type.name} built bridge on ${targetEdgeKey.substring(0,7)}... HP: ${edgeToBridge.bridgeHp}`, gameState.currentPlayer, 3000);
            resetActionSelectionStates();
            updateSelectedUnitInfoPanel();
        }
    };
    
    if (gameSettings.animationsEnabled) {
        gameState.activeAnimations.push(animation);
    } else {
        animation.onComplete();
    }
    
    resetActionSelectionStates();
    updateSelectedUnitInfoPanel();
}

        // --- Action: Movement & Fortification Damage ---
        function applyFortificationDamageOnMove(unitMoving, newEdgeKey) {
             if (!unitMoving || unitMoving.isFortified || unitMoving.positionType !== 'edge') return false;
            const tileCoords = parseEdgeKey(newEdgeKey); 
            if (tileCoords.some(coord => isNaN(coord.q))) return false;
            let unitDestroyed = false; const enemyPlayer = unitMoving.player === 1 ? 2 : 1;
            const checkAndApply = (tile) => {
                if (tile && tile.fortifiedByPlayer === enemyPlayer && !unitDestroyed) {
                    unitMoving.hp -= FORTIFICATION_DAMAGE;
                    logAction(`P${unitMoving.player} ${unitMoving.type.name} takes ZoC. HP: ${unitMoving.hp}`, gameState.currentPlayer, 3500);
                    if (unitMoving.hp <= 0) { handleUnitDeath(unitMoving, "zoc_move"); unitDestroyed = true; }
                    return true;
                } return false;
            };
            const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
            const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
            checkAndApply(tile1); checkAndApply(tile2);
            return unitDestroyed;
        }


        // --- Action: Attack (Melee & Archer) ---
        function getPotentialMeleeAttackEdges(attackingUnit) {
            const potentialEdges = new Set();
            if (!attackingUnit) return Array.from(potentialEdges);

            if (attackingUnit.isFortified && attackingUnit.positionType === 'center') {
                const fortifiedTile = gameState.tiles.get(attackingUnit.position);
                if (!fortifiedTile) return Array.from(potentialEdges);
                getNeighbors(fortifiedTile.q, fortifiedTile.r).forEach(neighborCoords => {
                    if (gameState.tiles.has(getTileKey(neighborCoords.q, neighborCoords.r))) {
                        const edgeKey = getEdgeKey(fortifiedTile.q, fortifiedTile.r, neighborCoords.q, neighborCoords.r);
                        potentialEdges.add(edgeKey);
                    }
                });
            } else if (attackingUnit.positionType === 'edge') {
                return getRotationallyAdjacentEdges(attackingUnit.position);
            }
            return Array.from(potentialEdges);
        }

        function getPotentialArcherAttackEdges(attackingUnit) {
            const potentialEdges = new Set();
            if (!attackingUnit || attackingUnit.type.name !== 'Archer') return Array.from(potentialEdges);

            if (attackingUnit.isFortified && attackingUnit.positionType === 'center') {
                const attackerTileKey = attackingUnit.position;
                const attackerTile = gameState.tiles.get(attackerTileKey);
                if (!attackerTile) return Array.from(potentialEdges);
                getNeighbors(attackerTile.q, attackerTile.r).forEach(neighborCoords => {
                    const neighborKey = getTileKey(neighborCoords.q, neighborCoords.r);
                    if (gameState.tiles.has(neighborKey)) {
                        potentialEdges.add(getEdgeKey(attackerTile.q, attackerTile.r, neighborCoords.q, neighborCoords.r));
                    }
                });
            } else if (attackingUnit.positionType === 'edge') {
                const currentUnitEdgeKey = attackingUnit.position;
                const [H1_coords, H2_coords] = parseEdgeKey(currentUnitEdgeKey);
                if (isNaN(H1_coords.q) || isNaN(H2_coords.q)) return Array.from(potentialEdges);

                const processHex = (hexCoords) => {
                    if (gameState.tiles.has(getTileKey(hexCoords.q, hexCoords.r))) {
                        getNeighbors(hexCoords.q, hexCoords.r).forEach(neighbor_coords => {
                            if (gameState.tiles.has(getTileKey(neighbor_coords.q, neighbor_coords.r))) {
                                const edgeToAdd = getEdgeKey(hexCoords.q, hexCoords.r, neighbor_coords.q, neighbor_coords.r);
                                potentialEdges.add(edgeToAdd); 
                            }
                        });
                    }
                };
                processHex(H1_coords);
                processHex(H2_coords);
            }
            return Array.from(potentialEdges);
        }

        function getValidMeleeAttackTargets(attackingUnit) {
            if (!attackingUnit || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction) return [];
            const targets = [];
            const addUnitTarget = (targetUnit, edgeKey = null, tileKeyForTarget = null) => {
                if (!targets.some(t => t.unit && t.unit.id === targetUnit.id)) targets.push({ unit: targetUnit, edgeKey, tileKeyForTarget, isBridgeTarget: false });
            };
            const addBridgeTarget = (edgeKey) => {
                 if (!targets.some(t => t.isBridgeTarget && t.edgeKey === edgeKey)) targets.push({ unit: null, edgeKey, tileKeyForTarget: null, isBridgeTarget: true });
            }
            
            const potentialAttackEdges = getPotentialMeleeAttackEdges(attackingUnit);

            potentialAttackEdges.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    edge.units.forEach(unitOnEdge => { 
                        if (unitOnEdge.player !== attackingUnit.player && unitOnEdge.positionType === 'edge') {
                            addUnitTarget(unitOnEdge, edgeKey); 
                        }
                    });
                     if (edge.bridge && edge.bridgeHp > 0) addBridgeTarget(edgeKey);
                }
            });
            
            if (attackingUnit.positionType === 'edge') { 
                const [H1_coords, H2_coords] = parseEdgeKey(attackingUnit.position);
                [H1_coords, H2_coords].forEach(hexCoords => { 
                     if (isNaN(hexCoords.q)) return;
                    const tileKey = getTileKey(hexCoords.q, hexCoords.r);
                    const tile = gameState.tiles.get(tileKey);
                    if (tile && tile.fortifiedByPlayer && tile.fortifiedByPlayer !== attackingUnit.player) {
                        const fortifiedUnit = gameState.units.find(u => u.isFortified && u.position === tileKey && u.player === tile.fortifiedByPlayer);
                        if (fortifiedUnit) {
                            addUnitTarget(fortifiedUnit, null, tileKey);
                        }
                    }
                });
            }
            return targets;
        }

        function canArcherOnEdgeSeeEdge(archerEdgeKey, targetEdgeKey, archerTile1, archerTile2) {
            let blockedByTile1 = false;
            if (archerTile1.type === TILE_TYPES.MOUNTAIN) {
                if (isEdgePartOfTile(archerTile1.q, archerTile1.r, targetEdgeKey) && targetEdgeKey !== archerEdgeKey) {
                    blockedByTile1 = true;
                }
            } else if (archerTile1.type === TILE_TYPES.FOREST) {
                if (isEdgePartOfTile(archerTile1.q, archerTile1.r, targetEdgeKey) &&
                    targetEdgeKey !== archerEdgeKey &&
                    !isEdgeRotationallyAdjacentToEdgeOnTile(archerTile1.q, archerTile1.r, archerEdgeKey, targetEdgeKey)) {
                    blockedByTile1 = true;
                }
            }

            let blockedByTile2 = false;
            if (archerTile2.type === TILE_TYPES.MOUNTAIN) {
                if (isEdgePartOfTile(archerTile2.q, archerTile2.r, targetEdgeKey) && targetEdgeKey !== archerEdgeKey) {
                    blockedByTile2 = true;
                }
            } else if (archerTile2.type === TILE_TYPES.FOREST) {
                if (isEdgePartOfTile(archerTile2.q, archerTile2.r, targetEdgeKey) &&
                    targetEdgeKey !== archerEdgeKey &&
                    !isEdgeRotationallyAdjacentToEdgeOnTile(archerTile2.q, archerTile2.r, archerEdgeKey, targetEdgeKey)) {
                    blockedByTile2 = true;
                }
            }
            return !blockedByTile1 && !blockedByTile2;
        }
        
        function canArcherOnEdgeSeeFortified(archerEdgeKey, targetFortifiedTileKey, archerTile1, archerTile2) {
            const targetFortifiedTile = gameState.tiles.get(targetFortifiedTileKey);
            if (!targetFortifiedTile) return false;

            let obstructed = false;
            if (archerTile1.type === TILE_TYPES.FOREST) {
                const connectingEdgeKey = getEdgeKey(archerTile1.q, archerTile1.r, targetFortifiedTile.q, targetFortifiedTile.r);
                if (gameState.edges.has(connectingEdgeKey)) { 
                    if (!isEdgeRotationallyAdjacentToEdgeOnTile(archerTile1.q, archerTile1.r, archerEdgeKey, connectingEdgeKey)) {
                        obstructed = true; 
                    }
                }
            }

            if (!obstructed && archerTile2.type === TILE_TYPES.FOREST) {
                const connectingEdgeKey = getEdgeKey(archerTile2.q, archerTile2.r, targetFortifiedTile.q, targetFortifiedTile.r);
                 if (gameState.edges.has(connectingEdgeKey)) { 
                    if (!isEdgeRotationallyAdjacentToEdgeOnTile(archerTile2.q, archerTile2.r, archerEdgeKey, connectingEdgeKey)) {
                        obstructed = true;
                    }
                }
            }
            if (obstructed) return false;

            const [archerH1_coords, archerH2_coords] = parseEdgeKey(archerEdgeKey);
            
            let isRotationallyValid = false;
            const connectingEdge1_key = getEdgeKey(archerH1_coords.q, archerH1_coords.r, targetFortifiedTile.q, targetFortifiedTile.r);
            if (gameState.edges.has(connectingEdge1_key)) { 
                if (isEdgeRotationallyAdjacentToEdgeOnTile(archerH1_coords.q, archerH1_coords.r, archerEdgeKey, connectingEdge1_key)) {
                    isRotationallyValid = true;
                }
            }
            
            if (!isRotationallyValid) { 
                const connectingEdge2_key = getEdgeKey(archerH2_coords.q, archerH2_coords.r, targetFortifiedTile.q, targetFortifiedTile.r);
                 if (gameState.edges.has(connectingEdge2_key)) { 
                    if (isEdgeRotationallyAdjacentToEdgeOnTile(archerH2_coords.q, archerH2_coords.r, archerEdgeKey, connectingEdge2_key)) {
                        isRotationallyValid = true;
                    }
                }
            }
            
            return isRotationallyValid;
        }

        function canFortifiedArcherSee(attackingUnit, targetInfo) {
            const archerFortTileKey = attackingUnit.position;
            const archerFortTile = gameState.tiles.get(archerFortTileKey);
            if (!archerFortTile) return false;

            if (archerFortTile.type === TILE_TYPES.FOREST) {
                if (targetInfo.isBridgeTarget || (targetInfo.unit && !targetInfo.unit.isFortified)) {
                    return isEdgePartOfTile(archerFortTile.q, archerFortTile.r, targetInfo.edgeKey);
                } else if (targetInfo.unit.isFortified) {
                    const targetTileKey = targetInfo.tileKeyForTarget;
                    const targetTile = gameState.tiles.get(targetTileKey);
                    if (!targetTile) return false;
                    const isAdjacent = axialDistance(archerFortTile.q, archerFortTile.r, targetTile.q, targetTile.r) === 1;
                    return isAdjacent && targetTile.type !== TILE_TYPES.FOREST;
                }
            }

            if (targetInfo.unit && targetInfo.unit.isFortified) {
                const targetTile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                if (targetTile && targetTile.type === TILE_TYPES.FOREST) {
                    return false;
                }
            }
            return true;
        }

        function canEdgeArcherSee(attackingUnit, targetInfo) {
            const archerEdgeKey = attackingUnit.position;
            const [archerH1, archerH2] = parseEdgeKey(archerEdgeKey);
            const archerTile1 = gameState.tiles.get(getTileKey(archerH1.q, archerH1.r));
            const archerTile2 = gameState.tiles.get(getTileKey(archerH2.q, archerH2.r));
            if (!archerTile1 || !archerTile2) return false;

            if (targetInfo.isBridgeTarget || (targetInfo.unit && !targetInfo.unit.isFortified)) {
                return canArcherOnEdgeSeeEdge(archerEdgeKey, targetInfo.edgeKey, archerTile1, archerTile2);
            }
            
            if (targetInfo.unit && targetInfo.unit.isFortified) {
                const targetTileKey = targetInfo.tileKeyForTarget;
                const targetTile = gameState.tiles.get(targetTileKey);
                if (!targetTile) return false;

                if (targetTile.type === TILE_TYPES.FOREST) {
                    if (!isEdgePartOfTile(targetTile.q, targetTile.r, archerEdgeKey)) {
                        return false; 
                    }
                }
                
                const isImmediatelyAdjacentFort = (targetTileKey === getTileKey(archerH1.q, archerH1.r) || targetTileKey === getTileKey(archerH2.q, archerH2.r));
                if (isImmediatelyAdjacentFort) {
                    const archerEdge = gameState.edges.get(archerEdgeKey);
                    const hasMeleeSpotter = archerEdge.units.some(u => u.player === attackingUnit.player && u.type.name === 'Melee');
                    return hasMeleeSpotter;
                } else {
                    return canArcherOnEdgeSeeFortified(archerEdgeKey, targetTileKey, archerTile1, archerTile2);
                }
            }
            
            return false;
        }

        function getValidArcherAttackTargets(attackingUnit) {
            if (!attackingUnit || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction || attackingUnit.type.name !== 'Archer') {
                return [];
            }

            const potentialAttackEdges = getPotentialArcherAttackEdges(attackingUnit);
            const potentialTargetableTiles = new Set();
            potentialAttackEdges.forEach(edgeKey => {
                const [c1, c2] = parseEdgeKey(edgeKey);
                if (!isNaN(c1.q)) potentialTargetableTiles.add(getTileKey(c1.q, c1.r));
                if (!isNaN(c2.q)) potentialTargetableTiles.add(getTileKey(c2.q, c2.r));
            });

            const potentialTargets = [];
            const addPotentialUnit = (unit, edgeKey = null, tileKey = null) => {
                if (!potentialTargets.some(t => t.unit && t.unit.id === unit.id)) {
                    potentialTargets.push({ unit: unit, edgeKey: edgeKey, tileKeyForTarget: tileKey, isBridgeTarget: false });
                }
            };
            const addPotentialBridge = (edgeKey) => {
                if (!potentialTargets.some(t => t.isBridgeTarget && t.edgeKey === edgeKey)) {
                    potentialTargets.push({ unit: null, edgeKey: edgeKey, tileKeyForTarget: null, isBridgeTarget: true });
                }
            };

            potentialAttackEdges.forEach(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    edge.units.forEach(unit => {
                        if (unit.player !== attackingUnit.player) {
                            addPotentialUnit(unit, edgeKey, null);
                        }
                    });
                    if (edge.bridge && edge.bridgeHp > 0) {
                        addPotentialBridge(edgeKey);
                    }
                }
            });
            potentialTargetableTiles.forEach(tileKey => {
                const tile = gameState.tiles.get(tileKey);
                if (tile && tile.fortifiedByPlayer && tile.fortifiedByPlayer !== attackingUnit.player) {
                    const fortifiedUnit = gameState.units.find(u => u.isFortified && u.position === tileKey);
                    if (fortifiedUnit) {
                        addPotentialUnit(fortifiedUnit, null, tileKey);
                    }
                }
            });
            
            return potentialTargets.filter(targetInfo => {
                if (attackingUnit.isFortified) {
                    return canFortifiedArcherSee(attackingUnit, targetInfo);
                } else { 
                    return canEdgeArcherSee(attackingUnit, targetInfo);
                }
            });
        }


        function handleAttackAction() {
            if (gameState.gameMode === 'singleplayer' && gameState.selectedUnit && gameState.selectedUnit.player !== gameState.playerSide) return;
            if (gameState.isDragging) return; 
            const { selectedUnit } = gameState;
            
            if (gameState.currentActionState === ACTION_STATES.SELECTING_ATTACK_TARGET) {
                 resetActionSelectionStates(); 
                 showInstruction("Attack cancelled.", 1500); 
                 updateSelectedUnitInfoPanel(); 
                 return;
            }

             if (!selectedUnit || selectedUnit.currentMove < ATTACK_COST || selectedUnit.hasPerformedMajorAction) {
                showInstruction(selectedUnit && selectedUnit.hasPerformedMajorAction ? "Unit acted." : "Cannot attack.", 2500); return;
            }

            gameState.debugAttackRangeHighlights = []; 

            if (selectedUnit.type.attackType === 'melee') {
                gameState.validMeleeAttackTargets = getValidMeleeAttackTargets(selectedUnit);
                gameState.debugAttackRangeHighlights = gameState.validMeleeAttackTargets
                    .filter(t => t.edgeKey && !t.isBridgeTarget)
                    .map(t => t.edgeKey);

                if (gameState.validMeleeAttackTargets.length === 0) {
                    showInstruction("No valid melee targets.", 2000);
                } else {
                    gameState.currentActionState = ACTION_STATES.SELECTING_ATTACK_TARGET;
                    showInstruction("Select target to attack.", 3000);
                }
            } else if (selectedUnit.type.attackType === 'ranged') {
                gameState.validArcherAttackTargets = getValidArcherAttackTargets(selectedUnit);
                gameState.debugAttackRangeHighlights = gameState.validArcherAttackTargets
                    .filter(t => t.edgeKey && !t.isBridgeTarget)
                    .map(t => t.edgeKey);

                if (gameState.validArcherAttackTargets.length === 0) {
                    showInstruction("No valid archer targets.", 2000);
                } else {
                    gameState.currentActionState = ACTION_STATES.SELECTING_ATTACK_TARGET;
                    showInstruction("Select target to attack.", 3000);
                }
            }
            updateSelectedUnitInfoPanel();
        }

        function getActionIcon(message) {
            let iconSvg = '';
            const iconColor = '#bdc3c7';

            if (message.includes('hits') || message.includes('takes') || message.includes('targets bridge') || message.includes('retaliates')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m15.2 3.8-3.5 3.5 4.3 4.3 3.5-3.5-4.3-4.3z"/><path d="m4.1 19.9 4.4-4.4"/><path d="M16 16h3v3"/><path d="M10.1 5.5 3 12.6l-1.4 1.4 4.2 4.2 1.4-1.4 7.1-7.1"/><path d="M12.6 3 3 12.6l4.2 4.2 9.6-9.6L12.6 3z"/></svg>`;
            } else if (message.includes('fortified')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>`;
            } else if (message.includes('unfortified')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>`;
            } else if (message.includes('healed') || message.includes('gained a shield')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"></path><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>`;
            } else if (message.includes('destroyed')) {
                 iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="9" cy="12" r="1"></circle><circle cx="15" cy="12" r="1"></circle><path d="M8 20v2h8v-2"></path><path d="m12.5 17.5-1-1-1 1"></path><path d="M16 20a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2"></path><path d="M16 20a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2"></path><path d="M15 2h-1.5a1.5 1.5 0 0 0 0 3h1.5a1.5 1.5 0 0 0 0-3Z"></path><path d="M9 2H7.5a1.5 1.5 0 0 0 0 3H9a1.5 1.5 0 0 0 0-3Z"></path></svg>`;
            } else if (message.includes('built bridge')) {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 8v8m20-8v8M8 4v2m8-2v2M4 12h16"/><path d="M8 10v4m8-4v4"/></svg>`;
            } else {
                iconSvg = `<svg class="log-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="${iconColor}" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22c5.523 0 10-4.477 10-10S17.523 2 12 2 2 6.477 2 12s4.477 10 10 10z"/><path d="m9 12 2 2 4-4"/></svg>`;
            }
            return `<div class="log-icon">${iconSvg}</div>`;
        }

        function updateActionLogDisplay() {
            if (!ui.actionLogContent) return;

            ui.actionLogContent.innerHTML = '';
            
            // REMOVED: The reversal of the log array. We now loop through it directly.
            for (const logObject of gameState.actionLog) {
                const originalMessage = logObject.message;
                const activePlayer = logObject.player;

                let formattedMessage = originalMessage.replace(/<br>/g, ' ');

                formattedMessage = formattedMessage.replace(/(P1)/g, '<strong class="p1-log">$1</strong>');
                formattedMessage = formattedMessage.replace(/(P2)/g, '<strong class="p2-log">$1</strong>');
                formattedMessage = formattedMessage.replace(/(\d+)\s(damage|HP)/g, '<strong class="damage-text">$1</strong> $2');
                formattedMessage = formattedMessage.replace(/(healed\s\d+\sHP)/g, '<span class="heal-text">$1</span>');
                formattedMessage = formattedMessage.replace(/(gained a shield)/g, '<span class="shield-text">$1</span>');
                formattedMessage = formattedMessage.replace(/(Advantage!)/g, '<strong class="advantage-text">$1</strong>');
                formattedMessage = formattedMessage.replace(/(Disadvantage!)/g, '<strong class="disadvantage-text">$1</strong>');
                formattedMessage = formattedMessage.replace(/(Spear Wall|Cavalry Screen|Combined arms|Damage split)/g, '<strong class="keyword-text">$1</strong>');

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-p${activePlayer}`; 
                logEntry.innerHTML = getActionIcon(originalMessage) + `<div class="log-message">${formattedMessage}</div>`;

                ui.actionLogContent.appendChild(logEntry);
            }
        }

        function updateSupplyPointsDisplay() {
            const p1SupplyEl = document.getElementById('p1Supply');
            const p2SupplyEl = document.getElementById('p2Supply');
            if (p1SupplyEl && p2SupplyEl) {
                p1SupplyEl.textContent = gameState.supplyPoints.player1;
                p2SupplyEl.textContent = gameState.supplyPoints.player2;
            }
        }

        function updateSupplyPointsBasedOnFlagStatus(playerNum) {
            const playerFlag = gameState.flags[`p${playerNum}_flag`];
            const playerSupplyKey = `player${playerNum}`;

            if (playerFlag && playerFlag.status === 'carried') {
                // Flag is stolen, set supply to 0.
                gameState.supplyPoints[playerSupplyKey] = 0;
            } else {
                // Flag is at base, restore to max.
                gameState.supplyPoints[playerSupplyKey] = 10;
            }
            updateSupplyPointsDisplay();
        }

function completeAttack(attackingUnit, targetUnitInfo, attackType) {
    if (!attackingUnit || !targetUnitInfo || attackingUnit.currentMove < ATTACK_COST || attackingUnit.hasPerformedMajorAction) {
        showInstruction("Cannot complete attack.", 2000); 
        resetActionSelectionStates(); 
        updateSelectedUnitInfoPanel(); return;
    }
    
    let damageModifier = 0;
    let advantageMessage = "";
    let baseDamage = attackingUnit.type.attack;

    if (targetUnitInfo.unit) {
        const attackerType = attackingUnit.type;
        const defenderType = targetUnitInfo.unit.type;
        if (attackerType.strengths && attackerType.strengths.includes(defenderType.name)) {
            damageModifier = 1;
            advantageMessage = "Advantage!";
        } else if (attackerType.weaknesses && attackerType.weaknesses.includes(defenderType.name)) {
            damageModifier = -1;
            advantageMessage = "Disadvantage!";
        }
    }
    baseDamage += damageModifier;

    let fortifiedArcherMsg = "";
    if (attackType === 'Archer' && attackingUnit.isFortified) { 
        baseDamage += 1; 
        fortifiedArcherMsg = `Fortified Archer +1 Attack.`;
    }
    
    let attackStatus = 'normal';
    if (advantageMessage === "Advantage!") {
        attackStatus = 'advantage';
    } else if (advantageMessage === "Disadvantage!") {
        attackStatus = 'disadvantage';
    }

    const animation = {
        attacker: attackingUnit,
        targetInfo: targetUnitInfo,
        startTime: Date.now(),
        
        onComplete: async () => {
            gameState.playerActionTaken[`player${gameState.currentPlayer}`] = true;
            attackingUnit.hasPerformedMajorAction = true;
            let hitAndRunMessage = "";
            if (attackingUnit.type.canMoveAfterAttack) {
                attackingUnit.currentMove -= ATTACK_COST;
                const spearWallOnAttacker = isEdgeAdjacentToSpearWall(attackingUnit, attackingUnit.position);
                const spearWallOnTarget = targetUnitInfo.edgeKey ? isEdgeAdjacentToSpearWall(attackingUnit, targetUnitInfo.edgeKey) : false;
                if (spearWallOnAttacker || spearWallOnTarget) {
                    hitAndRunMessage = "Spear Wall prevents further movement!";
                    gameState.currentReachableMoves.clear();
                } else if (attackingUnit.currentMove > 0) {
                    hitAndRunMessage = "Horseman can move again!";
                    if (gameState.gameMode !== 'singleplayer' || attackingUnit.player === gameState.playerSide) {
                        gameState.currentReachableMoves = getPossibleMoves(attackingUnit);
                    }
                } else {
                    gameState.currentReachableMoves.clear();
                }
            } else {
                attackingUnit.currentMove = 0;
                gameState.currentReachableMoves.clear();
            }

            let logParts = [];
            if (fortifiedArcherMsg) logParts.push(fortifiedArcherMsg);
            if (advantageMessage) logParts.push(advantageMessage);

            if (targetUnitInfo.isBridgeTarget && targetUnitInfo.edgeKey) {
                const bridgeEdge = gameState.edges.get(targetUnitInfo.edgeKey);
                if (bridgeEdge && bridgeEdge.bridge) {
                    bridgeEdge.bridgeHp -= baseDamage;
                    triggerDamageVisual({ position: targetUnitInfo.edgeKey, isFortified: false }, 'normal');
                    logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} targets bridge for ${baseDamage}.<br>Bridge HP: ${bridgeEdge.bridgeHp}/${BRIDGE_MAX_HP}.`);
                    if (bridgeEdge.bridgeHp <= 0) {
                        logParts.push(`Bridge destroyed!`);
                        bridgeEdge.bridge = false; bridgeEdge.bridgeHp = null;
                        [...bridgeEdge.units].forEach(unitOnCollapse => handleUnitDeath(unitOnCollapse, "bridge_collapse"));
                    }
                } else logParts.push("Target bridge missing.");
            }
            else if (targetUnitInfo.unit) {
                const targetUnit = targetUnitInfo.unit; 
                if (attackingUnit.player !== targetUnit.player) { 
                    targetUnit.lastAttackedByHostileOnTurn = gameState.globalTurnNumber;
                }
                let actualDamage = baseDamage; 
                let defenseMessage = "";
                let pierceMessage = "";

                if (targetUnit.isFortified) {
                    let hasCombinedArmsPartner = false;
                    const edge = gameState.edges.get(attackingUnit.position);
                    if (edge) {
                        if (attackingUnit.type.attackType === 'ranged') hasCombinedArmsPartner = edge.units.some(u => u.id !== attackingUnit.id && u.player === attackingUnit.player && u.type.attackType === 'melee');
                        else if (attackingUnit.type.attackType === 'melee') hasCombinedArmsPartner = edge.units.some(u => u.id !== attackingUnit.id && u.player === attackingUnit.player && u.type.attackType === 'ranged');
                    }
                    if (hasCombinedArmsPartner) {
                        defenseMessage = 'Combined arms negates fortification!';
                    } else {
                        const defenseBonus = targetUnit.type.fortificationBonus || 1;
                        const pierceValue = attackingUnit.type.defenseNegation || 0;
                        if (pierceValue > 0) pierceMessage = `${attackingUnit.type.name} pierces ${pierceValue} defense.`;
                        const effectiveDefense = Math.max(0, defenseBonus - pierceValue);
                        actualDamage = Math.max(0, baseDamage - effectiveDefense);
                        if (effectiveDefense > 0) defenseMessage = `Fortification reduced damage by ${effectiveDefense}.`;
                    }
                }
                if (pierceMessage) logParts.push(pierceMessage);
                if (defenseMessage) logParts.push(defenseMessage);
                
                triggerDamageVisual(targetUnit, attackStatus);

                if (attackType === 'Archer' && targetUnitInfo.edgeKey && actualDamage > 0 && !targetUnit.isFortified) {
                    const edgeOfTarget = gameState.edges.get(targetUnitInfo.edgeKey);
                    const allEnemyUnitsOnEdge = edgeOfTarget ? edgeOfTarget.units.filter(u => u.player === targetUnit.player) : [];
                    if (allEnemyUnitsOnEdge.length === 2) {
                        let splitDamage = Math.max(1, Math.round(actualDamage / 2));
                        logParts.push(`Damage split between 2 units!`);
                        allEnemyUnitsOnEdge.forEach(unitToHit => {
                            unitToHit.hp -= splitDamage;
                            triggerDamageVisual(unitToHit, attackStatus);
                            logParts.push(`P${unitToHit.player} ${unitToHit.type.name} takes ${splitDamage} damage. HP: ${unitToHit.hp}`);
                            if (attackingUnit.player !== unitToHit.player) unitToHit.lastAttackedByHostileOnTurn = gameState.globalTurnNumber;
                            if (unitToHit.hp <= 0) handleUnitDeath(unitToHit);
                        });
                    } else {
                        targetUnit.hp -= actualDamage;
                        logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} hits P${targetUnit.player} ${targetUnit.type.name} for ${actualDamage}.<br>HP: ${targetUnit.hp}/${targetUnit.maxHp}`);
                        if (targetUnit.hp <= 0) handleUnitDeath(targetUnit);
                    }
                } else { 
                    targetUnit.hp -= actualDamage;
                    logParts.push(`P${attackingUnit.player} ${attackingUnit.type.name} hits P${targetUnit.player} ${targetUnit.type.name} for ${actualDamage}.<br>HP: ${targetUnit.hp}/${targetUnit.maxHp}`);
                    if (targetUnit.hp <= 0) handleUnitDeath(targetUnit);
                }
                
                if (targetUnit.type.name === 'Horseman' && attackingUnit.type.attackType === 'melee' && targetUnitInfo.edgeKey) {
                    const edgeOfHorseman = gameState.edges.get(targetUnitInfo.edgeKey);
                    const retaliatingArcher = edgeOfHorseman ? edgeOfHorseman.units.find(u => u.player === targetUnit.player && u.type.name === 'Archer') : null;
                    if (retaliatingArcher) {
                        const retaliationDamage = Math.ceil(retaliatingArcher.type.attack / 2);
                        attackingUnit.hp -= retaliationDamage;
                        triggerDamageVisual(attackingUnit, 'normal');
                        logParts.push(`Cavalry Screen! P${retaliatingArcher.player} ${retaliatingArcher.type.name} retaliates for ${retaliationDamage} damage.<br>Attacker HP: ${attackingUnit.hp}/${attackingUnit.maxHp}`);
                        if (attackingUnit.hp <= 0) handleUnitDeath(attackingUnit, "retaliation");
                    }
                }
            }
            if (hitAndRunMessage) logParts.push(hitAndRunMessage);
            
            logAction(logParts.join('<br>'), gameState.currentPlayer, 4500);

            resetActionSelectionStates(); 
            updateSelectedUnitInfoPanel(); 
            if (!gameState.gameOver) checkVictoryCondition();
        }
    };
    
    if (gameSettings.animationsEnabled) {
        if (attackingUnit.type.attackType === 'melee') {
            animation.type = 'attack_lunge';
            animation.duration = 250;
            animation.target = targetUnitInfo.unit;
            gameState.activeAnimations.push(animation);
        } else if (attackingUnit.type.attackType === 'ranged') {
            let targets = [];
            let maxDistance = 0;

            const edgeOfTarget = targetUnitInfo.edgeKey ? gameState.edges.get(targetUnitInfo.edgeKey) : null;
            const enemyUnitsOnEdge = edgeOfTarget ? edgeOfTarget.units.filter(u => u.player !== attackingUnit.player) : [];

            if (edgeOfTarget && enemyUnitsOnEdge.length === 2 && !targetUnitInfo.unit.isFortified) {
                targets = enemyUnitsOnEdge;
            } else {
                targets.push(targetUnitInfo.unit);
            }
            
            animation.targets = targets;

            const startPos = getUnitScreenPosition(attackingUnit);
            if (startPos) {
                targets.forEach(t => {
                    const targetPos = getUnitScreenPosition(t);
                    if (targetPos) {
                        const distance = pointDistance(startPos, targetPos);
                        if (distance > maxDistance) maxDistance = distance;
                    }
                });
            }
            
            if (maxDistance > 0) {
                const preShotDrawDuration = 150;
                const preShotHoldDuration = 250;
                const travelDuration = maxDistance / PROJECTILE_SPEED_PIXELS_PER_MS;
                
                animation.type = 'attack_projectile';
                animation.duration = preShotDrawDuration + preShotHoldDuration + travelDuration;
                animation.preShotDuration = { draw: preShotDrawDuration, hold: preShotHoldDuration };
                animation.travelDuration = travelDuration;
                
                gameState.activeAnimations.push(animation);
            } else {
                 animation.onComplete();
            }
        } else {
            animation.onComplete();
        }
    } else {
        // Animations are disabled, so execute the result immediately.
        animation.onComplete();
    }
    
    resetActionSelectionStates(); 
    updateSelectedUnitInfoPanel();
}                                                                    

        function handleUnitSelectionClick(x, y) {
            let clickedOnUnit = null;
            for (const unit of gameState.units) {
                if (unit.isFortified && unit.positionType === 'center') {
                    const tile = gameState.tiles.get(unit.position);
                    if (tile) {
                        const {x: tileCenterX, y: tileCenterY} = axialToPixel(tile.q, tile.r);
                        if (Math.sqrt((x - tileCenterX)**2 + (y - tileCenterY)**2) < FORTIFIED_UNIT_DRAW_SIZE * 1.5) {
                             if (unit.player === gameState.currentPlayer) {
    if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) {
        showInstruction(`That is an AI unit.`);
        return true; // Acknowledge the click but do nothing
    }
    clickedOnUnit = unit;
    break;
}
                             else { showInstruction(`Enemy ${unit.type.name} fortified.`); return true; }
                        }
                    }
                }
            }
            if (!clickedOnUnit) {
                 const unitEdgePairs = [];
                 gameState.edges.forEach((edge, edgeKey) => { edge.units.forEach(u => { if (u.positionType === 'edge') unitEdgePairs.push({ unit: u, edge: edge }); }); });
                for (let i = unitEdgePairs.length - 1; i >= 0; i--) {
                    const {unit, edge} = unitEdgePairs[i]; const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    let unitX = mid.x, unitY = mid.y;
                    const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                    const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                    if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                        const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                        const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                        let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                        let perpX = -dy_val / len, perpY = dx_val / len;
                        unitX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                    }
                    if (Math.sqrt((x - unitX)**2 + (y - unitY)**2) < UNIT_CLICK_RADIUS) {
                       if (unit.player === gameState.currentPlayer) {
    if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) {
        showInstruction(`That is an AI unit.`);
        return true; // Acknowledge the click but do nothing
    }
    clickedOnUnit = unit;
    break;
}
                       else { showInstruction(`Enemy ${unit.type.name} on edge.`); return true; }
                    }
                }
            }

            if (clickedOnUnit) {
                if (gameState.selectedUnit && gameState.selectedUnit.id === clickedOnUnit.id) {
                    gameState.selectedUnit = null; 
                    gameState.currentReachableMoves.clear();
                    resetActionSelectionStates(); 
                } else {
                    gameState.selectedUnit = clickedOnUnit;
                    resetActionSelectionStates();
                    
                    const unit = gameState.selectedUnit;
                    const canPhysicallyMove = !unit.isFortified && unit.positionType === 'edge' && unit.currentMove >= 1;
                    const isAllowedToMove = !unit.hasPerformedMajorAction || unit.type.canMoveAfterAttack;

                    if (canPhysicallyMove && isAllowedToMove) {
                        gameState.currentReachableMoves = getPossibleMoves(unit);
                    } else {
                        gameState.currentReachableMoves.clear();
                    }
                }
                updateSelectedUnitInfoPanel(); 
                return true;
            }
            return false;
        }

    
function handleMoveAction(unitToMove, targetEdgeKey, costToMove) {
    gameState.playerActionTaken[`player${gameState.currentPlayer}`] = true;
    // --- PRE-MOVE: Remove unit from old position ---
    if (unitToMove.positionType === 'edge') {
        const oldEdge = gameState.edges.get(unitToMove.position);
        if (oldEdge) oldEdge.units = oldEdge.units.filter(u => u.id !== unitToMove.id);
    }

    // --- UPDATE STATE: Place unit in new position ---
    const finalTargetEdgeData = gameState.edges.get(targetEdgeKey);
    if (!finalTargetEdgeData) { console.error("Target edge for move not found:", targetEdgeKey); return; }
    
    unitToMove.position = targetEdgeKey;
    unitToMove.positionType = 'edge';
    unitToMove.currentMove -= costToMove;
    finalTargetEdgeData.units.push(unitToMove);
    clearDebugPath();

    // --- FLAG CAPTURE LOGIC & EFFECT TRIGGER ---
    const enemyFlag = unitToMove.player === 1 ? gameState.flags.p2_flag : gameState.flags.p1_flag;
    if (enemyFlag.status === 'at_base' && targetEdgeKey === enemyFlag.homePosition) {
        enemyFlag.status = 'carried';
        enemyFlag.carrierId = unitToMove.id;
        unitToMove.isCarryingFlag = true;
        unitToMove.currentMove = 0;
        logAction(`P${unitToMove.player} ${unitToMove.type.name} has picked up the flag!`, gameState.currentPlayer);
        updateAllHealingStatus();
        severSupplyLinesForPlayer(enemyFlag.player);

        // Set supply points to 0 for the player whose flag was stolen
        updateSupplyPointsBasedOnFlagStatus(enemyFlag.player);

        // --- CREATE THE STARBURST EFFECT ---
        const unitPos = getUnitScreenPosition(unitToMove);
        if (unitPos) {
            gameState.visualEffects.push({
                type: 'flag_capture_burst',
                x: unitPos.x,
                y: unitPos.y,
                // --- FIX #2 & #3: Use the OPPOSING player's color and add a delay ---
                player: enemyFlag.player, // Color of the flag being stolen
                startTime: Date.now(),
                duration: 500 // Shorter duration for a snappier effect
            });
        }
        // --- END OF EFFECT CREATION ---
    }
    
    // --- CHECK FOR VICTORY & POST-MOVE LOGIC ---
    if (checkVictoryCondition()) {
        return; 
    }

    const unitDestroyedByZoC = applyFortificationDamageOnMove(unitToMove, targetEdgeKey);
    
    if (!unitDestroyedByZoC && unitToMove.hp > 0) {
        logAction(`${unitToMove.type.name} moved. MP: ${Math.floor(unitToMove.currentMove)}`, gameState.currentPlayer);
        if (unitToMove.currentMove >= 1 && (!unitToMove.hasPerformedMajorAction || unitToMove.type.canMoveAfterAttack)) {
            if (gameState.gameMode !== 'singleplayer' || unitToMove.player === gameState.playerSide) {
                 gameState.currentReachableMoves = getPossibleMoves(unitToMove);
            }
        } else {
            gameState.currentReachableMoves.clear();
        }
    } else {
         gameState.currentReachableMoves.clear();
    }

    updateSelectedUnitInfoPanel();
}

function handleMoveClick(x, y) {
    const { selectedUnit } = gameState;
    if (!selectedUnit || selectedUnit.isFortified || selectedUnit.currentMove < 1) {
        return false;
    }
    // CRITICAL FIX: Prevent human from moving AI units.
    if (gameState.gameMode === 'singleplayer' && selectedUnit.player !== gameState.playerSide) {
        return false;
    }
            if (selectedUnit.hasPerformedMajorAction && !selectedUnit.type.canMoveAfterAttack) {
                return false;
            }
            for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) {
                    const costToMove = moveData.cost;
                    if (finalTargetEdgeData.units.some(u => u.player !== selectedUnit.player)) { showInstruction("Cannot move to enemy edge."); return true; }
                    if (finalTargetEdgeData.units.filter(u => u.player === selectedUnit.player).length >= 2) { showInstruction("Target edge full."); return true; }
                    if (costToMove <= selectedUnit.currentMove && costToMove !== Infinity) handleMoveAction(selectedUnit, targetEdgeKey, costToMove);
                    else showInstruction(`Cannot move. Cost: ${costToMove.toFixed(1)}, Have: ${selectedUnit.currentMove.toFixed(1)}`);
                    return true;
                }
            }
             return false;
        }

function handleActionTargetSelectionClick(x, y) {
    const { selectedUnit, currentActionState } = gameState;
    if (!selectedUnit) return false;

    let clickHandled = true;
    let clickedValidTarget = false;

    switch (currentActionState) {
        case ACTION_STATES.SELECTING_FORTIFY_TILE:
            const clickedAxial = pixelToAxial(x, y);
            const clickedTileKey = getTileKey(clickedAxial.q, clickedAxial.r);
            if (gameState.validFortifyTargetTileKeys.includes(clickedTileKey)) {
                completeFortify(selectedUnit, clickedTileKey);
                clickedValidTarget = true;
            }
            break;

        case ACTION_STATES.SELECTING_UNFORTIFY_EDGE:
            for (const edgeKey of gameState.validUnfortifyTargetEdgeKeys) {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) {
                        completeUnfortify(selectedUnit, edgeKey);
                        clickedValidTarget = true;
                        break;
                    }
                }
            }
            break;

        case ACTION_STATES.SELECTING_BRIDGE_EDGE:
            for (const edgeKey of gameState.validBridgeTargetEdgeKeys) {
                const edge = gameState.edges.get(edgeKey);
                if (edge) {
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) {
                        completeBuildBridge(edgeKey);
                        clickedValidTarget = true;
                        break;
                    }
                }
            }
            break;
        
        case ACTION_STATES.SELECTING_ATTACK_TARGET:
            const currentAttackTargets = selectedUnit.type.attackType === 'melee' 
                ? gameState.validMeleeAttackTargets 
                : gameState.validArcherAttackTargets;
            const attackType = selectedUnit.type.attackType === 'melee' ? 'Melee' : 'Archer';

            for (const targetInfo of currentAttackTargets) {
                if (targetInfo.isBridgeTarget && targetInfo.edgeKey) {
                    const edge = gameState.edges.get(targetInfo.edgeKey);
                    if (edge && edge.bridge) {
                        const p = { x, y };
                        const p1_center = axialToPixel(edge.q1, edge.r1); const p2_center = axialToPixel(edge.q2, edge.r2);
                        const edgeMidX = (p1_center.x + p2_center.x) / 2; const edgeMidY = (p1_center.y + p2_center.y) / 2;
                        let perp_dx = -(p2_center.y - p1_center.y); let perp_dy = p2_center.x - p1_center.x;
                        const len_perp_vec = Math.sqrt(perp_dx * perp_dx + perp_dy * perp_dy);

                        if (len_perp_vec > 0) {
                            const scale = HEX_SIZE / 2;
                            perp_dx = (perp_dx / len_perp_vec) * scale;
                            perp_dy = (perp_dy / len_perp_vec) * scale;
                            const v = { x: edgeMidX + perp_dx, y: edgeMidY + perp_dy };
                            const w = { x: edgeMidX - perp_dx, y: edgeMidY - perp_dy };

                            if (distToSegmentSquared(p, v, w) < (BRIDGE_CLICK_TOLERANCE * 2)**2) {
                                completeAttack(selectedUnit, targetInfo, attackType);
                                clickedValidTarget = true;
                                break;
                            }
                        }
                    }
                } else if (targetInfo.unit) {
                    const targetUnit = targetInfo.unit; let unitX_val, unitY_val, clickRadius = UNIT_CLICK_RADIUS;
                    if (targetUnit.isFortified && targetUnit.positionType === 'center' && targetInfo.tileKeyForTarget) {
                        const tile = gameState.tiles.get(targetInfo.tileKeyForTarget);
                        if (tile) { const centerPixel = axialToPixel(tile.q, tile.r); unitX_val = centerPixel.x; unitY_val = centerPixel.y; clickRadius = FORTIFIED_UNIT_DRAW_SIZE * 1.5; }
                        else continue;
                    } else if (targetInfo.edgeKey) {
                        const edgeOfTarget = gameState.edges.get(targetInfo.edgeKey); if (!edgeOfTarget) continue;
                        const mid = getEdgeMidpoint(edgeOfTarget.q1, edgeOfTarget.r1, edgeOfTarget.q2, edgeOfTarget.r2); unitX_val = mid.x; unitY_val = mid.y;
                        const edgeUnitsOnly = edgeOfTarget.units.filter(u => u.positionType === 'edge');
                        const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === targetUnit.id);
                        if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                            const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                            const p1 = axialToPixel(edgeOfTarget.q1, edgeOfTarget.r1); const p2 = axialToPixel(edgeOfTarget.q2, edgeOfTarget.r2);
                            let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                            let perpX = -dy_val / len, perpY = dx_val / len;
                            unitX_val += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitY_val += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                        }
                    } else continue;
                    if (Math.sqrt((x - unitX_val)**2 + (y - unitY_val)**2) < clickRadius) { 
                        completeAttack(selectedUnit, targetInfo, attackType); 
                        clickedValidTarget = true; 
                        break; 
                    }
                }
            }
            if (clickedValidTarget) break; 
            break; 

        default:
            clickHandled = false;
            break;
    }

    if (clickHandled && !clickedValidTarget) {
        showInstruction("Invalid selection. Click a highlighted target or Cancel.", 2000);
    }
    return clickHandled;
}

        // --- REFACTORED GENERIC EVENT HANDLERS ---
        function handleInteractionStart(x, y, isTouchEvent = false) {
            if (gameState.gameOver || gameState.currentActionState !== ACTION_STATES.IDLE && gameState.currentActionState !== ACTION_STATES.UNIT_SELECTED) return;

            dragOperationJustConcluded = false; 
            clearDebugPath();
            
            gameState.dragStartX = x; 
            gameState.dragStartY = y; 
            gameState.draggedDistance = 0;

            let unitToDrag = null;
            const clickRadius = isTouchEvent ? UNIT_CLICK_RADIUS * 1.5 : UNIT_CLICK_RADIUS;
            const edgeUnits = [];
            gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
            
            for (let i = edgeUnits.length - 1; i >= 0; i--) {
                 const {unit, edge} = edgeUnits[i];
                 if (unit.player !== gameState.currentPlayer) continue;
if (gameState.gameMode === 'singleplayer' && unit.player !== gameState.playerSide) continue; // Cannot drag AI units
if (unit.isFortified || unit.currentMove < 1) continue;
                 if (unit.hasPerformedMajorAction && !unit.type.canMoveAfterAttack) continue;
                 
                 const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                 let unitCenterX = mid.x, unitCenterY = mid.y;
                 const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                 const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                 if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                    const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                    const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                    let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                    let perpX = -dy_val / len, perpY = dx_val / len;
                    unitCenterX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitCenterY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                 }
                 if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < clickRadius) { 
                     unitToDrag = unit; 
                     break; 
                 }
            }

            if (unitToDrag) {
                gameState.isDragging = true; 
                gameState.dragStartTime = Date.now();
                gameState.draggingUnit = unitToDrag;
                gameState.dragUnitOriginalPosition = unitToDrag.position; 
                gameState.dragUnitOriginalType = unitToDrag.positionType;
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                
                if (!gameState.selectedUnit || gameState.selectedUnit.id !== unitToDrag.id) {
                    gameState.selectedUnit = unitToDrag;
                    gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                    updateSelectedUnitInfoPanel();
                }
                
                gameState.currentReachableMoves = getPossibleMoves(unitToDrag);
                
                if (unitToDrag.positionType === 'edge') {
                    const edgeData = gameState.edges.get(unitToDrag.position);
                    if (edgeData) edgeData.units = edgeData.units.filter(u => u.id !== unitToDrag.id);
                }
                canvas.style.cursor = 'grabbing'; 
            }
        }
        
        function handleInteractionMove(x, y) {
             if (gameState.isDragging && gameState.draggingUnit) {
                gameState.dragUnitRenderX = x; 
                gameState.dragUnitRenderY = y;
                gameState.draggedDistance = Math.sqrt((x - gameState.dragStartX)**2 + (y - gameState.dragStartY)**2);
                
                let foundPathUnderCursor = null;
                for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                     const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                     const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                     if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < HIGHLIGHT_CLICK_RADIUS) { 
                        foundPathUnderCursor = moveData.path; 
                        break; 
                    }
                 }

                if (foundPathUnderCursor) {
                    const newPotentialPathKey = foundPathUnderCursor.join('-');
                    const currentPotentialPathKey = gameState.potentialDebugPathToDraw ? gameState.potentialDebugPathToDraw.join('-') : null;

                    if (newPotentialPathKey !== currentPotentialPathKey) {
                        gameState.potentialDebugPathToDraw = foundPathUnderCursor;
                        gameState.debugPathHoverStartTime = Date.now();
                        if (gameState.debugPathToDraw && gameState.debugPathToDraw.join('-') !== newPotentialPathKey) {
                            clearDebugPath(); 
                        }
                    }
                } else { 
                    if (gameState.potentialDebugPathToDraw) {
                       clearDebugPath(); 
                    }
                }
            }
        }

        function handleInteractionEnd(x, y, isTouchEvent = false) {
            if (!gameState.isDragging || !gameState.draggingUnit) return;
            
            dragOperationJustConcluded = true;
            let droppedOnValidTarget = false;
            
            if (gameState.draggedDistance >= DRAGGED_DISTANCE_THRESHOLD) {
                const dropRadius = isTouchEvent ? HIGHLIGHT_CLICK_RADIUS * 1.2 : HIGHLIGHT_CLICK_RADIUS;
                for (const [targetEdgeKey, moveData] of gameState.currentReachableMoves) {
                    const finalTargetEdgeData = gameState.edges.get(targetEdgeKey); if (!finalTargetEdgeData) continue;
                    const mid = getEdgeMidpoint(finalTargetEdgeData.q1, finalTargetEdgeData.r1, finalTargetEdgeData.q2, finalTargetEdgeData.r2);
                    if (Math.sqrt((x - mid.x)**2 + (y - mid.y)**2) < dropRadius) {
                        const costToMove = moveData.cost; 
                        if (finalTargetEdgeData.units.some(u => u.player !== gameState.draggingUnit.player)) { showInstruction("Cannot move to enemy edge."); break; }
                        if (finalTargetEdgeData.units.filter(u => u.player === gameState.draggingUnit.player).length >= 2) { showInstruction("Target edge full."); break; }
                        if (costToMove <= gameState.draggingUnit.currentMove && costToMove !== Infinity) { 
                            handleMoveAction(gameState.draggingUnit, targetEdgeKey, costToMove); 
                            droppedOnValidTarget = true; 
                        }
                        else { showInstruction(`Cannot move. Cost: ${costToMove.toFixed(1)}, Have: ${gameState.draggingUnit.currentMove.toFixed(1)}`); }
                        break;
                    }
                }
            }
            
            if (!droppedOnValidTarget) {
                 const unit = gameState.draggingUnit;
                if (unit) {
                    if (gameState.dragUnitOriginalType === 'edge' && gameState.dragUnitOriginalPosition) {
                         const originalEdge = gameState.edges.get(gameState.dragUnitOriginalPosition);
                         if (originalEdge && !originalEdge.units.find(u => u.id === unit.id)) originalEdge.units.push(unit);
                         unit.position = gameState.dragUnitOriginalPosition; unit.positionType = 'edge';
                     }
                     if (gameState.draggedDistance >= DRAGGED_DISTANCE_THRESHOLD) showInstruction("Invalid drop. Unit returned.", 2000);
                     gameState.selectedUnit = unit;
                     gameState.currentActionState = ACTION_STATES.UNIT_SELECTED; 
                      if(unit && !unit.isFortified && unit.hp > 0 && !unit.hasPerformedMajorAction && unit.currentMove >=1) gameState.currentReachableMoves = getPossibleMoves(unit);
                      else gameState.currentReachableMoves.clear();
                }
            }
            
            gameState.isDragging = false; 
            gameState.dragStartTime = null;
            gameState.draggingUnit = null; 
            gameState.dragUnitOriginalPosition = null; 
            gameState.dragUnitOriginalType = null;
            clearDebugPath(); 
            canvas.style.cursor = gameState.hoveredUnitId ? 'pointer' : 'default'; 
            updateSelectedUnitInfoPanel(); 
        }

        function handleInteractionCancel() {
            dragOperationJustConcluded = true;
            clearDebugPath();
            if (gameState.isDragging && gameState.draggingUnit) {
                 const unit = gameState.draggingUnit;
                 if (gameState.dragUnitOriginalType === 'edge' && gameState.dragUnitOriginalPosition) {
                     const originalEdge = gameState.edges.get(gameState.dragUnitOriginalPosition);
                     if (originalEdge && !originalEdge.units.find(u => u.id === unit.id)) originalEdge.units.push(unit);
                     unit.position = gameState.dragUnitOriginalPosition; unit.positionType = 'edge';
                 }
                gameState.isDragging = false; 
                gameState.dragStartTime = null;
                gameState.draggingUnit = null; 
                gameState.dragUnitOriginalPosition = null; 
                gameState.dragUnitOriginalType = null;
                showInstruction("Drag cancelled. Unit returned.", 2500);
                gameState.selectedUnit = unit; 
                gameState.currentActionState = ACTION_STATES.UNIT_SELECTED;
                if(unit && !unit.isFortified && unit.hp > 0 && !unit.hasPerformedMajorAction && unit.currentMove >=1) gameState.currentReachableMoves = getPossibleMoves(unit);
                else gameState.currentReachableMoves.clear();
                updateSelectedUnitInfoPanel();
            }
        }
        
        function handleTapLogic(x, y) {
            if (handleActionTargetSelectionClick(x, y)) { /* Action target click handled */ } 
            else if (handleUnitSelectionClick(x,y)) { /* Unit selection/deselection handled */ }
            else if (handleMoveClick(x, y)) { /* Click-to-move handled */ } 
            else if (gameState.selectedUnit) {
                 gameState.selectedUnit = null; 
                 gameState.currentReachableMoves.clear();
                 resetActionSelectionStates(); 
                 updateSelectedUnitInfoPanel(); 
            }
        }

        // --- Original Event Handlers (Now as Wrappers) ---
        function handleCanvasMouseDown(event) {
            if (event.button !== 0) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleInteractionStart(x, y, false);
        }

        function handleCanvasMouseMove(event) {
            if (gameState.gameOver) return;
            const rect = canvas.getBoundingClientRect(); 
            const x = event.clientX - rect.left; 
            const y = event.clientY - rect.top;

            if (gameState.isDragging) {
                event.preventDefault();
                handleInteractionMove(x, y);
            } else {
                let foundHoverable = false; let newHoveredUnitId = null; const edgeUnits = [];
                gameState.edges.forEach(edge => edge.units.forEach(u => { if (u.positionType === 'edge') edgeUnits.push({unit:u, edge}); }));
                for(let i = edgeUnits.length -1; i >= 0; i--) {
                    const {unit, edge} = edgeUnits[i]; if (unit.player !== gameState.currentPlayer) continue;
                    const mid = getEdgeMidpoint(edge.q1, edge.r1, edge.q2, edge.r2);
                    let unitCenterX = mid.x, unitCenterY = mid.y;
                    const edgeUnitsOnly = edge.units.filter(u => u.positionType === 'edge');
                    const unitIndexOnEdge = edgeUnitsOnly.findIndex(u => u.id === unit.id);
                    if (edgeUnitsOnly.length > 1 && unitIndexOnEdge !== -1) {
                        const offsetSign = (unitIndexOnEdge % 2 === 0) ? -1 : 1;
                        const p1 = axialToPixel(edge.q1, edge.r1); const p2 = axialToPixel(edge.q2, edge.r2);
                        let dx_val = p2.x - p1.x, dy_val = p2.y - p1.y; const len = Math.sqrt(dx_val*dx_val + dy_val*dy_val) || 1;
                        let perpX = -dy_val / len, perpY = dx_val / len;
                        unitCenterX += perpX * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5); unitCenterY += perpY * UNIT_ON_EDGE_OFFSET * offsetSign * (0.5);
                    }
                    if (Math.sqrt((x - unitCenterX)**2 + (y - unitCenterY)**2) < UNIT_CLICK_RADIUS) { newHoveredUnitId = unit.id; foundHoverable = true; break; }
                }
                 if (!foundHoverable) {
                     for (const unit of gameState.units) {
                         if (unit.isFortified && unit.positionType === 'center' && unit.player === gameState.currentPlayer) {
                             const tile = gameState.tiles.get(unit.position);
                             if (tile) {
                                 const {x: tileCenterX, y: tileCenterY} = axialToPixel(tile.q, tile.r);
                                 if (Math.sqrt((x - tileCenterX)**2 + (y - tileCenterY)**2) < FORTIFIED_UNIT_DRAW_SIZE * 1.5) { newHoveredUnitId = unit.id; foundHoverable = true; break; }
                             }
                         }
                     }
                 }
                if (gameState.hoveredUnitId !== newHoveredUnitId) gameState.hoveredUnitId = newHoveredUnitId;
                canvas.style.cursor = foundHoverable ? 'pointer' : 'default';
            }
        }

        function handleCanvasMouseUp(event) {
            if (gameState.gameOver || !gameState.isDragging) return;
            const rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            handleInteractionEnd(x, y, false);
        }

        function handleCanvasMouseLeave(event) {
            handleInteractionCancel();
            if (gameState.hoveredUnitId !== null) gameState.hoveredUnitId = null;
            canvas.style.cursor = 'default';
        }

        function handleCanvasTouchStart(event) {
            if (gameState.gameOver || event.touches.length !== 1) return;
            event.preventDefault();
            const touch = event.touches[0]; 
            const rect = canvas.getBoundingClientRect();
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            handleInteractionStart(x, y, true);
        }

        function handleCanvasTouchMove(event) {
            if (gameState.isDragging && gameState.draggingUnit && event.touches.length === 1) {
                event.preventDefault();
                const touch = event.touches[0]; 
                const rect = canvas.getBoundingClientRect();
                const x = touch.clientX - rect.left;
                const y = touch.clientY - rect.top;
                handleInteractionMove(x, y);
            }
        }

        function handleCanvasTouchEnd(event) {
            if (gameState.gameOver) return;
            const finalTouch = event.changedTouches[0]; 
            if (!finalTouch) return;
            
            const rect = canvas.getBoundingClientRect();
            const x = finalTouch.clientX - rect.left;
            const y = finalTouch.clientY - rect.top;

            const wasDragging = gameState.isDragging;
            const wasShortDrag = gameState.draggedDistance < DRAGGED_DISTANCE_THRESHOLD;

            if (wasDragging) {
                handleInteractionEnd(x, y, true);
            }
            
            if (!wasDragging || wasShortDrag) {
                handleTapLogic(x, y);
            }
            
            gameState.draggedDistance = 0;
            updateSelectedUnitInfoPanel();
        }

        function handleCanvasTouchCancel(event) {
            handleInteractionCancel();
            gameState.draggedDistance = 0;
        }

        function handleCanvasClick(event) {
            if (gameState.gameOver || event.button !== 0) return;
            if (dragOperationJustConcluded) { 
                dragOperationJustConcluded = false; 
                return; 
            }
            const rect = canvas.getBoundingClientRect(); 
            const x = event.clientX - rect.left; 
            const y = event.clientY - rect.top;
            handleTapLogic(x, y);
        }

        // --- Zone of Control Damage & Healing ---
        function applyStartOfTurnZoCDamage() {
            const activePlayer = gameState.currentPlayer;
            const enemyPlayer = activePlayer === 1 ? 2 : 1;
            let unitsToDestroy = [];

            // Get the active player's base camp tiles to apply damage to the enemy
            const activePlayerBaseEdgeKey = FLAG_HOME_POSITIONS[`player${activePlayer}`];
            const activePlayerBaseTiles = [activePlayerBaseEdgeKey.split('_')[0], activePlayerBaseEdgeKey.split('_')[1]];

            gameState.units.forEach(unit => {
                // We are checking for enemy units adjacent to the current player's forts/base
                if (unit.player !== enemyPlayer || unit.positionType !== 'edge' || unit.isFortified) return;
                
                const edgeKey = unit.position;
                const edgeTileCoords = parseEdgeKey(edgeKey);
                if (edgeTileCoords.some(coord => isNaN(coord.q))) return;
        
                const tile1Key = getTileKey(edgeTileCoords[0].q, edgeTileCoords[0].r);
                const tile2Key = getTileKey(edgeTileCoords[1].q, edgeTileCoords[1].r);
                const tile1 = gameState.tiles.get(tile1Key);
                const tile2 = gameState.tiles.get(tile2Key);
                
                // Check for damage from a standard fort OR from the active player's base camp fort effect
                if ((tile1 && tile1.fortifiedByPlayer === activePlayer) || 
                    (tile2 && tile2.fortifiedByPlayer === activePlayer) ||
                    activePlayerBaseTiles.includes(tile1Key) || 
                    activePlayerBaseTiles.includes(tile2Key)) 
                {
                    unit.hp -= FORTIFICATION_DAMAGE;
                    // Correctly log that the action happened during the ACTIVE player's turn
                    logAction(`P${unit.player} ${unit.type.name} takes start-of-turn ZoC. HP: ${unit.hp}`, activePlayer, 3500);
                    if (unit.hp <= 0 && !unitsToDestroy.find(u => u.id === unit.id)) {
                        unitsToDestroy.push(unit);
                    }
                }
            });

            if (unitsToDestroy.length > 0) unitsToDestroy.forEach(u => handleUnitDeath(u, "zoc_turn_start"));
        }

        function updateAllHealingStatus() {
            // Check flag status for both players
            const p1FlagStolen = gameState.flags.p1_flag.status === 'carried';
            const p2FlagStolen = gameState.flags.p2_flag.status === 'carried';

            gameState.units.forEach(unit => {
                if (unit.isFortified) {
                    if (unit.player === 1) {
                        unit.canHeal = !p1FlagStolen;
                    } else { // unit.player === 2
                        unit.canHeal = !p2FlagStolen;
                    }
                } else {
                    unit.canHeal = false; // Unfortified units can't heal anyway
                }
            });
            // Let players know what happened
            if (p1FlagStolen) { logAction(`P1's flag is stolen! Healing is disabled.`, 2, 3000); }
            if (p2FlagStolen) { logAction(`P2's flag is stolen! Healing is disabled.`, 1, 3000); }
        }

function applyStartOfTurnHealing() {
    const playerFlag = gameState.flags[`p${gameState.currentPlayer}_flag`];
    if (playerFlag.status === 'carried') {
        return; // No healing for anyone if their flag is stolen.
    }

    gameState.units.forEach(unit => {
        if (unit.player !== gameState.currentPlayer || !unit.isFortified || unit.hp >= (unit.maxHp + 1)) {
            return;
        }

        const recentlyAttacked = gameState.globalTurnNumber < unit.lastAttackedByHostileOnTurn + 2;
        if (recentlyAttacked) {
            return;
        }
        
        let isSupplied = false;
        const playerBaseTiles = [FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
        
        if (playerBaseTiles.includes(unit.fortifiedTileKey)) {
            isSupplied = true;
        } else if (unit.supplyLine && unit.supplyLine.path) {
            const isIntercepted = unit.supplyLine.path.some(edgeKey => {
                const edge = gameState.edges.get(edgeKey);
                return edge && edge.units.some(u => u.player !== unit.player);
            });
            if (!isIntercepted) {
                isSupplied = true;
            }
        }

        if (isSupplied) {
            const oldHp = unit.hp;
            unit.hp++;
            const activePlayer = gameState.currentPlayer;
            if (oldHp < unit.maxHp && unit.hp === unit.maxHp) {
                logAction(`P${unit.player} ${unit.type.name} healed to full HP.`, activePlayer, 2500);
            } else if (unit.hp === unit.maxHp + 1) {
                logAction(`P${unit.player} ${unit.type.name} gained a shield!`, activePlayer, 2500);
                
                // --- TRIGGER SHIELD EFFECT ---
                let targetX, targetY, targetRadius;
                const tile = gameState.tiles.get(unit.position);
                if (tile) { // The unit must be fortified to heal, so it will be on a tile
                    const center = axialToPixel(tile.q, tile.r);
                    targetX = center.x;
                    targetY = center.y;
                    targetRadius = FORTIFIED_UNIT_DRAW_SIZE;

                    gameState.visualEffects.push({
                        type: 'shield_ring',
                        x: targetX, y: targetY,
                        unitRadius: targetRadius,
                        startTime: Date.now(),
                        duration: 600 // A slightly longer, more graceful duration
                    });
                }
                // --- END SHIELD EFFECT ---

            } else {
                 logAction(`P${unit.player} ${unit.type.name} healed 1 HP.`, activePlayer, 2500);
            }
        }
    });
}

        function logSiegeStatus() {
            const activePlayer = gameState.currentPlayer;
            const playerFlag = gameState.flags[`p${activePlayer}_flag`];

            if (playerFlag.status === 'carried') {
                const existingLog = gameState.actionLog[gameState.actionLog.length - 1];
                if (!existingLog || !existingLog.message.includes('Healing is disabled')) {
                    logAction(`P${activePlayer}'s flag is stolen! All healing is disabled.`, activePlayer);
                }
            }

            gameState.units.forEach(unit => {
                if (unit.player === activePlayer && unit.isFortified && unit.supplyLine && unit.supplyLine.path) {
                    const isIntercepted = unit.supplyLine.path.some(edgeKey => {
                        const edge = gameState.edges.get(edgeKey);
                        return edge && edge.units.some(u => u.player !== unit.player);
                    });

                    if (isIntercepted) {
                         logAction(`P${unit.player} ${unit.type.name} is under siege and cannot heal!`, activePlayer);
                    }
                }
            });
        }

        function handleRespawnQueue() {
            const player = gameState.currentPlayer;
            const queueKey = `player${player}`;
            const queue = gameState.respawnQueue[queueKey];
    
            if (queue.length === 0) {
                return;
            }

            // Iterate over the entire queue for the current player to decrement all timers.
            queue.forEach(item => {
            if (item.turnsRemaining > 0) { // Only decrement if it's not already ready
                item.turnsRemaining--;
                }
            });

            // After updating all timers, check if the unit at the front of the queue is ready.
            // This preserves the one-at-a-time respawn flow.
            const firstItem = queue[0];
            if (firstItem && firstItem.turnsRemaining <= 0) {
            showRespawnModal(player);
            }
    
            // Always update the display to show the new timer values.
        updateRespawnQueueDisplay();
        }

function triggerConfetti() {
    const container = document.getElementById('confettiContainer');
    if (!container) return;

    const confettiCount = 150;
    const colors = ['#FFC020', '#E04030', '#3090D0', '#2ecc71', '#ecf0f1'];

    for (let i = 0; i < confettiCount; i++) {
        const confettiPiece = document.createElement('div');
        confettiPiece.className = 'confetti-piece';
        
        // Randomize properties
        const x_start = Math.random() * 100; // % of screen width
        const y_start = -10 - Math.random() * 20; // Start off-screen
        const color = colors[Math.floor(Math.random() * colors.length)];
        const fall_duration = 3 + Math.random() * 4; // 3 to 7 seconds
        const rotation_start = Math.random() * 360;
        const rotation_end = rotation_start + 720 + Math.random() * 720;
        const sway = Math.random() * 150 - 75; // a horizontal sway of -75 to +75px

        confettiPiece.style.left = `${x_start}vw`;
        confettiPiece.style.top = `${y_start}px`;
        confettiPiece.style.backgroundColor = color;
        confettiPiece.style.transform = `rotate(${rotation_start}deg)`;
        
        container.appendChild(confettiPiece);

        // Animate using Web Animations API (clean and performant)
        confettiPiece.animate([
            { transform: `translate3d(0, 0, 0) rotate(${rotation_start}deg)` },
            { transform: `translate3d(${sway}px, 105vh, 0) rotate(${rotation_end}deg)` }
        ], {
            duration: fall_duration * 1000,
            easing: 'ease-in',
            iterations: 1
        });

        // Remove the element after it falls
        setTimeout(() => {
            confettiPiece.remove();
        }, fall_duration * 1000);
    }
}

// ========================================================================
// --- COMPLETE AI SYSTEM (VERSION 2.0) ---
// ========================================================================

// AI Brain: Gathers and scores all possible actions for a single unit.
function getUnitAIAction(unit, strategy, allEnemies, allAllies) {
    if (unit.hasPerformedMajorAction) return null;

    let possibleActions = [];

    // --- SUB-FUNCTION to score a potential attack ---
    const scoreAttack = (targetInfo) => {
        let score = 50.0;
        if(targetInfo.unit){
            if(targetInfo.unit.isCarryingFlag) score += 200;
            const predictedDmg = unit.type.attack + (unit.isFortified && unit.type.name === 'Archer' ? 1 : 0);
            if(targetInfo.unit.hp <= predictedDmg) score += 100;
            if(unit.type.strengths.includes(targetInfo.unit.type.name)) score += 25;
            if(unit.type.weaknesses.includes(targetInfo.unit.type.name)) score -= 25;
        } else { score = 5; } // Low score for bridge
        return score;
    };

    // --- SUB-FUNCTION to score a potential move ---
    const scoreMove = (edgeKey) => {
        let moveScore = 5.0; // Base incentive to not just stand still
        const unitPos = getUnitScreenPosition(unit);
        if (!unitPos) return 0;
        
        const moveMidPoint = getEdgeMidpoint(...parseEdgeKey(edgeKey).flatMap(c=>[c.q,c.r]));
        
        // Role-based scoring for the move itself
        if (unit.type.name === 'Pikeman' && strategy === 'IRON_WALL') {
            const centerDist = axialDistance(...edgeKey.split('_')[0].split(',').map(Number), 0, 0);
            moveScore += (4 - centerDist) * 5; // Move to the center to form the wall
        } else if (unit.type.name === 'Horseman' && strategy === 'BLITZ') {
            const flankTarget = allEnemies.find(e => e.type.name === 'Archer' || e.type.name === 'Melee');
            if(flankTarget) {
                const targetPos = getUnitScreenPosition(flankTarget);
                const currentDist = pointDistance(unitPos, targetPos);
                const afterDist = pointDistance(moveMidPoint, targetPos);
                if(afterDist < currentDist) moveScore += (1 - (afterDist / currentDist)) * 40;
            }
        } else { // Generic advance for others
             const closestEnemy = allEnemies[0];
             if(closestEnemy){
                const targetPos = getUnitScreenPosition(closestEnemy);
                const currentDist = pointDistance(unitPos, targetPos);
                const afterDist = pointDistance(moveMidPoint, targetPos);
                if(afterDist < currentDist) moveScore += (1 - (afterDist / currentDist)) * 20;
             }
        }
        return moveScore;
    };


    // === ACTION GENERATION ===

    // 1. Actions from CURRENT POSITION (no move)
    if (!unit.isFortified) {
        // ATTACK_ONLY
        const attackTargets = getValidMeleeAttackTargets(unit).concat(getValidArcherAttackTargets(unit));
        attackTargets.forEach(targetInfo => {
            possibleActions.push({ type: 'ATTACK_ONLY', unit, targetInfo, score: scoreAttack(targetInfo) });
        });
        // FORTIFY_ONLY
        if (unit.type.canFortify) {
             const edgeCoords = parseEdgeKey(unit.position);
             if (edgeCoords.length === 2 && !isNaN(edgeCoords[0].q)) {
                [getTileKey(edgeCoords[0].q, edgeCoords[0].r), getTileKey(edgeCoords[1].q, edgeCoords[1].r)].forEach(tileKey => {
                    const tile = gameState.tiles.get(tileKey);
                    if(tile && tile.type.canFortify && tile.fortifiedByPlayer === null) {
                         let score = 5 - unit.fortifyCooldown;
                         if(strategy === 'IRON_WALL' && unit.type.name === 'Pikeman') score += 25;
                         if(unit.hp < unit.maxHp) score+=20;
                         if(axialDistance(...tileKey.split(',').map(Number),0,0) > 1) score-= 15;
                         if(score > 0) possibleActions.push({ type: 'FORTIFY_ONLY', unit, targetTileKey: tileKey, score });
                    }
                });
             }
        }
    } else { // Unit is fortified
        // UNFORTIFY_ONLY
        const unfortifyTargets = getPotentialUnfortifyTargets(unit);
        if (unfortifyTargets.length > 0) {
            let score = (unit.hp >= unit.maxHp && unit.turnsFortified > 2) ? (unit.turnsFortified * 5) : 0;
            if(score > 0) possibleActions.push({ type: 'UNFORTIFY_ONLY', unit, targetEdgeKey: unfortifyTargets[0], score });
        }
    }

    // 2. Actions AFTER MOVING
    const possibleMoves = getPossibleMoves(unit);
    possibleMoves.forEach((moveData, edgeKey) => {
        const moveScore = scoreMove(edgeKey);
        const ghostUnit = { ...unit, position: edgeKey, currentMove: unit.currentMove - moveData.cost };

        // MOVE_AND_ATTACK (for Horseman)
        if (ghostUnit.type.name === 'Horseman' && ghostUnit.currentMove >= ATTACK_COST) {
            const attackTargets = getValidMeleeAttackTargets(ghostUnit);
            if (attackTargets.length > 0) {
                const bestTarget = attackTargets.sort((a,b) => scoreAttack(b) - scoreAttack(a))[0];
                const combinedScore = moveScore + scoreAttack(bestTarget);
                possibleActions.push({ type: 'MOVE_AND_ATTACK', unit, moveData, targetInfo: bestTarget, score: combinedScore });
            }
        }
        
        // MOVE_ONLY is always an option
        possibleActions.push({ type: 'MOVE_ONLY', unit, moveData, score: moveScore });
    });
    
    if (possibleActions.length === 0) return null;
    
    // Return the single best action for this unit
    possibleActions.sort((a, b) => b.score - a.score);
    return possibleActions[0];
}


// AI Executor: Takes a chosen action and performs it with animations.
async function executeAIAction(action) {
    if (!action) return;
    console.log(`AI Executing: ${action.type} for ${action.unit.type.name}`, `Score: ${action.score.toFixed(2)}`);
    gameState.selectedUnit = action.unit;
    updateSelectedUnitInfoPanel();
    await delay(400);

    const animateAndMove = async (unit, moveData) => {
        gameState.potentialDebugPathToDraw = moveData.path;
        gameState.debugPathHoverStartTime = Date.now() - PATH_DRAW_HOVER_DELAY_MS;
        await delay(PATH_DRAW_ANIMATION_DURATION_MS + 200);
        handleMoveAction(unit, moveData.path[moveData.path.length - 1], moveData.cost);
    };

    switch (action.type) {
        case 'MOVE_ONLY':
            await animateAndMove(action.unit, action.moveData);
            break;
        case 'ATTACK_ONLY':
            completeAttack(action.unit, action.targetInfo, action.unit.type.attackType === 'melee' ? 'Melee' : 'Archer');
            await delay(800);
            break;
        case 'FORTIFY_ONLY':
            completeFortify(action.unit, action.targetTileKey);
            await delay(600);
            break;
        case 'UNFORTIFY_ONLY':
            completeUnfortify(action.unit, action.targetEdgeKey);
            await delay(700);
            break;
        case 'MOVE_AND_ATTACK':
            await animateAndMove(action.unit, action.moveData);
            await delay(400);
            completeAttack(action.unit, action.targetInfo, action.unit.type.attackType === 'melee' ? 'Melee' : 'Archer');
            await delay(800);
            break;
    }

    gameState.selectedUnit = null;
    updateSelectedUnitInfoPanel();
    await delay(400);
}


// AI Turn Manager: The main loop that commands the AI turn.
async function executeAITurn() {
    if (gameState.gameOver) return;
    console.log(`--- AI Turn ${gameState.globalTurnNumber} (Player ${gameState.currentPlayer}) ---`);

    const aiStrategy = 'IRON_WALL'; // Will be dynamic later
    const allEnemies = gameState.units.filter(u => u.player !== gameState.currentPlayer);
    const allAllies = gameState.units.filter(u => u.player === gameState.currentPlayer);
    
    let unitsToProcess = allAllies.filter(u => !u.hasPerformedMajorAction);

    while (unitsToProcess.length > 0) {
        let bestActionOverall = null;

        for (const unit of unitsToProcess) {
            const bestActionForThisUnit = getUnitAIAction(unit, aiStrategy, allEnemies, allAllies);
            if (bestActionForThisUnit) {
                if (!bestActionOverall || bestActionForThisUnit.score > bestActionOverall.score) {
                    bestActionOverall = bestActionForThisUnit;
                }
            }
        }
        
        if (!bestActionOverall) {
            console.log("AI has no more possible actions.");
            break;
        }

        const actingUnit = bestActionOverall.unit;
        await executeAIAction(bestActionOverall);
        
        // This is the correct way to handle the action attempt.
        actingUnit.hasPerformedMajorAction = true;
        unitsToProcess = unitsToProcess.filter(u => u.id !== actingUnit.id);
    }

    console.log("AI turn finished.");
    if (!gameState.gameOver) {
        ui.endTurnButton.disabled = false;
        ui.endTurnButton.click();
    }
}

        // --- Game Flow & Event Listeners ---
function checkVictoryCondition() {
    if (gameState.gameOver) return true;
    let victoryText = null;

// Check for flag capture victory by iterating through ALL units.
for (const unit of gameState.units) {
    if (unit.isCarryingFlag) {
        const carrierPlayer = unit.player;
        const carrierHomeBaseEdge = FLAG_HOME_POSITIONS[`player${carrierPlayer}`];
        if (unit.position === carrierHomeBaseEdge) {
            victoryText = `Player ${carrierPlayer} captured the flag and wins!`;
            break; // A winner has been found, no need to check further.
        }
    }
}
    
    // If no flag victory, check for annihilation
    if (!victoryText) {
        const player1Units = gameState.units.filter(u => u.player === 1);
        const player2Units = gameState.units.filter(u => u.player === 2);
        
        if (gameState.tiles.size > 0) { 
            if (player1Units.length === 0 && player2Units.length > 0) {
                victoryText = "Player 2 Wins by Annihilation!";
            } else if (player2Units.length === 0 && player1Units.length > 0) {
                victoryText = "Player 1 Wins by Annihilation!";
            } else if (player1Units.length === 0 && player2Units.length === 0) {
                victoryText = "It's a Draw!";
            }
        }
    }

    if (victoryText) {
        ui.victoryMessage.textContent = victoryText;
        ui.victoryMessage.style.display = 'block';
        triggerConfetti();
        gameState.gameOver = true;
        gameState.currentActionState = ACTION_STATES.IDLE;
        ui.endTurnButton.disabled = true;
        document.getElementById('newMapButton').disabled = false; 
        if (gameState.selectedUnit) {
            ui.actionsPanel.style.display = 'none';
        }
        canvas.style.cursor = 'default'; 
        gameState.selectedUnit = null;
        gameState.currentReachableMoves.clear(); 
        updateSelectedUnitInfoPanel();
        return true; // VICTORY!
    }

    // No victory condition met
    document.getElementById('newMapButton').disabled = false;
    return false;
}                                                                       

        ui.fortifyUnfortifyButton.addEventListener('click', handleFortifyUnfortifyButtonClick);
        ui.buildBridgeButton.addEventListener('click', handleBuildBridgeAction);
        ui.attackButton.addEventListener('click', handleAttackAction);

        function proceedToEndTurn() {
            if (gameState.isDragging || gameState.gameOver) return;
    
            const previousPlayer = gameState.currentPlayer;
            // Reset the action flag for the player whose turn just ended.
            gameState.playerActionTaken[`player${previousPlayer}`] = false;

            gameState.currentPlayer = gameState.currentPlayer === 1 ? 2 : 1;
            // Reset the flag for the player whose turn is now STARTING.
            gameState.playerActionTaken[`player${gameState.currentPlayer}`] = false;

            if (previousPlayer === 2 && gameState.currentPlayer === 1) { 
                gameState.globalTurnNumber++;
                updateGlobalTurnDisplay();
            }
            
            gameState.selectedUnit = null; 
            gameState.currentReachableMoves.clear();
            gameState.hoveredUnitId = null; 
            canvas.style.cursor = 'default';
            resetActionSelectionStates();
            
            gameState.units.forEach(unit => {
                if (unit.player === gameState.currentPlayer) {
                    unit.hasPerformedMajorAction = false; 
                    let baseMoveForTurn = unit.type.baseMove;
                    if (unit.isCarryingFlag) {
                        baseMoveForTurn -= 1; 
                    }
                    unit.currentMove = Math.max(0, baseMoveForTurn); 
                    
                    if (unit.isFortified) {
                        unit.turnsFortified++;
                    } else {
                        unit.turnsFortified = 0;
                        if (unit.fortifyCooldown > 0) {
                            unit.fortifyCooldown = Math.max(0, unit.fortifyCooldown - 5);
                        }
                    }

                    const playerBaseTiles = [FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[0], FLAG_HOME_POSITIONS[`player${unit.player}`].split('_')[1]];
                    if (unit.isFortified && playerBaseTiles.includes(unit.fortifiedTileKey)) {
                        unit.turnsFortifiedAtBase++;
                        if (unit.turnsFortifiedAtBase > MAX_BASE_CAMP_TURNS) {
                            logAction(`P${unit.player} ${unit.type.name} was destroyed for cowardice!`, gameState.currentPlayer);
                            handleUnitDeath(unit, "cowardice");
                        }
                    }
                }
            });
            
            handleRespawnQueue();
            applyStartOfTurnZoCDamage(); 
            logSiegeStatus();
            applyStartOfTurnHealing(); 
            updateTurnDisplay();
            updateSelectedUnitInfoPanel(); 
            
            showInstruction(`Player ${gameState.currentPlayer}'s turn.`);
            logAction(`Player ${gameState.currentPlayer}'s Turn Begins`, gameState.currentPlayer);
            autoSaveGame(true);
            checkVictoryCondition();

            if (!gameState.gameOver && gameState.gameMode === 'singleplayer' && gameState.currentPlayer !== gameState.playerSide) {
                ui.endTurnButton.disabled = true;
                setTimeout(() => {
                    executeAITurn();
                }, 1500);
            } else {
                ui.endTurnButton.disabled = false;
            }
        }

ui.endTurnButton.addEventListener('click', () => {
    const playerHasActed = gameState.playerActionTaken[`player${gameState.currentPlayer}`];

    if (playerHasActed || !gameSettings.passTurnConfirmationEnabled || gameState.gameOver) {
        // If the player acted, or the setting is off, or game is over, end turn immediately.
        proceedToEndTurn();
    } else {
        // Otherwise, show the confirmation modal.
        document.getElementById('customConfirmMessage').textContent = 'You have not performed any actions. Are you sure you want to end your turn?';
        currentConfirmAction = proceedToEndTurn; // Set the action to run if "Confirm" is clicked.
        
        if (ui.customConfirmModal) {
            ui.customConfirmModal.style.display = 'flex';
            setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
        }
    }
});

// Replaces the old "Generate Map" button listener
document.getElementById('newMapButton').addEventListener('click', () => {
    const generateButton = document.getElementById('generateMapFromModalButton');
    if (gameState.gameMode === 'singleplayer') {
        generateButton.disabled = true;
    } else {
        generateButton.disabled = false;
    }
    showNewMapModal();
});

// --- New Map Modal Listeners ---
const newMapModalOverlay = document.getElementById('newMapModal');

// Click outside to close
newMapModalOverlay.addEventListener('click', (event) => {
    if (event.target === newMapModalOverlay) {
        hideNewMapModal();
    }
});

// 'x' button to close
document.getElementById('newMapModalCloseButton').addEventListener('click', hideNewMapModal);

// "Generate Map" button inside the modal
document.getElementById('generateMapFromModalButton').addEventListener('click', () => {
    hideNewMapModal();
    // It's good practice to confirm before resetting the game.
    document.getElementById('customConfirmMessage').textContent = 'Are you sure you want to generate a new map? This will reset the current game.';
    currentConfirmAction = handleGenerateNewMap;
    if (ui.customConfirmModal) {
        ui.customConfirmModal.style.display = 'flex';
        setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
    }
});

ui.customConfirmOkButton.addEventListener('click', () => {
    if (ui.customConfirmModal) {
        ui.customConfirmModal.classList.remove('modal-visible');
        setTimeout(() => ui.customConfirmModal.style.display = 'none', 300); 
    }
    // Execute the action that was stored when the modal was opened
    if (typeof currentConfirmAction === 'function') {
        currentConfirmAction();
        currentConfirmAction = null; // Clear the action after using it
    }
});
        ui.customConfirmCancelButton.addEventListener('click', () => {
             if (ui.customConfirmModal) {
                ui.customConfirmModal.classList.remove('modal-visible');
                setTimeout(() => ui.customConfirmModal.style.display = 'none', 300); 
            }
        });

document.getElementById('saveGameButton').addEventListener('click', saveGameToFile);
document.getElementById('loadGameButton').addEventListener('click', showLoadGameModal);

        function handleGenerateNewMap() {
             gameState.isDragging = false; 
             gameState.draggingUnit = null;
            const newLayout = generateImprovedMap(gameState.gridRadius);
            initializeGrid(newLayout); 
            showInstruction("New map generated. Player 1's Turn.", 3000);
        }

function startSingleplayerGame(playerSide) {
    hideAllModals(); // A new helper function we will create
    
    // Set the game mode state
    gameState.gameMode = 'singleplayer';
    gameState.playerSide = playerSide;

    // Force the default map for singleplayer
    initializeGrid(DEFAULT_MAP_LAYOUT_RADIUS_3);
    showInstruction(`Singleplayer game started. You are Player ${playerSide}.`, 3000);
    // If the human chose to be P2, the AI (P1) must take the first turn.
    if (gameState.playerSide === 2) {
        console.log("Player is P2, triggering AI's first turn.");
        ui.endTurnButton.disabled = true; // Disable button during AI turn
        setTimeout(() => {
            executeAITurn();
        }, 1500); // Wait a moment before AI starts
    }
}

function autoSaveGame(isSilent = false) {
    if (gameState.isDragging) {
        showInstruction("Cannot save while dragging a unit.", 2000);
        return;
    }
    try {
        // Create a temporary, serializable version of the game state
        const serializableState = { ...gameState };
        
        // Manually convert Map objects to arrays for JSON compatibility
        serializableState.tiles = Array.from(gameState.tiles.entries());
        serializableState.edges = Array.from(gameState.edges.entries());
        serializableState.currentReachableMoves = Array.from(gameState.currentReachableMoves.entries());

        serializableState.saveVersion = BUILD_VERSION; 

        const gameStateString = JSON.stringify(serializableState);
        const saveKey = gameState.gameMode === 'singleplayer' ? 'forthexSaveGame_sp' : 'forthexSaveGame';
        localStorage.setItem(saveKey, gameStateString);
        if (!isSilent) { showInstruction("Game Saved!", 2000); }
        console.log("Game state saved to localStorage.");
    } catch (error) {
        console.error("Error saving game state:", error);
        showInstruction("Could not save game. See console for details.", 3000);
    }
}

function saveGameToFile() {
    // --- Create the custom filename ---
    const now = new Date();
    const day = padZero(now.getDate());
    const month = padZero(now.getMonth() + 1); // JS months are 0-indexed
    const year = now.getFullYear();
    const hours = padZero(now.getHours());
    const minutes = padZero(now.getMinutes());
    const seconds = padZero(now.getSeconds());
    const modePrefix = gameState.gameMode === 'singleplayer' ? 'SP-' : '';
    const fileName = `FortHex-${BUILD_VERSION}-${modePrefix}SaveGame-${day}.${month}.${year}-${hours}:${minutes}:${seconds}.fhsave`;

    try {
        // --- Serialize the game state (same as autosave) ---
        const serializableState = { ...gameState };
        serializableState.tiles = Array.from(gameState.tiles.entries());
        serializableState.edges = Array.from(gameState.edges.entries());
        serializableState.currentReachableMoves = Array.from(gameState.currentReachableMoves.entries());
        serializableState.saveVersion = BUILD_VERSION;
        const gameStateString = JSON.stringify(serializableState, null, 2); // Using indentation for readability

        // --- Trigger the file download ---
        const blob = new Blob([gameStateString], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        showInstruction("Save file downloaded!", 2500);

    } catch (error) {
        console.error("Error saving game to file:", error);
        showInstruction("Could not create save file. See console.", 3000);
    }
}

function showLoadGameModal() {
const modal = document.getElementById('loadGameModal');
if (modal) {
modal.style.display = 'flex';
setTimeout(() => modal.classList.add('modal-visible'), 10);
}
}

function hideLoadGameModal() {
const modal = document.getElementById('loadGameModal');
if (modal) {
modal.classList.remove('modal-visible');
setTimeout(() => modal.style.display = 'none', 300);
}
}

function hideAllModals() {
    document.querySelectorAll('.modal-overlay').forEach(modal => {
        modal.classList.remove('modal-visible');
        setTimeout(() => modal.style.display = 'none', 300);
    });
}

function showNewMapModal() {
const modal = document.getElementById('newMapModal');
if (modal) {
modal.style.display = 'flex';
setTimeout(() => modal.classList.add('modal-visible'), 10);
}
}

function hideNewMapModal() {
const modal = document.getElementById('newMapModal');
if (modal) {
modal.classList.remove('modal-visible');
setTimeout(() => modal.style.display = 'none', 300);
}
}

function loadAutoSave() {
    const saveKey = gameState.gameMode === 'singleplayer' ? 'forthexSaveGame_sp' : 'forthexSaveGame';
    const savedStateString = localStorage.getItem(saveKey);
    if (!savedStateString) {
        showInstruction("No saved game found.", 2000);
        return;
    }

    try {
        const loadedState = JSON.parse(savedStateString);

        // Basic version check
        if (loadedState.saveVersion !== BUILD_VERSION) {
            showInstruction("Save file is from an incompatible version.", 3000);
            return;
        }
        
        // Overwrite the entire game state
        gameState = loadedState;
        
        // Re-link all the data structures
        rehydrateGameState();

        // Perform a full re-initialization from the loaded state
        fullGameRedraw();
        showInstruction("Game Loaded.", 2000);
        console.log("Game state loaded from localStorage.");

    } catch (error) {
        console.error("Error loading game state:", error);
        showInstruction("Could not load save data. It may be corrupted.", 3000);
    }
}

        function rehydrateGameState() {
            // Converts loaded data from simple arrays back into live objects/maps
            gameState.tiles = new Map(gameState.tiles);
            gameState.edges = new Map(gameState.edges);
            gameState.currentReachableMoves = gameState.currentReachableMoves ? new Map(gameState.currentReachableMoves) : new Map();

            for (const tile of gameState.tiles.values()) {
                if (tile.type && tile.type.name) {
                    tile.type = TILE_TYPES[tile.type.name.toUpperCase()];
                }
            }
            for (const unit of gameState.units) {
                if (unit.type && unit.type.name) {
                    unit.type = UNIT_TYPES[unit.type.name.toUpperCase()];
                }
            }
            for (const edge of gameState.edges.values()) {
                edge.units = [];
            }
            for (const unit of gameState.units) {
                if (unit.positionType === 'edge') {
                    const edge = gameState.edges.get(unit.position);
                    if (edge) edge.units.push(unit);
                }
            }
        }

        function fullGameRedraw() {
            // This function re-initializes the game's UI and re-renders the canvas from the current gameState.
            canvas.width = (2 * gameState.gridRadius + 1.5) * (HEX_SIZE * Math.sqrt(3));
            canvas.height = (2 * gameState.gridRadius + 1) * (HEX_SIZE * 2 * 0.75) + HEX_SIZE;
            document.querySelectorAll('.ui-panel').forEach(panel => { panel.style.minHeight = canvas.height + 'px'; });

            // Reset any non-persistent state properties that might affect drawing
            gameState.isDragging = false;
            gameState.draggingUnit = null;
            gameState.hoveredUnitId = null;

            // Update all UI panels with current data
            updateTurnDisplay();
            updateGlobalTurnDisplay();
            updateSupplyPointsDisplay();
            updateRespawnQueueDisplay();
            updateActionLogDisplay();
            updateSelectedUnitInfoPanel();

            if (gameState.gameOver) {
                ui.endTurnButton.disabled = true;
                ui.actionsPanel.style.display = 'none';
                ui.victoryMessage.textContent = "Game Over (Loaded)";
                ui.victoryMessage.style.display = 'block';
            } else {
                ui.victoryMessage.style.display = 'none';
                ui.endTurnButton.disabled = false;
            }
            // A single call to gameLoop will trigger a full redraw of the canvas
            requestAnimationFrame(gameLoop);
        }

// ========================================================================
// --- NEW IMPROVED MAP GENERATOR (V3 - Corrected) ---
// ========================================================================

function generateImprovedMap(radius) {
    const tempTiles = new Map();
    const allHexCoords = [];
    for (let q = -radius; q <= radius; q++) {
        for (let r = -radius; r <= radius; r++) {
            if (Math.abs(q + r) <= radius) {
                allHexCoords.push({ q, r });
            }
        }
    }

    // --- 1. Define Base Area Keys ---
    const p1BaseAreaKeys = new Set(['-3,1', '-2,1', '-2,2', '-3,2']);
    const p2BaseAreaKeys = new Set(['3,-1', '2,-1', '2,-2', '3,-2']);

    // --- 2. Generate Water Archetype ---
    const archetypes = ['coastline', 'river'];
    const chosenArchetype = archetypes[Math.floor(Math.random() * archetypes.length)];
    console.log(`Generating map with archetype: ${chosenArchetype}`);

    if (chosenArchetype === 'coastline') {
        generateCoastline(tempTiles, allHexCoords, radius);
    } else if (chosenArchetype === 'river') {
        generateRiver(tempTiles, allHexCoords, radius);
    }

    // --- 3. Generate Mountains ---
    // Let mountains generate anywhere for now, we can overwrite them later if needed.
    allHexCoords.forEach(coord => {
        const key = getTileKey(coord.q, coord.r);
        if (tempTiles.has(key)) return; // Don't overwrite existing water

        if (Math.random() < 0.18) {
            tempTiles.set(key, TILE_TYPES.MOUNTAIN);
        }
    });

    // --- 4. Guarantee Two Paths ---
    // This step is allowed to "carve" through any terrain, including mountains or water.
    const p1_start_node = '-3,1';
    const p2_end_node = '3,-1';
    const firstPath = findAndCarvePath(p1_start_node, p2_end_node, tempTiles, []);
    if (firstPath) {
        findAndCarvePath(p1_start_node, p2_end_node, tempTiles, firstPath);
    }

    // --- 5. Fill Remaining Empty Space ---
    // Any tile that hasn't been assigned a type yet gets forest or plains.
    allHexCoords.forEach(coord => {
        const key = getTileKey(coord.q, coord.r);
        if (!tempTiles.has(key)) {
            if (Math.random() < 0.45) {
                tempTiles.set(key, TILE_TYPES.FOREST);
            } else {
                tempTiles.set(key, TILE_TYPES.PLAINS);
            }
        }
    });

    // --- 6. ABSOLUTE FINAL STEP: Force Base Areas to be Plains ---
    // This is the last operation. It overwrites anything that was placed in the
    // base areas, including water, mountains, or paths.
    p1BaseAreaKeys.forEach(key => tempTiles.set(key, TILE_TYPES.PLAINS));
    p2BaseAreaKeys.forEach(key => tempTiles.set(key, TILE_TYPES.PLAINS));

    return tempTiles;
}

/** Generates a coastline on one side of the map. */
function generateCoastline(tiles, allCoords, radius) {
    const side = Math.floor(Math.random() * 6); // 0 to 5, picks a side of the hex map
    const direction = AXIAL_DIRECTIONS[side];
    
    allCoords.forEach(coord => {
        const projection = coord.q * direction.q + coord.r * direction.r;
        if (projection >= radius - 1) {
            tiles.set(getTileKey(coord.q, coord.r), TILE_TYPES.WATER);
        }
    });
}

/** Generates a winding river across the map. */
function generateRiver(tiles, allCoords, radius) {
    const edgeCoords = allCoords.filter(c => axialDistance(c.q, c.r, 0, 0) === radius);
    let current = edgeCoords[Math.floor(Math.random() * edgeCoords.length)];
    let riverPath = new Set();
    
    for(let i = 0; i < radius * 2.5; i++) {
         const key = getTileKey(current.q, current.r);
         if(riverPath.has(key)) break;
         riverPath.add(key);
         tiles.set(key, TILE_TYPES.WATER);

         const neighbors = getNeighbors(current.q, current.r).filter(n => isCoordInRadius(getTileKey(n.q, n.r), radius));
         if(neighbors.length > 0 && Math.random() > 0.4) {
             const randomNeighbor = neighbors[Math.floor(Math.random() * neighbors.length)];
             const neighborKey = getTileKey(randomNeighbor.q, randomNeighbor.r);
             if(!riverPath.has(neighborKey)) {
                 riverPath.add(neighborKey);
                 tiles.set(neighborKey, TILE_TYPES.WATER);
             }
         }
         
         let bestNeighbor = null;
         let maxDist = -Infinity;
         for(const n of neighbors) {
             const dist = -1 * (n.q * current.q + n.r * current.r);
             if (dist > maxDist) {
                 maxDist = dist;
                 bestNeighbor = n;
             }
         }
         if (bestNeighbor) {
             current = bestNeighbor;
         } else {
             break;
         }
    }
}


/**
 * Finds a path between two hexes. If no path exists, it carves one.
 * @param {string} startKey - The starting hex key (e.g., 'q,r').
 * @param {string} endKey - The target hex key.
 * @param {Map} tiles - The map of tiles to operate on.
 * @param {Array<string>} excludedKeys - An array of hex keys to ignore during pathfinding.
 * @returns {Array<string>|null} The path as an array of keys, or null if failed.
 */
function findAndCarvePath(startKey, endKey, tiles, excludedKeys = []) {
    let openSet = [startKey];
    const cameFrom = new Map();
    const gScore = new Map();
    gScore.set(startKey, 0);
    const fScore = new Map();
    const [sq, sr] = startKey.split(',').map(Number);
    const [eq, er] = endKey.split(',').map(Number);
    fScore.set(startKey, axialDistance(sq, sr, eq, er));
    const excludedSet = new Set(excludedKeys);

    while (openSet.length > 0) {
        let currentKey = openSet.sort((a, b) => (fScore.get(a) || Infinity) - (fScore.get(b) || Infinity))[0];

        if (currentKey === endKey) {
            return reconstructPath(cameFrom, currentKey);
        }

        openSet = openSet.filter(key => key !== currentKey);
        const [cq, cr] = currentKey.split(',').map(Number);
        const neighbors = getNeighbors(cq, cr).map(n => getTileKey(n.q, n.r));

        for (const neighborKey of neighbors) {
            if (!tiles.has(neighborKey) && !isCoordInRadius(neighborKey, GRID_RADIUS)) continue;
            const tile = tiles.get(neighborKey);
            const isPassable = tile !== TILE_TYPES.WATER && tile !== TILE_TYPES.MOUNTAIN;
            if (excludedSet.has(neighborKey)) continue;

            if (isPassable) {
                const tentative_gScore = (gScore.get(currentKey) || Infinity) + 1;
                if (tentative_gScore < (gScore.get(neighborKey) || Infinity)) {
                    cameFrom.set(neighborKey, currentKey);
                    gScore.set(neighborKey, tentative_gScore);
                    const [nq, nr] = neighborKey.split(',').map(Number);
                    fScore.set(neighborKey, tentative_gScore + axialDistance(nq, nr, eq, er));
                    if (!openSet.includes(neighborKey)) {
                        openSet.push(neighborKey);
                    }
                }
            }
        }
    }

    console.log("No path found, attempting to carve.");
    let carvePath = [startKey];
    let currentCarveKey = startKey;
    for (let i = 0; i < 100; i++) {
        if (currentCarveKey === endKey) break;
        const [ccq, ccr] = currentCarveKey.split(',').map(Number);
        const neighbors = getNeighbors(ccq, ccr)
                            .map(n => ({ key: getTileKey(n.q, n.r), q: n.q, r: n.r }))
                            .filter(n => isCoordInRadius(n.key, GRID_RADIUS));
        let nextStep = neighbors.sort((a,b) => axialDistance(a.q, a.r, eq, er) - axialDistance(b.q, b.r, eq, er))[0];
        if (!nextStep) return null;
        if (tiles.get(nextStep.key) === TILE_TYPES.WATER || tiles.get(nextStep.key) === TILE_TYPES.MOUNTAIN) {
            tiles.set(nextStep.key, TILE_TYPES.PLAINS);
        }
        currentCarveKey = nextStep.key;
        carvePath.push(currentCarveKey);
    }
    return carvePath;
}

/** Reconstructs a path from the 'cameFrom' map of an A* search. */
function reconstructPath(cameFrom, currentKey) {
    const totalPath = [currentKey];
    while (cameFrom.has(currentKey)) {
        currentKey = cameFrom.get(currentKey);
        totalPath.unshift(currentKey);
    }
    return totalPath;
}

/** Checks if a given hex coordinate key is within the map radius */
function isCoordInRadius(key, radius) {
    const [q, r] = key.split(',').map(Number);
    if (isNaN(q) || isNaN(r)) return false;
    return Math.abs(q) <= radius && Math.abs(r) <= radius && Math.abs(q + r) <= radius;
}

        function placeUnitsOnNewGeneratedMap() {
            const landEdges = [];
            gameState.edges.forEach((edgeData, edgeKey) => {
                const tileCoords = parseEdgeKey(edgeKey);
                const tile1 = gameState.tiles.get(getTileKey(tileCoords[0].q, tileCoords[0].r));
                const tile2 = gameState.tiles.get(getTileKey(tileCoords[1].q, tileCoords[1].r));
                if (tile1 && tile2 && isLand(tile1.type) && isLand(tile2.type)) {
                    landEdges.push(edgeKey);
                }
            });

            if (landEdges.length < 8) {
                console.error(`CRITICAL: Not enough land edges (${landEdges.length}). Placing randomly.`);
                landEdges.sort(() => 0.5 - Math.random());
                const usedEdgesFallback = new Set();
                const allUnitTypes = [UNIT_TYPES.MELEE, UNIT_TYPES.ARCHER, UNIT_TYPES.PIKEMAN, UNIT_TYPES.HORSEMAN];

                const placeFallbackTeam = (player) => {
                    allUnitTypes.forEach(type => {
                        let placed = false;
                        for (const edgeKey of landEdges) {
                            if (!usedEdgesFallback.has(edgeKey)) {
                                gameState.units.push(createUnit(player, type, edgeKey));
                                usedEdgesFallback.add(edgeKey);
                                placed = true;
                                break;
                            }
                        }
                        if (!placed) console.error(`Could not place P${player} ${type.name}`);
                    });
                };
                placeFallbackTeam(1);
                placeFallbackTeam(2);
            } else {
                const p1CandidateEdges = [];
                const p2CandidateEdges = [];
                const hemisphereThresholdQ = 0;
                landEdges.forEach(edgeKey => {
                    const coords = parseEdgeKey(edgeKey);
                    const avgQ = (coords[0].q + coords[1].q) / 2;
                    if (avgQ < hemisphereThresholdQ) {
                        p1CandidateEdges.push({ key: edgeKey, q: avgQ });
                    } else {
                        p2CandidateEdges.push({ key: edgeKey, q: avgQ });
                    }
                });

                p1CandidateEdges.sort((a, b) => a.q - b.q);
                p2CandidateEdges.sort((a, b) => b.q - a.q);

                const usedEdges = new Set();
                const allUnitTypes = [UNIT_TYPES.MELEE, UNIT_TYPES.ARCHER, UNIT_TYPES.PIKEMAN, UNIT_TYPES.HORSEMAN];

                const placeTeam = (playerNum, candidates) => {
                    let placedCount = 0;
                    for (const cand of candidates) {
                        if (placedCount >= 4) break;
                        if (!usedEdges.has(cand.key)) {
                            gameState.units.push(createUnit(playerNum, allUnitTypes[placedCount], cand.key));
                            usedEdges.add(cand.key);
                            placedCount++;
                        }
                    }
                    while (placedCount < 4) {
                        const fallbackEdge = landEdges.find(e => !usedEdges.has(e));
                        if(fallbackEdge) {
                             gameState.units.push(createUnit(playerNum, allUnitTypes[placedCount], fallbackEdge));
                             usedEdges.add(fallbackEdge);
                             placedCount++;
                        } else {
                            console.error(`Ran out of all possible land edges placing for P${playerNum}`);
                            break;
                        }
                    }
                };

                placeTeam(1, p1CandidateEdges);
                placeTeam(2, p2CandidateEdges);
            }

            gameState.units.forEach(unit => {
                if (!unit || !unit.position) {
                    console.error(`Invalid unit/pos after placement:`, unit);
                    gameState.units = gameState.units.filter(u => u && u.id !== (unit ? unit.id : undefined));
                    return;
                }
                const edge = gameState.edges.get(unit.position);
                if (edge) {
                    if (edge.units.length < 2) {
                        edge.units.push(unit);
                    } else {
                        console.warn(`Unit ${unit.id} on full edge ${unit.position}. Occupants: ${edge.units.map(u=>u.id).join(', ')}.`);
                    }
                } else {
                    console.error("CRITICAL: Edge not found for unit pos:", unit.position, unit);
                }
            });
        }

        ui.downloadButton.addEventListener('click', () => {
            try {
                const pageHTML = document.documentElement.outerHTML; const blob = new Blob([pageHTML], { type: 'text/html' });
                const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'FortHex.html';
                document.body.appendChild(a); a.click(); document.body.removeChild(a); URL.revokeObjectURL(a.href);
                showInstruction('Game HTML downloaded!', 2000);
            } catch (error) { console.error("Error downloading game:", error); showInstruction('Error downloading. See console.', 3000); }
        });

        if (ui.tutorialButton) {
            ui.tutorialButton.addEventListener('click', () => {
                if (ui.tutorialModalOverlay) {
                    ui.tutorialModalOverlay.style.display = 'flex'; 
                    setTimeout(() => {
                        ui.tutorialModalOverlay.classList.add('modal-visible');
                    }, 10); 
                }
            });
        }

        function closeTutorialModal() {
            if (ui.tutorialModalOverlay) {
                ui.tutorialModalOverlay.classList.remove('modal-visible');
                setTimeout(() => {
                    ui.tutorialModalOverlay.style.display = 'none';
                }, 300); 
            }
        }

        if (ui.tutorialCloseButton) {
            ui.tutorialCloseButton.addEventListener('click', closeTutorialModal);
        }
        if (ui.tutorialModalOverlay) {
            ui.tutorialModalOverlay.addEventListener('click', (event) => {
                if (event.target === ui.tutorialModalOverlay) { 
                    closeTutorialModal();
                }
            });
        }

        if (ui.tutorialSectionHeaders) {
            ui.tutorialSectionHeaders.forEach(header => {
                header.addEventListener('click', () => {
                    const content = header.nextElementSibling;
                    const arrow = header.querySelector('.tutorial-arrow');
                    const isActive = header.classList.contains('active');

                    ui.tutorialSectionHeaders.forEach(otherHeader => {
                        if (otherHeader !== header) {
                            otherHeader.classList.remove('active');
                            otherHeader.nextElementSibling.classList.remove('open');
                            const otherArrow = otherHeader.querySelector('.tutorial-arrow');
                            if (otherArrow) otherArrow.innerHTML = '&#9658;'; 
                        }
                    });

                    if (isActive) {
                        header.classList.remove('active');
                        content.classList.remove('open');
                        if (arrow) arrow.innerHTML = '&#9658;'; 
                    } else {
                        header.classList.add('active');
                        content.classList.add('open');
                        if (arrow) arrow.innerHTML = '&#9660;'; 
                    }
                });
            });
        }

        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousedown', handleCanvasMouseDown);
        canvas.addEventListener('mousemove', handleCanvasMouseMove);
        canvas.addEventListener('mouseup', handleCanvasMouseUp);
        window.addEventListener('mouseup', handleCanvasMouseUp);
        canvas.addEventListener('mouseleave', handleCanvasMouseLeave);
        canvas.addEventListener('touchstart', handleCanvasTouchStart, { passive: false });
        canvas.addEventListener('touchmove', handleCanvasTouchMove, { passive: false });
        canvas.addEventListener('touchend', handleCanvasTouchEnd);
        canvas.addEventListener('touchcancel', handleCanvasTouchCancel);

        window.onload = function () {
            document.getElementById('buildVersionDisplay').textContent = `FortHex Build ${BUILD_VERSION}`;
            
            loadSettings(); // Load settings from localStorage into the gameSettings object
            loadColorPreferences(); // ADD THIS LINE to load color preferences


            // Sync UI checkboxes to match the loaded settings
            document.getElementById('settingAnimations').checked = gameSettings.animationsEnabled;
            document.getElementById('settingFancyVisuals').checked = gameSettings.fancyVisualsEnabled;
            document.getElementById('settingPassTurnConfirmation').checked = gameSettings.passTurnConfirmationEnabled;
            document.getElementById('settingTooltips').checked = gameSettings.tooltipsEnabled;

            // --- Connection Status Indicator ---
            const connectionIcon = document.getElementById('connectionStatusIcon');

            function updateConnectionStatus() {
                if (navigator.onLine) {
                    connectionIcon.classList.remove('status-offline');
                    connectionIcon.classList.add('status-online');
                } else {
                    connectionIcon.classList.remove('status-online');
                    connectionIcon.classList.add('status-offline');
                }
            }

            window.addEventListener('online', updateConnectionStatus);
            window.addEventListener('offline', updateConnectionStatus);

            // Set initial state on load
            updateConnectionStatus();

            // --- Main Menu System Listeners ---
            document.getElementById('gameIconLink').addEventListener('click', (event) => {
                event.preventDefault(); 
                document.getElementById('customConfirmMessage').textContent = 'Are you sure you want to restart? Any unsaved progress will be lost.';
                currentConfirmAction = () => {
                    location.reload();
                };
                if (ui.customConfirmModal) {
                    ui.customConfirmModal.style.display = 'flex';
                    setTimeout(() => ui.customConfirmModal.classList.add('modal-visible'), 10);
                }
            });

            document.getElementById('gameMenuTrigger').addEventListener('click', () => {
                const modal = document.getElementById('gameMenuModal');
                document.getElementById('mainMenuContent').style.display = 'block';
                document.getElementById('singleplayerMenuContent').style.display = 'none';
                document.getElementById('multiplayerMenuContent').style.display = 'none';
                modal.style.display = 'flex';
                setTimeout(() => modal.classList.add('modal-visible'), 10);
            });

            const mainMenuContent = document.getElementById('mainMenuContent');
            const spMenuContent = document.getElementById('singleplayerMenuContent');
            const mpMenuContent = document.getElementById('multiplayerMenuContent');

            document.getElementById('singleplayerButton').addEventListener('click', () => {
                mainMenuContent.style.display = 'none';
                spMenuContent.style.display = 'block';
            });

            document.getElementById('multiplayerButton').addEventListener('click', () => {
                mainMenuContent.style.display = 'none';
                mpMenuContent.style.display = 'block';
            });

            document.getElementById('playAsBlueButton').addEventListener('click', () => startSingleplayerGame(1));
            document.getElementById('playAsRedButton').addEventListener('click', () => startSingleplayerGame(2));

            document.getElementById('localMultiplayerButton').addEventListener('click', () => location.reload());

            document.getElementById('backToMainMenuButtonSP').addEventListener('click', () => {
                spMenuContent.style.display = 'none';
                mainMenuContent.style.display = 'block';
            });
            document.getElementById('backToMainMenuButtonMP').addEventListener('click', () => {
                mpMenuContent.style.display = 'none';
                mainMenuContent.style.display = 'block';
            });

            document.getElementById('gameMenuModal').addEventListener('click', (e) => {
                if (e.target.id === 'gameMenuModal') {
                    const modal = e.target;
                    modal.classList.remove('modal-visible');
                    setTimeout(() => modal.style.display = 'none', 300);
                }
            });

            const settingsButton = document.getElementById('settingsButton');
            const settingsModal = document.getElementById('settingsModal');
            const settingsBackButton = document.getElementById('settingsBackButton');
            const gameMenuModal = document.getElementById('gameMenuModal');

            settingsButton.addEventListener('click', () => {
                if (gameMenuModal) {
                    gameMenuModal.classList.remove('modal-visible');
                    setTimeout(() => { gameMenuModal.style.display = 'none'; }, 300);
                }
                if (settingsModal) {
                    setTimeout(() => {
                        settingsModal.style.display = 'flex';
                        setTimeout(() => settingsModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            settingsBackButton.addEventListener('click', () => {
                if (settingsModal) {
                    settingsModal.classList.remove('modal-visible');
                    setTimeout(() => { settingsModal.style.display = 'none'; }, 300);
                }
                if (gameMenuModal) {
                     setTimeout(() => {
                        gameMenuModal.style.display = 'flex';
                        setTimeout(() => gameMenuModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            settingsModal.addEventListener('click', (e) => {
                if (e.target.id === 'settingsModal') {
                    const modal = e.target;
                    modal.classList.remove('modal-visible');
                    setTimeout(() => modal.style.display = 'none', 300);
                }
            });

            // --- Changelog Modal Listeners ---
            const changelogButton = document.getElementById('changelogButton');
            const changelogModal = document.getElementById('changelogModal');
            const changelogBackButton = document.getElementById('changelogBackButton');

            changelogButton.addEventListener('click', () => {
                if (gameMenuModal) {
                    gameMenuModal.classList.remove('modal-visible');
                    setTimeout(() => { gameMenuModal.style.display = 'none'; }, 300);
                }
                if (changelogModal) {
                    setTimeout(() => {
                        changelogModal.style.display = 'flex';
                        setTimeout(() => changelogModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            changelogBackButton.addEventListener('click', () => {
                if (changelogModal) {
                    changelogModal.classList.remove('modal-visible');
                    setTimeout(() => { changelogModal.style.display = 'none'; }, 300);
                }
                if (gameMenuModal) {
                     setTimeout(() => {
                        gameMenuModal.style.display = 'flex';
                        setTimeout(() => gameMenuModal.classList.add('modal-visible'), 10);
                    }, 350);
                }
            });

            changelogModal.addEventListener('click', (e) => {
                if (e.target.id === 'changelogModal') {
                    hideAllModals(); // Close all modals and return to the game
                }
            });

            const gameWrapper = document.getElementById('gameWrapper');
            const animationsCheckbox = document.getElementById('settingAnimations');
            const passTurnCheckbox = document.getElementById('settingPassTurnConfirmation');
            const fancyVisualsCheckbox = document.getElementById('settingFancyVisuals');
            const tooltipsCheckbox = document.getElementById('settingTooltips');
            const uiScaleSlider = document.getElementById('settingUiScale');
            const uiScaleValueLabel = document.getElementById('uiScaleValueLabel');

            function applyUiScale() {
                uiScaleSlider.value = gameSettings.uiScale;
                uiScaleValueLabel.textContent = `${Math.round(gameSettings.uiScale * 100)}%`;
                gameWrapper.style.transform = `scale(${gameSettings.uiScale})`;
            }

            loadSettings(); 

            animationsCheckbox.checked = gameSettings.animationsEnabled;
            passTurnCheckbox.checked = gameSettings.passTurnConfirmationEnabled;
            fancyVisualsCheckbox.checked = gameSettings.fancyVisualsEnabled;
            tooltipsCheckbox.checked = gameSettings.tooltipsEnabled;
            applyUiScale(); 

            animationsCheckbox.addEventListener('change', (e) => {
                gameSettings.animationsEnabled = e.target.checked;
                saveSettings();
            });

            passTurnCheckbox.addEventListener('change', (e) => {
                gameSettings.passTurnConfirmationEnabled = e.target.checked;
                saveSettings();
            });
            
            fancyVisualsCheckbox.addEventListener('change', (e) => {
                gameSettings.fancyVisualsEnabled = e.target.checked;
                saveSettings();
            });

            tooltipsCheckbox.addEventListener('change', (e) => {
                gameSettings.tooltipsEnabled = e.target.checked;
                saveSettings();
            });

            uiScaleSlider.addEventListener('input', (e) => {
                const scaleValue = parseFloat(e.target.value);
                gameSettings.uiScale = scaleValue;
                applyUiScale(); 
                saveSettings(); 
            });

            const customConfirmModalOverlay = document.getElementById('customConfirmModal');
            customConfirmModalOverlay.addEventListener('click', (event) => {
                if (event.target === customConfirmModalOverlay) {
                    if (ui.customConfirmModal) {
                        ui.customConfirmModal.classList.remove('modal-visible');
                        setTimeout(() => ui.customConfirmModal.style.display = 'none', 300);
                        currentConfirmAction = null; 
                    }
                }
            });

            const loadGameModalOverlay = document.getElementById('loadGameModal');
            loadGameModalOverlay.addEventListener('click', (event) => {
                if (event.target === loadGameModalOverlay) {
                    hideLoadGameModal();
                }
            });

            document.getElementById('loadFromAutosaveButton').addEventListener('click', () => {
                if (localStorage.getItem('forthexSaveGame')) {
                    loadAutoSave();
                    hideLoadGameModal();
                } else {
                    showInstruction("No autosave found.", 2000);
                }
            });

            document.getElementById('loadFromFileButton').addEventListener('click', () => {
                document.getElementById('fileLoaderInput').click();
            });

            document.getElementById('fileLoaderInput').addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) {
                    return; 
                }

                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const loadedState = JSON.parse(e.target.result);
                        if (loadedState.saveVersion !== BUILD_VERSION) {
                            showInstruction("Save file is from an incompatible version.", 3000);
                            return;
                        }
                        gameState = loadedState;
                        rehydrateGameState(); // Re-link data
                        fullGameRedraw();
                        hideLoadGameModal();
                        showInstruction("Game loaded from file!", 2000);
                    } catch (error) {
                        console.error("Failed to load from file:", error);
                        showInstruction("Error: Invalid or corrupted save file.", 3000);
                    }
                };
                reader.readAsText(file);
                event.target.value = null; 
            });

            const respawnChoicesDiv = document.getElementById('respawnChoices');
            if (respawnChoicesDiv) {
                respawnChoicesDiv.addEventListener('click', (event) => {
                    const button = event.target.closest('.respawn-button');
                    if (button) {
                        const unitTypeName = button.dataset.unitType;
                        const unitType = UNIT_TYPES[unitTypeName];
                        
                        if (unitType) {
                            const spawnSuccess = spawnUnit(gameState.currentPlayer, unitType);

                            if (spawnSuccess) {
                                const queueKey = `player${gameState.currentPlayer}`;
                                gameState.respawnQueue[queueKey].shift(); 
                                updateRespawnQueueDisplay(); 
                                const queue = gameState.respawnQueue[queueKey];
                                const nextInQueue = queue.length > 0 ? queue[0] : null;

                                if (nextInQueue && nextInQueue.turnsRemaining <= 0) {
                                    showRespawnModal(gameState.currentPlayer);
                                } else {
                                    hideRespawnModal();
                                }
                            } else {
                                showInstruction("Could not spawn unit, base is blocked!", 3000);
                                hideRespawnModal();
                            }
                        }
                    }
                });
            }

            gameState.gridRadius = GRID_RADIUS; 
            initializeGrid();
            // This is the important call to our new function
            updateCssVariables(); 
            populateColorPickers();
            gameLoop();
            showInstruction("Project Hexblade Loaded. Player 1's Turn.", 3000);

            // --- Color Picker Drawer Logic ---
            const colorPickerDrawer = document.getElementById('colorPickerDrawer');
            const drawerHandle = document.getElementById('drawerHandle');
            const drawerTabs = document.getElementById('drawerTabs');
            const tabButtons = document.querySelectorAll('.drawer-tab-button');
            const drawerIcon = drawerHandle.querySelector('svg');
            const tabContent = document.getElementById('drawerTabContent');

            // This function now only CREATES the 5 circles once.
            function populateColorPickers() {
                const container = document.getElementById('color-options');
                if (!container) return;

                container.innerHTML = ''; // Clear any existing circles

                for (let i = 0; i < COLOR_THEMES.length; i++) {
                    const circle = document.createElement('div');
                    circle.className = 'color-option-circle';
                    circle.dataset.themeIndex = i;
                    // Player dataset is now set dynamically when tabs are switched
                    container.appendChild(circle);
                }

                // Set the initial colors and active state to Player 1's palette
                updateColorPickerCircles('player1');
            }

            // This function UPDATES the colors and active state of the 5 circles
            function updateColorPickerCircles(playerKey) {
                const container = document.getElementById('color-options');
                if (!container) return;
                const circles = container.querySelectorAll('.color-option-circle');
                const activeThemeIndex = gameState.playerColorSelections[playerKey];

                circles.forEach((circle, index) => {
                    const theme = COLOR_THEMES[index];
                    circle.style.backgroundColor = theme[playerKey].primary;
                    circle.dataset.player = playerKey.slice(-1); // Set player to '1' or '2'
                    
                    // Update which circle is highlighted as active
                    circle.classList.toggle('active', index === activeThemeIndex);
                });
            }

            // Helper function to update the drawer's border/icon colors based on the active tab
            function updateDrawerColors() {
                const activeTab = document.querySelector('.drawer-tab-button.active');
                if (!activeTab) return;

                const activePlayerKey = activeTab.dataset.tab === 'p1' ? 'player1' : 'player2';
                
                if (colorPickerDrawer.classList.contains('drawer-open')) {
                    colorPickerDrawer.style.borderColor = TEAM_COLORS[activePlayerKey].primary;
                    drawerHandle.style.borderColor = TEAM_COLORS[activePlayerKey].primary;
                    drawerIcon.style.stroke = TEAM_COLORS[activePlayerKey].accent;
                } else {
                    colorPickerDrawer.style.borderColor = '#ecf0f1';
                    drawerHandle.style.borderColor = '#ecf0f1';
                    drawerIcon.style.stroke = '#ecf0f1';
                }
            }

            // Event handler for clicking a color circle
            function handleColorSelection(event) {
                const circle = event.target.closest('.color-option-circle');
                if (!circle) return;

                const player = circle.dataset.player; // '1' or '2'
                const themeIndex = parseInt(circle.dataset.themeIndex, 10);
                const playerKey = `player${player}`;
                const otherPlayerKey = player === '1' ? 'player2' : 'player1';

                // --- Start the transition ---
                gameState.colorTransition.active = true;
                gameState.colorTransition.startTime = Date.now();
                
                // Store the 'from' and 'to' color objects for BOTH players
                gameState.colorTransition.from.player1 = { ...TEAM_COLORS.player1 };
                gameState.colorTransition.from.player2 = { ...TEAM_COLORS.player2 };
                gameState.colorTransition.to[playerKey] = { ...COLOR_THEMES[themeIndex][playerKey] };
                gameState.colorTransition.to[otherPlayerKey] = { ...TEAM_COLORS[otherPlayerKey] }; // The other player's color doesn't change

                // 1. Update the live TEAM_COLORS object for ONLY the selected player
                TEAM_COLORS[playerKey] = { ...COLOR_THEMES[themeIndex][playerKey] };
                gameState.playerColorSelections[playerKey] = themeIndex; // Remember this selection

                // 2. Update the active circle visuals
                const container = circle.parentElement;
                container.querySelectorAll('.color-option-circle').forEach(c => c.classList.remove('active'));
                circle.classList.add('active');

                // 3. Update all DOM UI elements instantly
                updateCssVariables();
                updateTurnDisplay();
                updateDrawerColors();
                saveColorPreferences(); 
            }

            // Open/Close the drawer
            drawerHandle.addEventListener('click', () => {
                colorPickerDrawer.classList.toggle('drawer-open');
                updateDrawerColors();
            });

            // Switch between P1 and P2 tabs
            drawerTabs.addEventListener('click', (e) => {
                const clickedButton = e.target.closest('.drawer-tab-button');
                if (!clickedButton) return;
                
                const targetTabId = clickedButton.dataset.tab;
                const playerKey = targetTabId === 'p1' ? 'player1' : 'player2';

                // Update button active state
                tabButtons.forEach(button => {
                    button.classList.toggle('active', button.dataset.tab === targetTabId);
                });

                // This is the fix: Update the circle colors and then the drawer border
                updateColorPickerCircles(playerKey);
                updateDrawerColors();
            });

            // Attach the click listener for selecting a color
            if (tabContent) {
                tabContent.addEventListener('click', handleColorSelection);
            }

            // Close drawer if clicking outside
            document.addEventListener('click', (e) => {
                if (colorPickerDrawer.classList.contains('drawer-open') && !colorPickerDrawer.contains(e.target)) {
                    colorPickerDrawer.classList.remove('drawer-open');
                    updateDrawerColors(); // Reset colors when closing
                }
            });

            // Prevent outside-click from firing on the handle itself
            drawerHandle.addEventListener('click', (e) => {
                e.stopPropagation();
            });
            // --- End of Color Picker Drawer Logic ---
        }
    </script>
          
<div id="buildVersionDisplay"></div>
<div id="confettiContainer"></div>

<div id="colorPickerDrawer">
    <div id="drawerHandle">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
            <path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0L12 2.69z"></path>
        </svg>
    </div>
    <div id="drawerContent">
        <div id="drawerTabs">
            <button class="drawer-tab-button active p1-tab" data-tab="p1">P1</button>
            <button class="drawer-tab-button p2-tab" data-tab="p2">P2</button>
        </div>
        <div id="drawerTabContent">
            <div id="color-options" class="color-options-container">
                <!-- All 5 circles generated by JS -->
            </div>
        </div>
    </div>
</div>

</body></html>